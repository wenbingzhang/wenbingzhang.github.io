[{"id":0,"href":"/notes/2025/02/10/7auahqg8nnxm5ydhxzqrnr/","title":"📝 调用Python代码","section":"🔖 Python","content":"#include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;Python.h\u0026gt; // 包含 Python 头文件 int main() { // 初始化 Python 解释器 Py_Initialize(); // 创建一个 Python 字典来传递参数 PyObject* pName = PyUnicode_FromString(\u0026#34;__main__\u0026#34;); PyObject* pModule = PyImport_Import(pName); Py_XDECREF(pName); if (pModule != nullptr) { // 创建一个全局字典来存储参数 PyObject* pGlobals = PyModule_GetDict(pModule); // 将参数作为 Python 对象添加到全局字典中 PyDict_SetItemString(pGlobals, \u0026#34;param1\u0026#34;, PyLong_FromLong(42)); // 示例参数1 PyDict_SetItemString(pGlobals, \u0026#34;param2\u0026#34;, PyUnicode_FromString(\u0026#34;Hello from C++\u0026#34;)); // 示例参数2 // 定义并执行 Python 代码 const char* script = R\u0026#34;( import platform import sys import os system_info = { \u0026#39;param1\u0026#39;: param1, \u0026#39;param2\u0026#39;: param2, \u0026#39;OS\u0026#39;: platform.system(), \u0026#39;OS Version\u0026#39;: platform.version(), \u0026#39;Release\u0026#39;: platform.release(), \u0026#39;Machine\u0026#39;: platform.machine(), \u0026#39;Processor\u0026#39;: platform.processor(), \u0026#39;Python Version\u0026#39;: sys.version, } print(system_info) )\u0026#34;; // 执行 Python 代码 const auto result = PyRun_SimpleString(script); std::cout \u0026lt;\u0026lt; \u0026#34;Result from Python: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; Py_XDECREF(pModule); } else { PyErr_Print(); std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to load the Python script\u0026#34; \u0026lt;\u0026lt; std::endl; } // 关闭 Python 解释器 Py_Finalize(); return 0; } "},{"id":1,"href":"/notes/2024/08/01/rnc4n7cfifidx8ca2rhjme/","title":"📝 QML鼠标事件","section":"🔖 Qt","content":" 示例代码 # import QtQuick 2.15 import QtQuick.Controls 2.15 ApplicationWindow { visible: true width: 640 height: 480 Rectangle { id: container width: 200 height: 200 color: \u0026#34;lightblue\u0026#34; MouseArea { anchors.fill: parent onEntered: { console.log(\u0026#34;Mouse entered\u0026#34;) container.color = \u0026#34;lightgreen\u0026#34; } onExited: { console.log(\u0026#34;Mouse exited\u0026#34;) container.color = \u0026#34;lightblue\u0026#34; } } } } 问题描述 # 鼠标进入矩形区域时，不会改变矩形的颜色。\n解决方法 # 需要在MouseArea中设置hoverEnabled: true属性，这样鼠标进入矩形区域时，会触发onEntered事件，改变矩形的颜色。\n"},{"id":2,"href":"/notes/2024/06/06/sf4ff6x8cuyhvzougj9dwg/","title":"📝 MacOS签名","section":"🔖 MacOS相关","content":" 下载根证书 # https://www.apple.com/certificateauthority/DeveloperIDG2CA.cer\n导入根证书 # sudo security import ~/Downloads/DeveloperIDG2CA.cer \\ -k /Library/Keychains/System.keychain \\ -T /usr/bin/codesign \\ -T /usr/bin/security \\ -T /usr/bin/productbuild 查看和清理特殊属性 # xattr -lr xxx.app xattr -cr xxx.app 签发APP # codesign --deep --force --verbose --sign \u0026#34;xxxx\u0026#34; xxx.app 验证签名 # spctl --assess --type execute --verbose=4 xxx.app 参考文档 # https://testerhome.com/topics/33338\nhttps://www.apple.com/certificateauthority/\nhttps://www.jianshu.com/p/f420649fba42\n"},{"id":3,"href":"/notes/2024/03/11/j3c62fv8dglvf2kg975zlv/","title":"📝 标签操作","section":"📔 Git","content":" 创建标签 # git tag \u0026lt;tagname\u0026gt; 推送标签到远程仓库 # git push origin \u0026lt;tagname\u0026gt; 推送所有标签到远程仓库 # git push origin --tags 查看本地所有标签 # git tag 查看远程所有标签 # git ls-remote --tags origin 删除本地或远程标签 # git tag -d \u0026lt;tagname\u0026gt; # 删除远程标签 git push origin :refs/tags/\u0026lt;tagname\u0026gt; "},{"id":4,"href":"/notes/2024/03/06/e3ksq3zkmps14gcxuirwzx/","title":"📝 所有权","section":"🔖 学习笔记","content":" 所有权 # 所有权规则 # Rust 中的每一个值都有一个 所有者（owner）。 值在任一时刻有且只有一个所有者。 当所有者（变量）离开作用域，这个值将被丢弃。 可Copy的类型 # 所有整数类型，比如 u32 。 布尔类型，bool ，它的值是 true 和 false 。 所有浮点数类型，比如 f64 。 字符类型，char 。 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy ，但(i32, String) 就没有。 "},{"id":5,"href":"/notes/2025/02/10/gqci9riugfetribe6j6fou/","title":"📝 调用Python方法","section":"🔖 Python","content":"#include \u0026lt;Python.h\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { // 初始化 Python 解释器 Py_Initialize(); // 创建 Python 字典并将参数传递给 Python PyObject* pName = PyUnicode_FromString(\u0026#34;__main__\u0026#34;); PyObject* pModule = PyImport_Import(pName); Py_XDECREF(pName); if (pModule != nullptr) { // 创建一个全局字典来存储参数 PyObject* pGlobals = PyModule_GetDict(pModule); // 创建 Python 函数 const char* func_code = R\u0026#34;( def my_function(param1, param2): return f\u0026#34;Received param1: {param1}, param2: {param2}\u0026#34; )\u0026#34;; // 执行定义函数的代码 PyRun_SimpleString(func_code); // 获取 Python 函数对象 PyObject* pFunc = PyDict_GetItemString(pGlobals, \u0026#34;my_function\u0026#34;); if (PyCallable_Check(pFunc)) { // 准备参数 PyObject* pArgs = PyTuple_Pack(2, PyLong_FromLong(42), PyUnicode_FromString(\u0026#34;Hello from C++\u0026#34;)); // 调用函数 PyObject* pValue = PyObject_CallObject(pFunc, pArgs); if (pValue != nullptr) { // 打印函数返回值 std::cout \u0026lt;\u0026lt; \u0026#34;Function returned: \u0026#34; \u0026lt;\u0026lt; PyUnicode_AsUTF8(pValue) \u0026lt;\u0026lt; std::endl; Py_XDECREF(pValue); } else { PyErr_Print(); } Py_XDECREF(pArgs); } else { PyErr_Print(); } } else { PyErr_Print(); std::cerr \u0026lt;\u0026lt; \u0026#34;Failed to load the Python module\u0026#34; \u0026lt;\u0026lt; std::endl; } // 关闭 Python 解释器 Py_Finalize(); return 0; } "},{"id":6,"href":"/notes/2024/08/06/ny773erqjgbzmzgfikfvds/","title":"📝 QML虚拟列表","section":"🔖 Qt","content":"import QtQuick 2.15 import QtQuick.Controls 2.15 ApplicationWindow { visible: true width: 640 height: 28 Flickable { id: flickable width: parent.width height: parent.height contentWidth: 51200 // 根据需要调整刻度尺长度（1000个刻度，每个刻度间隔51.2） clip: true Component.onCompleted: updateVisibleRange() onContentXChanged: updateVisibleRange() onWidthChanged: updateVisibleRange() function updateVisibleRange() { var itemWidth = 51.2; var firstIndex = Math.floor(flickable.contentX / itemWidth); var visibleCount = Math.ceil(flickable.width / itemWidth) + 1; firstVisibleIndex = firstIndex; lastVisibleIndex = firstIndex + visibleCount; createVisibleItems(); } property int firstVisibleIndex: 0 property int lastVisibleIndex: 0 function createVisibleItems() { itemContainer.children.forEach(function(item) { item.destroy(); }); for (var i = firstVisibleIndex; i \u0026lt;= lastVisibleIndex; i++) { var item = itemComponent.createObject(itemContainer, { index: i, width: 1, height: flickable.height, x: i * 51.2 }); } } Item { id: itemContainer anchors.fill: parent } Component { id: itemComponent Item { property int index Rectangle { property int itemIndex: index anchors.bottom: parent.bottom width: 1 height: index % 10 === 0 ? 18 : index % 5 === 0 ? 9 : 4 color: \u0026#34;black\u0026#34; Repeater { model: index % 10 === 0 ? 1 : 0 Label { anchors.left: parent.right anchors.leftMargin: 2 anchors.bottom: parent.bottom anchors.bottomMargin: 4 // color: activePalette.windowText text: parent.itemIndex } } } } } } } "},{"id":7,"href":"/notes/2024/05/28/3txbbb7iruppjsg4p7rwnb/","title":"📝 MacOS堆栈大小","section":"🔖 MacOS相关","content":" 问题代码 # char buffer[8*1024*1024]; 问题分析 # macos系统默认的堆栈大小为8MB，可以通过ulimit命令查看和修改。 但是，如果代码中使用了大量的堆栈变量，可能会导致栈溢出，导致程序崩溃。 # 查看系统默认的堆栈大小 ulimit -a # 或者 ulimit -s 解决方案 # char *buffer = new char[8*1024*1024]; // 记得释放 delete[] buffer; "},{"id":8,"href":"/notes/2024/03/14/5kqlzqjqawbxf2t6vusxar/","title":"📝 删除Commit","section":"📔 Git","content":"# 获取commit信息 git log # commit-id 要删除commit的下一个commit-id git rebase -i (commit-id) # 编辑文件，将要删除的commit之前的pick改为drop # 保存文件退出 # 再次查看commit信息，确认删除成功 git log "},{"id":9,"href":"/notes/2024/03/06/o4arkqgfnqygr5ckif2gkk/","title":"📝 借用与引用","section":"🔖 学习笔记","content":" 借用与引用 # 创建一个引用的行为称为 借用 允许使用值但不获取其所有权 引用规则 # 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。 引用必须总是有效的。 可变引用 # 允许修改一个借用的值，这就是可变引用（\u0026amp;mut）。\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;mut s); } fn change(some_string: \u0026amp;mut String) { some_string.push_str(\u0026#34;, world\u0026#34;); } 悬垂引用（Dangling References） # fn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { // dangle 返回一个字符串的引用 let s = String::from(\u0026#34;hello\u0026#34;); // s 是一个新字符串 \u0026amp;s // 返回字符串 s 的引用 } // 这里 s 离开作用域并被丢弃。其内存被释放。 // 危险！ "},{"id":10,"href":"/notes/2025/02/10/pkdrvn9md3ggfmbxahx4ef/","title":"📝 注册Python模块","section":"🔖 Python","content":"#include \u0026lt;Python.h\u0026gt; #include \u0026lt;iostream\u0026gt; // 示例结构体（C++对象） struct MyStruct { int value; }; // C++ 从 Python 获取 `void*` 并使用 static PyObject* use_object(PyObject* self, PyObject* args) { PyObject* capsule; if (!PyArg_ParseTuple(args, \u0026#34;O\u0026#34;, \u0026amp;capsule)) { return nullptr; } // 取回 `void*` 并转换回 C++ 指针 auto* obj = static_cast\u0026lt;MyStruct*\u0026gt;(PyCapsule_GetPointer(capsule, \u0026#34;this\u0026#34;)); if (!obj) { PyErr_SetString(PyExc_RuntimeError, \u0026#34;Invalid capsule!\u0026#34;); return nullptr; } std::cout \u0026lt;\u0026lt; \u0026#34;Received C++ object with value: \u0026#34; \u0026lt;\u0026lt; obj-\u0026gt;value \u0026lt;\u0026lt; std::endl; return PyLong_FromLong(obj-\u0026gt;value); } // Python 方法表 static PyMethodDef CppMethods[] = { {\u0026#34;use_object\u0026#34;, use_object, METH_VARARGS, \u0026#34;Use a C++ object from PyCapsule\u0026#34;}, {nullptr, nullptr, 0, nullptr} }; // Python 模块定义 static struct PyModuleDef cppModule = { PyModuleDef_HEAD_INIT, \u0026#34;cppModule\u0026#34;, nullptr, -1, CppMethods }; // 初始化 Python 模块 PyMODINIT_FUNC PyInit_cppModule(void) { return PyModule_Create(\u0026amp;cppModule); } int main() { // 初始化 Python 解释器 Py_Initialize(); PyObject* pModule = PyImport_AddModule(\u0026#34;__main__\u0026#34;); PyObject* pGlobals = PyModule_GetDict(pModule); // 注册 C++ 方法到 Python PyObject* pCppModule = PyModule_Create(\u0026amp;cppModule); PyDict_SetItemString(pGlobals, \u0026#34;cppModule\u0026#34;, pCppModule); // 执行 Python 代码 const auto python_code = R\u0026#34;( def my_function(capsule): result = cppModule.use_object(capsule) # 传回 C++ 处理 print(f\u0026#34;Python received: {result}\u0026#34;) return result )\u0026#34;; PyRun_SimpleString(python_code); // 获取 Python 函数对象 if (PyObject* pFunc = PyDict_GetItemString(pGlobals, \u0026#34;my_function\u0026#34;); PyCallable_Check(pFunc)) { auto* obj = new MyStruct{42}; // 创建 C++ 对象 const auto capsule = PyCapsule_New(obj, \u0026#34;this\u0026#34;, nullptr); // 返回封装的指针 // 准备参数 PyObject* pArgs = PyTuple_Pack(1, capsule); // 调用函数 if (PyObject* pValue = PyObject_CallObject(pFunc, pArgs); pValue != nullptr) { // 打印函数返回值 std::cout \u0026lt;\u0026lt; \u0026#34;Function returned: \u0026#34; \u0026lt;\u0026lt; PyLong_AsLong(pValue) \u0026lt;\u0026lt; std::endl; Py_XDECREF(pValue); } else { PyErr_Print(); } Py_XDECREF(pArgs); } else { PyErr_Print(); } // 关闭 Python 解释器 Py_Finalize(); return 0; } "},{"id":11,"href":"/blog/git/WNYzxj6GR/","title":"📝 git之删除远程分支","section":"📔 Git","content":" git删除远程分支就这么简单\ngit push origin --delete [branch_name] "},{"id":12,"href":"/blog/git/-fZeBsu3T/","title":"📝 git更新.gitignore","section":"📔 Git","content":" 一般直接修改.gitignore是不生效的，需要先清理缓存，再修改.gitignore。\ngit rm -r --cached . git add . git commit -m \u0026#39;update .gitignore\u0026#39; "},{"id":13,"href":"/blog/git/H1Krv6b-4/","title":"📝 git修改历史cimmit信息","section":"📔 Git","content":" git 使用rebase修改历史提交的cimmit信息\n1、修改指定commit # git rebase -i 36224db 或:\ngit rebase -i HEAD~3 2、把pick改为edit # pick：保留该commit（缩写:p）\nreword：保留该commit，但我需要修改该commit的注释（缩写:r）\nedit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）\nsquash：将该commit和前一个commit合并（缩写:s）\nfixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）\nexec：执行shell命令（缩写:x）\ndrop：我要丢弃该commit（缩写:d）\n3、修改commit信息 # git commit --amend git rebase --continue 4、推送到远程仓库 # git push -f origin master "},{"id":14,"href":"/blog/git/By9OI51xN/","title":"📝 git基础笔记","section":"📔 Git","content":" git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。\n克隆项目 # git clone https://github.com/golang/go.git 查看远程仓库 # git remote -v 添加远程仓库 # 要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 git remote add [shortname] [url]：\ngit remote add pb https://github.com/golang/go.git 现在可以用字符串 pb 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 git fetch pb\n从远程仓库抓取数据 # git fetch [remote-name] 推送数据到远程仓库 # git push [remote-name] [branch-name]\ngit push origin master 查看远程仓库信息 # git remote show [remote-name]\ngit remote show origin 重命名远程仓库 # git remote rename old_remote-name new_remote-name\ngit remote rename pb test 删除远程仓库 # git remote rm remote-name\ngit remote rm test "},{"id":15,"href":"/blog/git/Hk6GGp6cQ/","title":"📝 Git回滚到某个commit","section":"📔 Git","content":" git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。\n回滚命令 # git reset --hard HEAD^ #回滚到上个版本 git reset --hard HEAD~3 #回滚到前3次提交之前，以此类推，回退到n次提交之前 git reset --hard commit_id #回滚到指定commit的sha版本 推送命令 # git push origin HEAD --force #强制推送到远程 温馨提示 # 回滚有风险，请提前做好备份。\n"},{"id":16,"href":"/links/","title":"🤝 友情链接","section":"Docs","content":" "},{"id":17,"href":"/articles/2024/12/23/wvkjyjt7qhumo4jpucheca/","title":"Linux硬盘故障相关的查询命令","section":"📚 我的文章","content":" 查看硬盘及对应的UUID信息 # # 查看硬盘及对应的UUID信息 或者是所有硬盘的UUID信息 blkid [/dev/sda1] # lsblk -o NAME,UUID -p 查看UUID对应的硬盘路径 # blkid -U 383bc776-fc1a-4040-ad8f-45f4f5d96fcf 查看硬盘信息 # lshw -class disk 检测磁盘是否损坏 # badblocks -b 4096 -v /dev/sda # 也有坏快的屏蔽方式这个里就不列举了 点亮硬盘LED # dd if=/dev/sda of=/dev/null bs=1M count=100 # 点亮硬盘LED 查看服务器序列号 # dmidecode -t 1 # 查看对应的\u0026#39;Serial Number\u0026#39;字段 "},{"id":18,"href":"/articles/2024/11/15/mcagbs9lfdrnxxu9k29t9j/","title":"使用FFmpeg生成测试视频","section":"📚 我的文章","content":" 生成23.976fps的测试视频 # ffmpeg -f lavfi -i testsrc=size=1280x720:rate=30 -vf \u0026#34;drawtext=text=\u0026#39;%{pts\\:hms} %{n}\u0026#39;:x=(w-text_w)/2:y=100:fontsize=48:fontcolor=white:boxcolor=black@0.5:borderw=2\u0026#34; -r 23.976 -t 10 -y output.mp4 "},{"id":19,"href":"/articles/2024/03/27/e4c2nybngzu5eddbnmdjgq/","title":"Mamba替代Conda","section":"📚 我的文章","content":"mamba是一个conda的替代品，可以加速conda的包管理，提升包管理的效率。\n安装 # brew install micromamba 配置 # # 根据命令提示，修改~/.zshrc文件 micromamba shell init -s zsh -p ~/.micromamba # 添加配置文件 $ cat ~/.mambarc channels: - conda-forge always_yes: false 使用 # micromamba create -n python310 python=3.10 # 激活环境 micromamba activate python310 # 然后可以用 micromamba 或者 pip 装东西 micromamba install package_1 package_2=version ## 具体请参考 https://mamba.readthedocs.io/en/latest/ micromamba --help "},{"id":20,"href":"/articles/2024/03/06/9mzhfnl58azjmeibfblvjy/","title":"Hugo网站建设","section":"📚 我的文章","content":" 安装 Hugo # 下载地址：https://github.com/gohugoio/hugo/releases\n创建网站 # hugo new site book cd book git init git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book 本地调试 # hugo server --disableFastRender --minify --ignoreCache github actions # mkdir -p .github/workflows touch .github/workflows/build.yml name: Build on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.123.7\u0026#39; # 是否启用 hugo extend extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GH_PAGE_ACTION_TOKEN }} publish_dir: ./public github pages # 可以在项目的 Settings 中开启 Pages 服务，然后选择 Branch 为gh-pages即可。\n如果想要定制域名，可以参考官方文档 About custom domains and GitHub Pages\n"},{"id":21,"href":"/articles/2024/02/06/kkcc5t2y88hybafpourudv/","title":"FFmpeg检测透明通道","section":"📚 我的文章","content":" 检测透明通道 # FFmpeg命令 # $ ffmpeg -v error -i 123.mp4 -vf \u0026#34;select=\u0026#39;eq(n,0)\u0026#39;, alphaextract\u0026#34; -f null /dev/null [Parsed_alphaextract_1 @ 0x7fe8f5208100] Requested planes not available. [Parsed_alphaextract_1 @ 0x7fe8f5208100] Failed to configure input pad on Parsed_alphaextract_1 [vf#0:0 @ 0x7fe8f5005f40] Error reinitializing filters! Failed to inject frame into filter network: Invalid argument Error while filtering: Invalid argument [out#0/null @ 0x7fe8f5004900] Nothing was written into output file, because at least one of its streams received no packets. 判断条件 # 如果出现以上报错信息，则说明视频中没有透明通道。\n"},{"id":22,"href":"/blog/linux/fSHb366Mg/","title":"ssh客户端于服务端保持连接","section":"📚 我的文章","content":" linux ssh 默认没有开启心跳，所以很容易导致连接断开。\n服务端设置 # sudo vim /etc/ssh/sshd_config TCPKeepAlive yes ClientAliveInterval 60 ClientAliveCountMax 3 客户端设置 # 一般还是建议在客户端设置。\nsudo vim /etc/ssh/ssh_config TCPKeepAlive yes ServerAliveInterval 60 ServerAliveCountMax 3 "},{"id":23,"href":"/blog/linux/G0DCCusMR/","title":"Centos7系统升级内核版本","section":"📚 我的文章","content":" 使用ELRepo仓库升级系统内核\n查看内核版本 # uname -r uname -a cat /etc/redhat-release 安装ELRepo yum源 # rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 查看可用的内核版本 # yum --disablerepo=\u0026#34;*\u0026#34; --enablerepo=\u0026#34;elrepo-kernel\u0026#34; list available ... kernel-lt.x86_64 4.4.155-1.el7.elrepo kernel-lt-devel.x86_64 4.4.155-1.el7.elrepo ... 安装稳定版本内核 # yum --enablerepo=elrepo-kernel install kernel-lt 设置引导（grub2） # 查看所有内核版本 # sudo awk -F\\\u0026#39; \u0026#39;$1==\u0026#34;menuentry \u0026#34; {print i++ \u0026#34; : \u0026#34; $2}\u0026#39; /etc/grub2.cfg 0 : CentOS Linux (4.4.241-1.el7.elrepo.x86_64) 7 (Core) 1 : CentOS Linux (3.10.0-957.el7.x86_64) 7 (Core) 2 : CentOS Linux (0-rescue-651e1b90bb3149809cdeb8cc80e72c43) 7 (Core) 设置新的默认引导的内核版本 # 方法1\ngrub2-set-default 0 #其中 0 是上面查询出来的可用内核 方法2\nvim /etc/default/grub GRUB_DEFAULT=0 #其中 0 是上面查询出来的可用内核 grub2-mkconfig -o /boot/grub2/grub.cfg #生成 grub 配置文件 reboot # 重启机器 验证及删除旧内核（可选） # uname -r # 查看内核版本 4.4.241-1.el7.elrepo.x86_64 yum install yum-utils package-cleanup --oldkernels # 删除旧的内核版本 # 也可以使用 rpm -qa | grep kernel 先把所有的内核版本查询出来，然后使用 yum remove 删除掉旧的内核版本 升级失败的处理方法 # 如果发现升级内核版本并重启，发现机器无法启动，需要在开机进入引导内核选择界面手动选择老的内核启动，然后再讲默认引导的内核版本改回来的内核版本进行回滚。\n"},{"id":24,"href":"/blog/linux/xd2UELYGR/","title":"dnsmasq安装与配置","section":"📚 我的文章","content":" dnsmasq是一个小巧且方便地用于配置DNS和DHCP的工具，适用于小型网络，它提供了DNS功能和可选择的DHCP功能。\n安装服务 # sudo yum install dnsmasq 常用配置 # cat /etc/dnsmasq.conf #######这里表示 严格按照 resolv-file 文件中的顺序从上到下进行 DNS 解析, 直到第一个成功解析成功为止 #strict-order ###同时发送所有的查询到所有的dns服务器，谁快就用谁 all-servers listen-address=127.0.0.1 ###不让dnsmasq去读/etc/hosts文件 no-hosts ## 设置缓存条目 cache-size=10240 #允许客户端缓存的时间单位为秒 local-ttl=10 max-cache-ttl=15 ###开启日志 #log-queries ##配置日志文件 #log-facility=/data/logs/dnsmasq.log cat /etc/resolv.dnsmasq.conf nameserver 223.5.5.5 nameserver 114.114.114.114 nameserver 222.246.129.80 启动服务 # systemctl start dnsmasq 验证方法 # dig www.zhangwenbing.com 其他配置 # 国内指定DNS # server=/cn/114.114.114.114 server=/taobao.com/114.114.114.114 server=/taobaocdn.com/114.114.114.114 国外指定DNS # server=/google.com/8.8.8.8 屏蔽网页广告 # address=/ad.youku.com/127.0.0.1 address=/ad.iqiyi.com/127.0.0.1 其他功能 # 除了DNS，还支持DHCP和TFTP，由于暂时用不到，这里就不一一例举了。\n"},{"id":25,"href":"/blog/linux/SNyWJwbGR/","title":"使用ssh配置跳板机","section":"📚 我的文章","content":" 简单的修改/etc/ssh/ssh_config文件即可通过跳板机，直达目标服务器。\n配置方法 # cat /etc/ssh/ssh_config Host jump-server User xxxx Hostname yyy.yyy.yyy.yyy Port 22 Host 10.* ProxyCommand ssh -q -W %h:%p jump-server Host 支持通配符 * 和 ?\nxxxx 跳板机用户名\nyyy.yyy.yyy.yyy 跳板机IP地址\n需要注意的问题 # 跳板机最好是免秘钥登录，不然的话会需要输入密码。\n"},{"id":26,"href":"/blog/linux/tqj7MybMg/","title":"centos6镜像站停止维护的解决办法","section":"📚 我的文章","content":" 2020年11月30日 centos6各大开源镜像站已经停止维护了，但是阿里云还有其他源可以使用。\n错误提示 # http://mirrors.aliyun.com/epel/6/x86_64/repodata/repomd.xml: [Errno 14] PYCURL ERROR 22 - \u0026#34;The requested URL returned error: 404 Not Found\u0026#34; 解决办法 # cat /etc/yum.repos.d/CentOS-Base.repo # CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead. # # [base] name=CentOS-6.10 - Base - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos-vault/6.10/os/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6 #released updates [updates] name=CentOS-6.10 - Updates - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos-vault/6.10/updates/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6 #additional packages that may be useful [extras] name=CentOS-6.10 - Extras - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos-vault/6.10/extras/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6 #additional packages that extend functionality of existing packages [centosplus] name=CentOS-6.10 - Plus - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos-vault/6.10/centosplus/$basearch/ gpgcheck=1 enabled=0 gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6 #contrib - packages by Centos Users [contrib] name=CentOS-6.10 - Contrib - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos-vault/6.10/contrib/$basearch/ gpgcheck=1 enabled=0 gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6 yum clean all yum makecache "},{"id":27,"href":"/blog/ffmpeg/ROS_KIbGg/","title":"ffmpeg规范音频的响度","section":"📚 我的文章","content":" 通过FFmpeg内置滤镜、手动调整音量、或者ffmpeg-normalize实现对响度的控制。\n内置归一化滤波器 # loudnorm：通过EBU R.128进行响度标准化。您可以设置积分的体积目标，体积范围目标或最大真实峰。建议用于发布音频和视频，并被世界各地的广播公司使用。\ndynaudnorm：“智能”响度归一化，不进行裁剪。动态地将规范化应用于文件的窗口部分。应谨慎使用，因为这可能会改变声音的特性。\n#fdk_aac编码器 ffmpeg200421 -i \u0026#34;source_audio.ts\u0026#34; -c:a libfdk_aac -strict -2 -ac 2 -ar 48000 -ab 196k -af \u0026#34;[0:a]pan=stereo| FL \u0026lt; FL + 0.5*FC + 0.6*BL + 0.6*SL | FR \u0026lt; FR + 0.5*FC + 0.6*BR + 0.6*SR,loudnorm=I=-23:LRA=6:tp=-1\u0026#34; -y -cutoff 20000 \u0026#34;ac_5m.ts\u0026#34; #aac编码器 ffmpeg -i \u0026#34;source_audio.ts\u0026#34; -c:a aac -strict -2 -ac 2 -ar 48000 -ab 196k -af \u0026#34;loudnorm=I=-23:LRA=6:tp=-1\u0026#34; -y -cutoff 20000 \u0026#34;1_aac_dynaudnorm_ac_5m.ts\u0026#34; 常用方式 # ffmpeg -i input.mp4 -vn -acodec libfdk_aac -ac 2 -ar 44100 -af loudnorm=I=-16:TP=-1:LRA=7:print_format=json -f null /dev/null 手动规范音频的响度 # 首先，您需要分析音频流以获取最大音量，以查看规范化是否起作用。\nffmpeg -i video.avi -af \u0026#34;volumedetect\u0026#34; -vn -sn -dn -f null /dev/null [Parsed_volumedetect_0 @ 0x7f8ba1c121a0] mean_volume: -16.0 dB [Parsed_volumedetect_0 @ 0x7f8ba1c121a0] max_volume: -5.0 dB [Parsed_volumedetect_0 @ 0x7f8ba1c121a0] histogram_0db: 87861 使用音量过滤器（volume）\nffmpeg -i video.mp4 -af \u0026#34;volume=5dB\u0026#34; -c:v copy -c:a aac -cutoff 20000 output.mp4 volume=5dB 表示增加5分贝的音量\nvolume=-5dB 表示减少5分贝的音量\nvolume=1.5 表示放大1.5倍的音量\nffmpeg-normalize # ffmpeg-normalize 是一个Python库，可以使用pip安装，详细的使用方式在github上有文档，这里就不做过多的介绍了。\n"},{"id":28,"href":"/blog/linux/-vpymjJGg/","title":"tcpdump之UDP抓包","section":"📚 我的文章","content":" 使用tcpdump抓UDP包，过滤过滤IP和port，并且自动拆分片段。\n安装tcpdump # yum install -y tcpdump 使用方法 # tcpdump -i bond0 udp port xxxx and host xxx.x.xx.xxx -s0 -G 600 -w %Y_%m%d_%H%M_%S.pcap 参数说明 # -i 指定监听的网卡\nudp 监听UDP协议\nport 指定过滤的端口\nhost 指定过滤的ip\n-s 表示从一个包中截取的字节数，0表示包不截断\n-G 按照固定的时间间隔切割输出的文件（单位：秒）\n-w 直接将包写入文件中，并不分析和打印出来；\n取非运算是 ‘not ’ ‘! ‘，与运算是’and’，’\u0026amp;\u0026amp;;或运算 是’or’ ,‘||’\n定时抓包(python) # #!/usr/bin/env python # -*- coding: UTF-8 -*- # # @author 张文兵 # @blog https://zhangwenbing.com/ # @datetime 2020-12-18 14:56:01 # @description # import os import time from apscheduler.schedulers.blocking import BlockingScheduler def system(cmd): t = time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;, time.localtime(time.time())) print(\u0026#39;{} 执行 {}\u0026#39;.format(t, cmd)) stat = os.system(cmd) if stat != 0: print(\u0026#39;{} 执行 {} 失败\u0026#39;.format(t, cmd)) scheduler = BlockingScheduler() # 星期1-5的17点40分执行抓包任务 scheduler.add_job(system, \u0026#39;cron\u0026#39;, day_of_week=\u0026#34;mon,tue,wed,thu,fri,sat\u0026#34;, hour=17, minute=30, args=[\u0026#39;/sbin/tcpdump -i bond0 udp port xxxx and host xxx.x.xx.xxx -s0 -G 3600 -w /your_path/%Y_%m%d_%H%M_%S.pcap \u0026amp;\u0026gt;/dev/null\u0026#39;]) # 星期1-5的20点01分执行kill scheduler.add_job(system, \u0026#39;cron\u0026#39;, day_of_week=\u0026#34;mon,tue,wed,thu,fri,sat\u0026#34;, hour=20, minute=1, args=[\u0026#39;pkill -9 tcpdump \u0026amp;\u0026gt;/dev/null\u0026#39;]) scheduler.start() # 星期1-5的23点59分执行自动清理7天之前的抓包文件 scheduler.add_job(system, \u0026#39;cron\u0026#39;, day_of_week=\u0026#34;mon,tue,wed,thu,fri,sat\u0026#34;, hour=23, minute=59, args=[\u0026#39;/usr/bin/find /your_path/ -type f -ctime +7 -exec rm -f {} \\; \u0026amp;\u0026gt;/dev/null\u0026#39;]) scheduler.start() 切分抓包文件 # tcpdump -r old_file -w new_files -C 10 -r 指定需要切分的文件\n-w 指定新的文件名前缀\n-C 指定切分的文件大小（单位：M）\n"},{"id":29,"href":"/blog/linux/h5sGcU1MR/","title":"Linux收录UDP视频花屏总结","section":"📚 我的文章","content":" 最近在Linux下使用ffmpeg收录UDP流花屏问题，发现机器有双网卡，添加路由指定网卡收录导致无法收录了。另附一些解决花屏的优化方法。\n优化内核参数 # cat /etc/sysctl.conf net.ipv4.conf.default.rp_filter = 0 net.ipv4.conf.all.rp_filter = 0 # 修改默认网络的缓存大小 这个很重要不然 net.core.rmem_max = 50000000 net.core.rmem_default = 50000000 sysctl -p # 添加以上配置后需要重启系统 reboot # 不重启的话一定要执行以下命令 for i in /proc/sys/net/ipv4/conf/*/rp_filter ; do echo 0 \u0026gt; \u0026#34;$i\u0026#34;; done 吐槽 # 由于博主只修改了上面的 sysctl.conf 并且只执行了 sysctl -p 所以悲剧了，添加路由之后一直无法收录。\n20201218更新 # 刚开始以为是存储和收录走同一网口导致花屏，没想到经过一番抓包分析之后，最后确定是交换机有瓶颈（交换机老旧），是交换机的数据处理不过来导致的丢包。\ncifs(samba) # 如果收录文件是存储到cifs的话，一定要在挂载的时候指定 cache=none 禁用缓存，不然收录长视频时会导致收录中断。\n"},{"id":30,"href":"/blog/linux/loBZJ41MR/","title":"CentOS添加静态路由之route","section":"📚 我的文章","content":" route命令参数详细说明及常用命令\n原文地址 docs.lvrui.io\n\u0026gt; route Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface default localhost 0.0.0.0 UG 100 0 0 eno16780032 172.17.0.0 0.0.0.0 255.255.0.0 U 0 0 0 docker0 192.168.10.0 0.0.0.0 255.255.255.0 U 100 0 0 eno16780032 macOS 中使用 netstat -nr 命令来查看当前路由表\nDestination 目标网路\nGateway 网关\nGenmask 掩码\nFlags 标识\nU 路由已经启动\nH 路由目标为主机\nG 使用网关\nR 为动态路由复原路由表\nD 由守护进程或间接动态安装\nM 被路由守护进程或间接修改\nA 通过 addrconf 修改\nC 缓存条目\n! 拒绝路由\nMetric 路由开销, 到目标的‘距离’（通常基于跳数统计）\nRef 参考此路由的数量\nUse 路由查找计数。依赖与使用 - F 还是 - C 选项，这个值要么是路由缓存未命中数要么是命中数\nIface 此路由数据包发送到的网络接口\n添加到主机的路由 # route add –host 192.168.59.2 dev eth1 route add –host 192.168.59.2 gw 192.168.10.85 添加到网络的路由 # route add -net 192.168.248.0/24 gw 192.168.10.85 route add –net 192.168.248.0 netmask 255.255.255.0 gw 192.168.10.85 route add –net 192.168.248.0 netmask 255.255.255.0 dev eth1 添加默认网关 # route add default gw 192.168.10.85 route add -net 0.0.0.0 gw 192.168.10.85 使用 route 命令添加的路由，机器重启或者网卡重启后路由就失效了\nroute del –host 192.168.10.85 dev eth1 怎么 add 的就怎么 del 掉. 但是 del 的时候可以不写网关\n在 /etc/rc.local 里添加路由信息\nroute add -net 192.168.247.0/24 dev eth1 route add -net 192.168.110.0/24 gw 192.168.10.85 在 /etc/sysconfig/network 里添加到末尾 GATEWAY=gw-ip 或者 GATEWAY=gw-dev\n在 /etc/sysconfig/static-router 添加 any net x.x.x.x/24 gw y.y.y.y\n添加永久路由 # CentOS7 下推荐使用上面第三种方法添加永久静态路由\n[root@centos7 ~] 10.15.150.0/24 via 192.168.150.253 dev enp0s3 10.25.250.0/24 via 192.168.150.253 dev enp0s3 将永久静态路由需要写到 /etc/sysconfig/network-scripts/route-interface 文件中\n注意:\nifcfg-enp0s3 文件改名为 ifcfg-eth0 后，route-enp0s3 文件也要改名为 route-eth0\n参考文档:\nhttps://www.cnblogs.com/panblack/p/Centos7_Static_Routes.html "},{"id":31,"href":"/blog/macos/aaELFz1Mg/","title":"macos Lauchpad(启动台) 重置","section":"📚 我的文章","content":" 重置macos的Lauchpad(启动台)，及设置Lauchpad(启动台)的行数和列数。\n打开终端程序，按需求执行以下命令即可。\n重置 Lauchpad # defaults write com.apple.dock ResetLaunchPad -bool TRUE; 重启 Dock # killall Dock 设置 Lauchpad 图标的列数 # defaults write com.apple.dock springboard-columns -int 7 设置 Lauchpad 图标的行数 # defaults write com.apple.dock springboard-rows -int 7 "},{"id":32,"href":"/blog/linux/bdpp4QAMg/","title":"nginx及php-fpm优化","section":"📚 我的文章","content":" 简单的讲讲nginx+php的一些常用优化，以及相关的内核参数优化。\nNginx 优化 # 1. TCP 与 UNIX 套接字 # UNIX 域套接字提供的性能略高于 TCP 套接字在回送接口上的性能（较少的数据复制，较少的上下文切换）。如果每个服务器需要支持超过 1000 个连接，请使用 TCP 套接字 - 它们可以更好地扩展。\nupstream backend { server unix:/var/run/fastcgi.sock; } 2. 调整 worker_processes 参数 # 现代硬件是多处理器，NGINX 可以利用多个物理或虚拟处理器。在大多数情况下，您的 Web 服务器计算机不会配置为处理多个工作负载（例如同时提供 Web 服务器和打印服务器的服务），因此您需要配置 NGINX 以使用所有可用的处理器，因为 NGINX 工作进程是不是多线程的。\n将 nginx.conf 文件中的 worker_processes 设置为计算机所具有的核心数。\n当你在它的时候，增加 worker_connections 的数量（每个核心应该处理多少个连接）并将 multi_accept 设置为 ON，如果你在 Linux 上则设置为 epoll：\nworker_processes 4; events { worker_connections 1024; multi_accept on; } 3. 禁用访问日志 # access_log off; log_not_found off; error_log /var/log/nginx-error.log warn; 如果有需要不可以关闭，至少是缓存他们\naccess_log /var/log/nginx/access.log main buffer=16k; 4. 开启 gzip 压缩 # gzip on; gzip_disable \u0026#34;msie6\u0026#34;; gzip_vary on; gzip_proxied any; gzip_comp_level 6; gzip_min_length 1100; gzip_buffers 16 8k; gzip_http_version 1.1; gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; 5. 缓存访问频次较高的文件 # open_file_cache max=2000 inactive=20s; open_file_cache_valid 60s; open_file_cache_min_uses 5; open_file_cache_errors off; 6. 调整客户端超时 # client_max_body_size 50M; client_body_buffer_size 1m; client_body_timeout 15; client_header_timeout 15; keepalive_timeout 2 2; send_timeout 15; sendfile on; tcp_nopush on; tcp_nodelay on; 7. 调整输出缓存 # fastcgi_buffers 256 16k; fastcgi_buffer_size 128k; fastcgi_connect_timeout 3s; fastcgi_send_timeout 120s; fastcgi_read_timeout 120s; fastcgi_busy_buffers_size 256k; fastcgi_temp_file_write_size 256k; reset_timedout_connection on; server_names_hash_bucket_size 100; 8. 负载均衡策略 # Nginx 提供轮询（round robin）、用户 IP 哈希（client IP）和指定权重 3 种方式。\n默认情况下，Nginx 会为你提供轮询作为负载均衡策略。但是这并不一定能够让你满意。比如，某一时段内的一连串访问都是由同一个用户 Michael 发起的，那么第一次 Michael 的请求可能是 backend2，而下一次是 backend3，然后是 backend1、backend2、backend3…… 在大多数应用场景中，这样并不高效。当然，也正因如此，Nginx 为你提供了一个按照 Michael、Jason、David 等等这些乱七八糟的用户的 IP 来 hash 的方式，这样每个 client 的访问请求都会被甩给同一个后端服务器。\nupstream backend { ip_hash; server unix:/var/run/php7.2-fpm.sock1 weight=100 max_fails=5 fail_timeout=5; server unix:/var/run/php7.2-fpm.sock2 weight=100 max_fails=5 fail_timeout=5; } 9. 持续监控日志 # 尤其是在调优最初期，在一个窗口\ntail -f /var/log/nginx/error.log 在另外两个窗口分别：\ntail -f /var/log/php-fpm/error.log tail -f /var/log/php-fpm/www-error.log PHP-fpm 优化 # 1. 修改进程管理模式 # static 管理模式适合比较大内存的服务器，而 dynamic 则适合小内存的服务器，你可以设置一个 pm.min_spare_servers 和 pm.max_spare_servers 合理范围，这样进程数会不断变动。ondemand 模式则更加适合微小内存，例如 512MB 或者 256MB 内存，以及对可用性要求不高的环境。\npm = dynamic #指定进程管理方式，有3种可供选择：static、dynamic和ondemand。 pm.max_children = 16 #static模式下创建的子进程数或dynamic模式下同一时刻允许最大的php-fpm子进程数量。 pm.start_servers = 10 #动态方式下的起始php-fpm进程数量。 pm.min_spare_servers = 8 #动态方式下服务器空闲时最小php-fpm进程数量。 pm.max_spare_servers = 16 #动态方式下服务器空闲时最大php-fpm进程数量。 pm.max_requests = 2000 #php-fpm子进程能处理的最大请求数。 pm.process_idle_timeout = 10s request_terminate_timeout = 120 pm = static，始终保持一个固定数量的子进程，这个数由 pm.max_children 定义，这种方式很不灵活，也通常不是默认的。\npm = dynamic，启动时会产生固定数量的子进程（由 pm.start_servers 控制）可以理解成最小子进程数，而最大子进程数则由 pm.max_children 去控制，子进程数会在最大和最小数范围中变化。闲置的子进程数还可以由另 2 个配置控制，分别是 pm.min_spare_servers 和 pm.max_spare_servers。如果闲置的子进程超出了 pm.max_spare_servers，则会被杀掉。小于 pm.min_spare_servers 则会启动进程（注意，pm.max_spare_servers 应小于 pm.max_children）。\npm = ondemand，这种模式和 pm = dynamic 相反，把内存放在第一位，每个闲置进程在持续闲置了 pm.process_idle_timeout 秒后就会被杀掉，如果服务器长时间没有请求，就只会有一个 php-fpm 主进程。弊端是遇到高峰期或者如果 pm.process_idle_timeout 的值太短的话，容易出现 504 Gateway Time-out 错误，因此 pm = dynamic 和 pm = ondemand 谁更适合视实际情况而定。\n2. 释放内存的配置 # pm.max_requests = 1000 设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ‘0’ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.\n也就是当一个 PHP-CGI 进程处理的请求数累积到 1000 个后，自动重启该进程，防止第三方库造成的内存泄漏。 重启时可能会导致 502 错误，在高并发站点时有出现。\n3. php-fpm 慢日志 # request_terminate_timeout = 30s #将执行时间太长的进程直接终止 request_slowlog_timeout = 2s #2秒 slowlog = log/$pool.log.slow #日志文件 内核优化 # 1. TIME_WAIT产生原因： # 1、nginx现有的负载均衡模块实现php fastcgi负载均衡，nginx使用了短连接方式，所以会造成大量处于TIME_WAIT状态的连接。\n2、TCP/IP设计者本来是这么设计的\n主要有两个原因\n(1) 防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）\n(2) 可靠的关闭TCP连接\n在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。\n2. 过多TIME_WAIT危害 # TIME_WAIT 并不会占用很大资源的，除非受到攻击。只要把TIME_WAIT所占用内存控制在一定范围。一般默认最大是35600条TIME_WAIT。\n3. 解决方法 # net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭。\nnet.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭。\nnet.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。\nnet.ipv4.tcp_fin_timeout = 30 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。\nnet.ipv4.tcp_keepalive_time = 1200 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。\nnet.ipv4.ip_local_port_range = 1024 65000 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。\nnet.ipv4.tcp_max_syn_backlog = 8192 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。\nnet.ipv4.tcp_max_tw_buckets = 5000 表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默 认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。\n注:\nnet.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_tw_recycle = 1 设置这两个参数： reuse是表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接； recyse是加速TIME-WAIT sockets回收\n"},{"id":33,"href":"/blog/ffmpeg/Mv3bzfgqM/","title":"ffmpeg在特定的时间混合一个或多个音频","section":"📚 我的文章","content":" 使用FFmpeg中的adelay和amix滤镜给音频做混音\n在30秒后混合1个音频\nffmpeg -i 1-1.mp3 -i 2.mp3 -filter_complex \u0026#34;[1]adelay=delays=30s:all=1[aud1];[0][aud1]amix=inputs=2\u0026#34; -vsync 2 -y 3.mp3 在30秒后混合2个音频\nffmpeg -i 1-1.mp3 -i 2.mp3 -i 3.mp3 -filter_complex \u0026#34;[1]adelay=delays=30s:all=1[aud1];[2]adelay=delays=30s:all=1[aud2];[0][aud1][aud2]amix=inputs=3\u0026#34; -vsync 2 -y 4.mp3 混合多个参照混合2个的命令修改下即可\n"},{"id":34,"href":"/blog/linux/HTLMANZea/","title":"[supervisord]填坑之最大连接数","section":"📚 我的文章","content":" 修改supervisord配置突破1024最大连接数\n问题描述 # 最近在使用supervisord服务时发现，无论如何修改系统的最大连接数，由supervisord管理的程序都无法突破1024的限制。\n解决办法 # cat /etc/supervisord.conf [supervisord] minfds=81920 minprocs=81920 cat /etc/supervisord.d/xxx.ini [program:xxx] minfds=81920 minprocs=81920 systemctl restart supervisord.service "},{"id":35,"href":"/blog/ffmpeg/UtHueryud/","title":"FFmpeg 水印","section":"📚 我的文章","content":" 图片水印、文字水印、画中画\n图片水印 # ffmpeg -i input.mp4 -vf \u0026#34;movie=wenzi.png[watermark];[in][watermark] overlay=main_w-overlay_w-10:main_h-overlay_h-10[out] \u0026#34; output.mp4 -i :一般表示输入\ninput.mp4:这里表示要处理的视频源\n-vf:滤镜相关，视频裁剪，水印等等操作都需要它完成\nwenzi.png: 要添加的水印图片地址\noverlay:水印参数\nmain_w-overlay_w-10 : 水印在x轴的位置，也可以写成x=main_w-overlay_w-10\nmain_h-overlay_h-10：水印在y轴的位置\nffmpeg -i input.mp4 -i logo.png -filter_complex \u0026#39;overlay=x=10:y=main_h-overlay_h-10\u0026#39; output.mp4 -filter_complex: 相比-vf,\nfilter_complex适合开发复杂的滤镜功能，如同时对视频进行裁剪并旋转。参数之间使用逗号（，）隔开即可\nmain_w:视频宽度\noverlay_w: 要添加的图片水印宽度\nmain_h : 视频高度\noverlay_h:要添加的图片水印宽度\n文字水印 # ffmpeg -i input.mp4 -vf \u0026#34;drawtext=fontfile=simhei.ttf: text=‘技术是第一生产力’:x=10:y=10:fontsize=24:fontcolor=white:shadowy=2\u0026#34; output.mp4 fontfile:字体类型\ntext:要添加的文字内容\nfontsize:字体大小\nfontcolor：字体颜色\n画中画 # 只显示1遍，后边重复显示最后一帧。\nffmpeg -i bunny.mp4 -vf \u0026#34;movie=test.mov[logo];[0:v][logo]overlay=x=100:y=100\u0026#34; -y out.mp4 mov一直循环显示。 添加 loop=0,setpts=N/FRAME_RATE/TB 即可。\nffmpeg -i bunny.mp4 -vf \u0026#34;movie=test.mov:loop=0,setpts=N/FRAME_RATE/TB[logo];[0:v][logo]overlay=x=100:y=100\u0026#34; -y out.mp4 只显示一遍 添加eof_action即可。\nffmpeg -i bunny.mp4 -vf \u0026#34;movie=test.mov[logo];[0:v][logo]overlay=x=100:y=100:eof_action=pass\u0026#34; -vframes 1000 -y out.mp4 "},{"id":36,"href":"/blog/linux/QNIBzjz3k/","title":"supervisor 常见坑及解决办法","section":"📚 我的文章","content":" Too many open files、获取不到$HOME等\nToo many open files # vim /etc/supervisord.conf [supervisord] minfds=81920 minprocs=81920 # systemctl restart supervisord 获取不到$HOME # [program:apache2] command=/home/chrism/bin/httpd -c \u0026#34;ErrorLog /dev/stdout\u0026#34; -DFOREGROUND user=chrism environment=HOME=\u0026#34;/home/chrism\u0026#34;,USER=\u0026#34;chrism\u0026#34; supervisorctl update "},{"id":37,"href":"/blog/linux/N2EsU3hZT/","title":"linux nvidia 获取显卡信息","section":"📚 我的文章","content":" 使用deviceQuery获取显卡信息\n环境 # Linux、nvidia、cuda\n命令 # /usr/local/cuda/extras/demo_suite/deviceQuery CUDA Device Query (Runtime API) version (CUDART static linking) Detected 2 CUDA Capable device(s) Device 0: \u0026#34;GeForce RTX 2080 Ti\u0026#34; CUDA Driver Version / Runtime Version 10.1 / 10.1 CUDA Capability Major/Minor version number: 7.5 Total amount of global memory: 11019 MBytes (11554717696 bytes) (68) Multiprocessors, ( 64) CUDA Cores/MP: 4352 CUDA Cores GPU Max Clock rate: 1545 MHz (1.54 GHz) Memory Clock rate: 7000 Mhz Memory Bus Width: 352-bit L2 Cache Size: 5767168 bytes Maximum Texture Dimension Size (x,y,z) 1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384) Maximum Layered 1D Texture Size, (num) layers 1D=(32768), 2048 layers Maximum Layered 2D Texture Size, (num) layers 2D=(32768, 32768), 2048 layers Total amount of constant memory: 65536 bytes Total amount of shared memory per block: 49152 bytes Total number of registers available per block: 65536 Warp size: 32 Maximum number of threads per multiprocessor: 1024 Maximum number of threads per block: 1024 Max dimension size of a thread block (x,y,z): (1024, 1024, 64) Max dimension size of a grid size (x,y,z): (2147483647, 65535, 65535) Maximum memory pitch: 2147483647 bytes Texture alignment: 512 bytes Concurrent copy and kernel execution: Yes with 3 copy engine(s) Run time limit on kernels: No Integrated GPU sharing Host Memory: No Support host page-locked memory mapping: Yes Alignment requirement for Surfaces: Yes Device has ECC support: Disabled Device supports Unified Addressing (UVA): Yes Device supports Compute Preemption: Yes Supports Cooperative Kernel Launch: Yes Supports MultiDevice Co-op Kernel Launch: Yes Device PCI Domain ID / Bus ID / location ID: 0 / 1 / 0 Compute Mode: \u0026lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) \u0026gt; Device 1: \u0026#34;GeForce RTX 2080 Ti\u0026#34; CUDA Driver Version / Runtime Version 10.1 / 10.1 CUDA Capability Major/Minor version number: 7.5 Total amount of global memory: 11019 MBytes (11554717696 bytes) (68) Multiprocessors, ( 64) CUDA Cores/MP: 4352 CUDA Cores GPU Max Clock rate: 1545 MHz (1.54 GHz) Memory Clock rate: 7000 Mhz Memory Bus Width: 352-bit L2 Cache Size: 5767168 bytes Maximum Texture Dimension Size (x,y,z) 1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384) Maximum Layered 1D Texture Size, (num) layers 1D=(32768), 2048 layers Maximum Layered 2D Texture Size, (num) layers 2D=(32768, 32768), 2048 layers Total amount of constant memory: 65536 bytes Total amount of shared memory per block: 49152 bytes Total number of registers available per block: 65536 Warp size: 32 Maximum number of threads per multiprocessor: 1024 Maximum number of threads per block: 1024 Max dimension size of a thread block (x,y,z): (1024, 1024, 64) Max dimension size of a grid size (x,y,z): (2147483647, 65535, 65535) Maximum memory pitch: 2147483647 bytes Texture alignment: 512 bytes Concurrent copy and kernel execution: Yes with 3 copy engine(s) Run time limit on kernels: No Integrated GPU sharing Host Memory: No Support host page-locked memory mapping: Yes Alignment requirement for Surfaces: Yes Device has ECC support: Disabled Device supports Unified Addressing (UVA): Yes Device supports Compute Preemption: Yes Supports Cooperative Kernel Launch: Yes Supports MultiDevice Co-op Kernel Launch: Yes Device PCI Domain ID / Bus ID / location ID: 0 / 2 / 0 Compute Mode: \u0026lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) \u0026gt; \u0026gt; Peer access from GeForce RTX 2080 Ti (GPU0) -\u0026gt; GeForce RTX 2080 Ti (GPU1) : Yes \u0026gt; Peer access from GeForce RTX 2080 Ti (GPU1) -\u0026gt; GeForce RTX 2080 Ti (GPU0) : Yes deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 10.1, CUDA Runtime Version = 10.1, NumDevs = 2 源码 # https://github.com/NVIDIA/cuda-samples/tree/master/Samples/deviceQuery\n编译 # /usr/local/cuda/bin/nvcc deviceQuery.cpp -I /usr/local/cuda/samples/common/inc/ -o deviceQuery "},{"id":38,"href":"/blog/ffmpeg/rdgQnFI6j/","title":"ffprobe详解","section":"📚 我的文章","content":" ffprobe是ffmpeg提供的三大工具之一，用来查看音视频文件的各种信息，比如：封装格式、音频/视频流信息、数据包信息等。\nffprobe的源码是ffprobe.c，开发过程中如果想获取ffprobe查看的信息，可以通过分析源码，获得对应字段。\n本文主要介绍format、stream、Packet和Frame信息，包含每个字段的说明以及对应的ffmpeg字段。\n查看音视频文件的封装格式 # ffprobe -show_format inputFile 输出信息：\n[FORMAT] // 文件名 filename=VID_20190811_113717.mp4 // 容器中流的个数，即AVFormatContext-\u0026gt;nb_streams nb_streams=2 // 即AVFormatContext-\u0026gt;nb_programs nb_programs=0 // 封装格式，即AVFormatContext-\u0026gt;iformat-\u0026gt;name format_name=mov,mp4,m4a,3gp,3g2,mj2 // 即AVFormatContext-\u0026gt;iformat-\u0026gt;long_name format_long_name=QuickTime / MOV // 即AVFormatContext-\u0026gt;start_time，基于AV_TIME_BASE_Q，换算为秒 start_time=0.000000 // 即AVFormatContext-\u0026gt;duration，基于AV_TIME_BASE_Q，换算为秒 duration=10.508000 // 单位字节，即avio_size(AVFormatContext-\u0026gt;pb) size=27263322 // 码率，即AVFormatContext-\u0026gt;bit_rate bit_rate=20756240 // 即AVFormatContext-\u0026gt;probe_score probe_score=100 [/FORMAT] 查看音视频文件的流信息 # ffprobe -show_streams inputFile 输出信息：\n[STREAM] // 当前流的索引信息,对应于AVStream-\u0026gt;index index=0 // AVCodecDescriptor * cd = avcodec_descriptor_get(AVStream-\u0026gt;codecpar-\u0026gt;codec_id) // 编码名称，即cd-\u0026gt;name codec_name=h264 // 编码全称，即cd-\u0026gt;long_name codec_long_name=H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 // 一个编码参数，可以为Baseline、Main、High等，Baseline无B帧，Main及以后可以包含B帧 // 通过avcodec_profile_name(AVStream-\u0026gt;codecpar-\u0026gt;codec_id, AVStream-\u0026gt;codecpar-\u0026gt;profile)获得 profile=High // 流类型，即av_get_media_type_string(AVStream-\u0026gt;codecpar-\u0026gt;codec_type) codec_type=video // 即AVStream-\u0026gt;codec-\u0026gt;time_base codec_time_base=14777/877500 // 通过宏av_fourcc2str(AVStream-\u0026gt;codecpar-\u0026gt;codec_tag)获得 codec_tag_string=avc1 // 对应AVStream-\u0026gt;codecpar-\u0026gt;codec_tag codec_tag=0x31637661 // 有效区域的宽度，即AVStream-\u0026gt;codecpar-\u0026gt;width width=1920 // 有效区域的高度，即AVStream-\u0026gt;codecpar-\u0026gt;height height=1080 // 视频帧宽度，可能与上面的宽度不同，即AVStream-\u0026gt;codec-\u0026gt;coded_width，例如：当解码帧在输出前裁剪或启用低分辨率时 coded_width=1920 // 视频帧高度，可能与上面的高度不同，即AVStream-\u0026gt;codec-\u0026gt;coded_height，例如：当解码帧在输出前裁剪或启用低分辨率时 coded_height=1088 // 视频的延迟帧数，即AVStream-\u0026gt;codecpar-\u0026gt;video_delay has_b_frames=0 // sar，图像采集时，横向采集点数与纵向采集点数的比例 // FFmpeg提供了多个sar：AVStream-\u0026gt;sample_aspect_ratio、AVStream-\u0026gt;codecpar-\u0026gt;sample_aspect_ratio、AVFrame-\u0026gt;sample_aspect_ratio // 通过av_guess_sample_aspect_ratio获取最终的sar sample_aspect_ratio=1:1 // dar，真正展示的图像宽高比，在渲染视频时，必须根据这个比例进行缩放 // 通过av_reduce计算得到，par * sar = dar display_aspect_ratio=16:9 // 像素格式，即av_get_pix_fmt_name(AVStream-\u0026gt;codecpar-\u0026gt;format) pix_fmt=yuvj420p // 编码参数，即AVStream-\u0026gt;codecpar-\u0026gt;level level=40 // 额外的色彩空间特征，即av_color_range_name(AVStream-\u0026gt;codecpar-\u0026gt;color_range)，AVCOL_RANGE_MPEG对应tv，AVCOL_RANGE_JPEG对应pc color_range=pc // YUV彩色空间类型，即av_color_space_name(AVStream-\u0026gt;codecpar-\u0026gt;color_space) color_space=bt470bg // 颜色传输特性，即av_color_transfer_name(AVStream-\u0026gt;codecpar-\u0026gt;color_trc) color_transfer=smpte170m // 即av_color_primaries_name(AVStream-\u0026gt;codecpar-\u0026gt;color_primaries) color_primaries=bt470bg // 色度样品的位置，即av_chroma_location_name(AVStream-\u0026gt;codecpar-\u0026gt;chroma_location) chroma_location=left // 交错视频中字段的顺序，即AVStream-\u0026gt;codecpar-\u0026gt;field_order field_order=unknown // av_timecode_make_mpeg_tc_string处理AVStream-\u0026gt;codec-\u0026gt;timecode_frame_start获得 timecode=N/A // 参考帧数量，即AVStream-\u0026gt;codec-\u0026gt;refs refs=1 is_avc=true // 表示用几个字节表示NALU的长度 nal_length_size=4 id=N/A // 当前流的基本帧率，这个值仅是一个猜测，对应于AVStream-\u0026gt;r_frame_rate r_frame_rate=30/1 // 平均帧率，对应于AVStream-\u0026gt;avg_frame_rate avg_frame_rate=438750/14777 // AVStream的时间基准，即AVStream-\u0026gt;time_base time_base=1/90000 // 流开始时间，基于time_base，即AVStream-\u0026gt;start_time start_pts=0 // 转换（start_pts * time_base）之后的开始时间，单位秒 start_time=0.000000 // 流时长，基于time_base，即AVStream-\u0026gt;duration duration_ts=945728 // 转换（duration_ts * time_base）之后的时长，单位秒 duration=10.508089 // 码率，即AVStream-\u0026gt;codecpar-\u0026gt;bit_rate bit_rate=19983544 // 最大码率，即AVStream-\u0026gt;codec-\u0026gt;rc_max_rate max_bit_rate=N/A // Bits per sample/pixel，即AVStream-\u0026gt;codec-\u0026gt;bits_per_raw_sample bits_per_raw_sample=8 // 视频流中的帧数，即AVStream-\u0026gt;nb_frames nb_frames=312 nb_read_frames=N/A nb_read_packets=N/A // 下面TAG为AVStream-\u0026gt;metadata中的信息 // 逆时针的旋转角度（相当于正常视频的逆时针旋转角度） TAG:rotate=90 // 创建时间 TAG:creation_time=2019-08-11T03:37:28.000000Z // 语言 TAG:language=eng TAG:handler_name=VideoHandle // SIDE_DATA为AVStream-\u0026gt;side_data数据 [SIDE_DATA] // side_data数据类型，Display Matrix表示一个3*3的矩阵，这个矩阵需要应用到解码后的视频帧上，才能正确展示 side_data_type=Display Matrix displaymatrix= 00000000: 0 65536 0 00000001: -65536 0 0 00000002: 0 0 1073741824 // 顺时针旋转90度还原视频 rotation=-90 [/SIDE_DATA] [/STREAM] [STREAM] // 当前流的索引信息,对应于AVStream-\u0026gt;index index=1 // AVCodecDescriptor * cd = avcodec_descriptor_get(AVStream-\u0026gt;codecpar-\u0026gt;codec_id) // 编码名称，即cd-\u0026gt;name codec_name=aac // 编码全称，即cd-\u0026gt;long_name codec_long_name=AAC (Advanced Audio Coding) // 通过avcodec_profile_name(AVStream-\u0026gt;codecpar-\u0026gt;codec_id, AVStream-\u0026gt;codecpar-\u0026gt;profile)获得 profile=LC // 流类型，即av_get_media_type_string(AVStream-\u0026gt;codecpar-\u0026gt;codec_type) codec_type=audio // 即AVStream-\u0026gt;codec-\u0026gt;time_base codec_time_base=1/48000 // 通过宏av_fourcc2str(AVStream-\u0026gt;codecpar-\u0026gt;codec_tag)获得 codec_tag_string=mp4a // 对应AVStream-\u0026gt;codecpar-\u0026gt;codec_tag codec_tag=0x6134706d // 采样点格式，通过av_get_sample_fmt_name(AVStream-\u0026gt;codecpar-\u0026gt;format)获取 sample_fmt=fltp // 采样率，即AVStream-\u0026gt;codecpar-\u0026gt;sample_rate sample_rate=48000 // 通道数，即AVStream-\u0026gt;codecpar-\u0026gt;channels channels=2 // 通道布局，与channels是相对应，通过av_bprint_channel_layout获取，stereo表示立体声 channel_layout=stereo // 每个采样点占用多少bit，即av_get_bits_per_sample(par-\u0026gt;codec_id) bits_per_sample=0 id=N/A r_frame_rate=0/0 avg_frame_rate=0/0 // AVStream的时间基准，即AVStream-\u0026gt;time_base time_base=1/48000 // 流开始时间，基于time_base，即AVStream-\u0026gt;start_time start_pts=0 // 转换（start_pts * time_base）之后的开始时间，单位秒 start_time=0.000000 // 流时长，基于time_base，即AVStream-\u0026gt;duration duration_ts=502776 // 转换（duration_ts * time_base）之后的时长，单位秒 duration=10.474500 // 码率，即AVStream-\u0026gt;codecpar-\u0026gt;bit_rate bit_rate=156002 // 最大码率，即AVStream-\u0026gt;codec-\u0026gt;rc_max_rate max_bit_rate=156000 // Bits per sample/pixel，即AVStream-\u0026gt;codec-\u0026gt;bits_per_raw_sample bits_per_raw_sample=N/A // 音频流中的帧数，即AVStream-\u0026gt;nb_frames nb_frames=491 nb_read_frames=N/A nb_read_packets=N/A TAG:creation_time=2019-08-11T03:37:28.000000Z TAG:language=eng TAG:handler_name=SoundHandle [/STREAM] SAR(Sample Aspect Ratio): 采样数宽高比，图像的横向采集点数与纵向采集点数的比值，即像素个数的比值。\nPAR(Pixel Aspect Ratio): 像素宽高比，即每个像素的宽度与高度的比值，所以可以认为像素不是正方形的。\nDAR(Display Aspect Ratio): 显示宽高比，图像最终展示的宽高比，播放器在渲染视频帧时，需要保持DAR的比例。\n它们之间的关系：PAR * SAR = DAR\n如上图所示：每个方格代表一个像素，宽度为5像素，高度为4像素，即SAR=5 : 4\n假设图像的显示宽度为160，高度为120，即DAR=4 : 3\n那么可以计算出PAR = DAR / SAR = 16 : 15，表示像素方格是一个长方形。\nFFmpeg提供了多个SAR：\nAVStream-\u0026gt;sample_aspect_ratio\nAVStream-\u0026gt;codecpar-\u0026gt;sample_aspect_ratio\nAVFrame-\u0026gt;sample_aspect_ratio\n最终的SAR是通过av_guess_sample_aspect_ratio获取的。\n对于DAR，AVStream-\u0026gt;display_aspect_ratio的值始终为0:0，参考ffprobe代码，可知DAR是通过av_reduce计算得到的，如下所示：\nAVRational sar, dar; // par AVCodecParameters *par = AVStream-\u0026gt;codecpar; // 计算出sar sar = av_guess_sample_aspect_ratio(AVFormatContext, AVStream, NULL); // 根据par和sar计算出dar av_reduce(\u0026amp;dar.num, \u0026amp;dar.den, par-\u0026gt;width * sar.num, par-\u0026gt;height * sar.den, 1024*1024); 查看音视频文件的数据包信息 # // -select_streams表示选择音频或者视频 ffprobe -show_format [-select_streams audio | video] inputFile 首先看下视频流的第一个Packet和第二个Packet：\n[PACKET] //Packet类型，即av_get_media_type_string(AVStream-\u0026gt;codecpar-\u0026gt;codec_type) codec_type=video // 当前帧所属流的索引信息,对应于AVStream-\u0026gt;index stream_index=0 // 帧展示时间，即AVPacket-\u0026gt;pts，基于AVStream-\u0026gt;time_base时间基准 pts=0 // 换算为秒 pts_time=0.000000 // 帧解码时间，即AVPacket-\u0026gt;dts，基于AVStream-\u0026gt;time_base时间基准 dts=0 // 换算为秒 dts_time=0.000000 // 当前帧的时长，等于下一帧的pts - 当前帧pts，即AVPacket-\u0026gt;duration，基于AVStream-\u0026gt;time_base时间基准 duration=12972 // 换算为秒 duration_time=0.144133 // AVPacket-\u0026gt;convergence_duration，也是基于AVStream-\u0026gt;time_base时间基准 convergence_duration=N/A // 换算为秒 convergence_duration_time=N/A // 当前帧的Size，字节，即AVPacket-\u0026gt;size size=187872 // 当前帧地址偏移量，即AVPacket-\u0026gt;pos pos=830842 flags=K_ [/PACKET] [PACKET] codec_type=video stream_index=0 pts=12972 // 即 12972 / 90000 pts_time=0.144133 dts=12972 dts_time=0.144133 duration=2999 duration_time=0.033322 convergence_duration=N/A convergence_duration_time=N/A size=31200 // 上一帧的pos + size pos=1018714 flags=__ [/PACKET] 然后看下音频流的第一个Packet和第二个Packet：\n[PACKET] // 音频帧 codec_type=audio // 当前帧所属流的索引信息,对应于AVStream-\u0026gt;index stream_index=1 // 帧展示时间，即AVPacket-\u0026gt;pts，基于AVStream-\u0026gt;time_base时间基准 pts=0 pts_time=0.000000 // 帧解码时间，即AVPacket-\u0026gt;dts，基于AVStream-\u0026gt;time_base时间基准 dts=0 dts_time=0.000000 // 当前帧的时长，等于下一帧的pts - 当前帧pts，即AVPacket-\u0026gt;duration，基于AVStream-\u0026gt;time_base时间基准 duration=1024 // 1024 / 48000 duration_time=0.021333 convergence_duration=N/A convergence_duration_time=N/A size=416 pos=810458 flags=K_ [/PACKET] [PACKET] // 音频帧 codec_type=audio stream_index=1 pts=1024 // 1024 / 48000 pts_time=0.021333 dts=1024 dts_time=0.021333 duration=1024 duration_time=0.021333 convergence_duration=N/A convergence_duration_time=N/A size=416 // 上一帧的pos + size pos=810874 flags=K_ [/PACKET] 查看音视频文件解码后的帧信息 # // -select_streams表示选择音频或者视频 ffprobe -show_frames [-select_streams audio | video] inputFile 首先看下视频流的第一帧和第二帧：\n[FRAME] // 帧类型，即av_get_media_type_string(AVStream-\u0026gt;codecpar-\u0026gt;codec_type) media_type=video // 当前帧所属流的索引信息, 对应于AVStream-\u0026gt;index stream_index=0 // 是否关键帧，1：关键帧，0：非关键帧，即AVFrame-\u0026gt;key_frame key_frame=1 // 帧展示时间, 即AVFrame-\u0026gt;pts, 基于AVStream-\u0026gt;time_base时间基准 pkt_pts=0 // 换算为秒 pkt_pts_time=0.000000 // 帧解码时间，从对应的AVPacket copy而来，即AVFrame-\u0026gt;pkt_dts，基于AVStream-\u0026gt;time_base时间基准 pkt_dts=0 // 换算为秒 pkt_dts_time=0.000000 // 帧时间戳，基本与pts相同，即AVFrame-\u0026gt;best_effort_timestamp，基于AVStream-\u0026gt;time_base时间基准 best_effort_timestamp=0 // 换算为秒 best_effort_timestamp_time=0.000000 // 对应的AVPacket的帧时长，即AVFrame-\u0026gt;pkt_duration，基于AVStream-\u0026gt;time_base时间基准 pkt_duration=12972 // 换算为秒 pkt_duration_time=0.144133 // 从最后一个已输入解码器的AVPacket重新排序的pos，即AVFrame-\u0026gt;pkt_pos pkt_pos=830842 // 对应的AVPacket的帧size，即AVFrame-\u0026gt;pkt_size pkt_size=187872 // 旋转之前的帧宽度，即AVFrame-\u0026gt;width width=1920 // 旋转之前的帧高度，即AVFrame-\u0026gt;height height=1080 // 视频帧的像素格式，即av_get_pix_fmt_name(AVFrame-\u0026gt;format) pix_fmt=yuvj420p // sar，图像采集时，横向采集点数与纵向采集点数的比例 // FFmpeg提供了多个sar：AVStream-\u0026gt;sample_aspect_ratio、AVStream-\u0026gt;codecpar-\u0026gt;sample_aspect_ratio、AVFrame-\u0026gt;sample_aspect_ratio // 通过av_guess_sample_aspect_ratio获取最终的sar sample_aspect_ratio=1:1 // 视频帧的图片类型，此处为I帧，即av_get_picture_type_char(frame-\u0026gt;pict_type) pict_type=I // picture number in bitstream order, 即AVFrame-\u0026gt;coded_picture_number coded_picture_number=0 // picture number in display order, 即AVFrame-\u0026gt;display_picture_number display_picture_number=0 // 视频帧内容是否是交错的, 即AVFrame-\u0026gt;interlaced_frame interlaced_frame=0 // 若视频帧内容是交错的，表示首先展示的顶部字段，即AVFrame-\u0026gt;top_field_first top_field_first=0 // 当解码时，这个信号表明视频帧必须延迟多少。extra_delay = repeat_pict / (2*fps), 即AVFrame-\u0026gt;repeat_pict repeat_pict=0 // 额外的色彩空间特征，即av_color_range_name(AVFrame-\u0026gt;color_range)，AVCOL_RANGE_MPEG对应tv，AVCOL_RANGE_JPEG对应pc color_range=pc // YUV彩色空间类型，即av_color_space_name(AVFrame-\u0026gt;colorspace) color_space=bt470bg // 即av_color_primaries_name(AVFrame-\u0026gt;color_primaries) color_primaries=bt470bg // 颜色传输特性，即av_color_transfer_name(AVFrame-\u0026gt;color_trc) color_transfer=smpte170m // 色度样品的位置，即av_chroma_location_name(AVFrame-\u0026gt;chroma_location) chroma_location=left [/FRAME] [FRAME] media_type=video stream_index=0 // 非关键帧 key_frame=0 pkt_pts=12972 // 12972 / 90000 pkt_pts_time=0.144133 pkt_dts=12972 pkt_dts_time=0.144133 best_effort_timestamp=12972 best_effort_timestamp_time=0.144133 pkt_duration=2999 pkt_duration_time=0.033322 pkt_pos=1018714 pkt_size=31200 width=1920 height=1080 pix_fmt=yuvj420p sample_aspect_ratio=1:1 // 视频帧的图片类型，此处为P帧，即av_get_picture_type_char(frame-\u0026gt;pict_type) pict_type=P coded_picture_number=1 display_picture_number=0 interlaced_frame=0 top_field_first=0 repeat_pict=0 color_range=pc color_space=bt470bg color_primaries=bt470bg color_transfer=smpte170m chroma_location=left [/FRAME] 然后看下音频流的第一帧和第二帧：\n[FRAME] // 帧类型，即av_get_media_type_string(AVStream-\u0026gt;codecpar-\u0026gt;codec_type) media_type=audio // 当前帧所属流的索引信息, 对应于AVStream-\u0026gt;index stream_index=1 // 是否关键帧 key_frame=1 // 帧展示时间, 即AVFrame-\u0026gt;pts, 基于AVStream-\u0026gt;time_base时间基准 pkt_pts=0 // 换算为秒 pkt_pts_time=0.000000 // 帧解码时间，从对应的AVPacket copy而来，即AVFrame-\u0026gt;pkt_dts，基于AVStream-\u0026gt;time_base时间基准 pkt_dts=0 // 换算为秒 pkt_dts_time=0.000000 // 帧时间戳，基本与pts相同，即AVFrame-\u0026gt;best_effort_timestamp，基于AVStream-\u0026gt;time_base时间基准 best_effort_timestamp=0 // 换算为秒 best_effort_timestamp_time=0.000000 // 对应的AVPacket的帧时长，即AVFrame-\u0026gt;pkt_duration，基于AVStream-\u0026gt;time_base时间基准 pkt_duration=1024 // 换算为秒 pkt_duration_time=0.021333 // 从最后一个已输入解码器的AVPacket重新排序的pos，即AVFrame-\u0026gt;pkt_pos pkt_pos=810458 // 对应的AVPacket的帧size，即AVFrame-\u0026gt;pkt_size pkt_size=416 // 音频采样点格式，即av_get_sample_fmt_name(AVFrame-\u0026gt;format) sample_fmt=fltp // 当前音频帧的采样点数，即AVFrame-\u0026gt;nb_samples nb_samples=1024 // 通道数，即AVFrame-\u0026gt;channels channels=2 // 通道布局，通过av_bprint_channel_layout得到，与channels对应 channel_layout=stereo [/FRAME] [FRAME] media_type=audio stream_index=1 key_frame=1 pkt_pts=1024 pkt_pts_time=0.021333 pkt_dts=1024 pkt_dts_time=0.021333 best_effort_timestamp=1024 best_effort_timestamp_time=0.021333 pkt_duration=1024 pkt_duration_time=0.021333 pkt_pos=810874 pkt_size=416 sample_fmt=fltp nb_samples=1024 channels=2 channel_layout=stereo [/FRAME] 参考文章 # FFmpeg获取视频正确的宽高比\n转载自-\u0026gt;https://www.zybuluo.com/ltlovezh/note/1534824\n"},{"id":39,"href":"/blog/macos/MiSev5_HW/","title":"upx for macos 之源码编译","section":"📚 我的文章","content":" UPX (the Ultimate Packer for eXecutables)是一款先进的可执行程序文件压缩器，压缩过的可执行文件体积缩小50%-70% ，这样减少了磁盘占用空间、网络上传下载的时间和其它分布以及存储费用。\n准备源码 # git clone https://github.com/upx/upx.git git clone https://github.com/upx/upx-lzma-sdk.git lzma-sdk wget http://www.oberhumer.com/opensource/ucl/download/ucl-1.03.tar.gz 编译源码 # tar -xzvf ucl-1.03.tar.gz cd ucl-1.03 ./configure --prefix=/home/o/ucl CC=clang make cd ../upx make all UPX_UCLDIR=../ucl-1.03 UPX_LZMADIR=../lzma-sdk 编译完成之后再src目录下能找到upx.out文件就成功了\n"},{"id":40,"href":"/blog/ffmpeg/ovfEIBOES/","title":"ffmpeg 删除音视频文件中的元数据","section":"📚 我的文章","content":" 清除mp3文件中自带的专辑（album），艺术家（artist），流派（genre）等元数据。\nffmpeg -i \u0026#34;test.mp3\u0026#34; -b:a 320k -map_metadata -1 -y \u0026#34;out.mp3\u0026#34; -map_metadata -1 表示清除所有元数据\n"},{"id":41,"href":"/blog/linux/roH7hpe6L/","title":"mediainfo 静态编译脚本","section":"📚 我的文章","content":" 因为需要mediainfo支持http协议，在老的版本中是不支持的，所以只能自己动手编译了。\n说明 # 系统：ubuntu 14.04 (其他版本可能会有少许改动)\nmediainfo版本：0.7.71\n编译环境：c/c++\n脚本 # #!/bin/bash cd ~/ apt-get install git automake autoconf libtool pkg-config make g++ zlib1g-dev libcurl4-gnutls-dev git clone https://github.com/MediaArea/ZenLib.git cd ZenLib make clean git checkout v0.4.37 cd Project/GNU/Library ./autogen.sh ./configure --enable-static make -j2 cd ~/ git clone https://github.com/openssl/openssl.git cd openssl make clean git checkout OpenSSL_1_0_2i ./Configure linux-generic64 make -j2 curl_vserion=7.50.0 cd ~/ wget --no-check-certificate https://curl.haxx.se/download/curl-$curl_vserion.tar.gz tar -zxvf curl-$curl_vserion.tar.gz cd curl-$curl_vserion/ make clean ./configure --enable-static --disable-share --disable-ldap --disable-ldaps --without-librtmp --without-libidn make -j2 cd ~/ git clone https://github.com/MediaArea/MediaInfoLib.git cd MediaInfoLib git checkout v0.7.71 cd Project/GNU/Library/ make clean ./autogen ./configure --enable-static --with-libcurl=../../../../curl-$curl_vserion/ make -j2 cd ~/ git clone https://github.com/MediaArea/MediaInfo.git cd MediaInfo git checkout v0.7.71 cd Project/GNU/CLI make clean ./autogen ./configure --enable-staticlibs make -j2 # make install g++ -static -O2 -DUNICODE -DUNICODE -DSIZE_T_IS_LONG -o mediainfo CLI_Main.o CommandLine_Parser.o Help.o Core.o ../../../../MediaInfoLib/Project/GNU/Library/.libs/libmediainfo.a -lz ../../../../ZenLib/Project/GNU/Library/.libs/libzen.a ../../../../curl-$curl_vserion/lib/.libs/libcurl.a ../../../../openssl/libssl.a ../../../../openssl/libcrypto.a -lpthread -lstdc++ -pthread -Wl,-rpath -Wl,../../../../ZenLib/Project/GNU/Library/.libs -Wl,-rpath -Wl,../../../../curl-$curl_vserion/lib/.libs -Wl,-rpath -Wl,../../../../openssl -ldl "},{"id":42,"href":"/blog/linux/RRaHkWbSu/","title":"ssh免秘钥登陆常见问题","section":"📚 我的文章","content":" 收集一些ssh登陆常见的问题，方便快速解决问题。\n重要事情 # cat /var/log/secure cat /var/log/message 无论你遇到任何奇葩的sshd问题，你先执行上面的命令查看下日志。\n错误一 # 问题描述 # Authentication refused:bad ownership or modes for dircetory /root 解决方法 # chmod 700 /root 其他相关 # id_ras 权限为600\n/root/.ssh 权限为600\n"},{"id":43,"href":"/blog/linux/JQIo7dGc1/","title":"openssl - https SAN自签名证书","section":"📚 我的文章","content":" 使用openssl生产自签名证书，用于https测试。\nCA根证书制作 # #1.生成根证书密钥 $ openssl genrsa -out ca.key 4096 #建议长度为4096,1024长度已经被列为不安全。 #2.生成自签名根证书 $ openssl req -new -x509 -days 3650 -key ca.key -out ca.crt #这里在输入CommonName的时候输入名称而不是域名或者ip,就是证书上显示的颁发者，虽然是自签名证书，但是尽量让证书看起来标准一些 使用根证书来签名其它证书 # 1.生成证书密钥 # $ openssl genrsa -out server.key 4096 2. Subject Alt Name(SAN) # 高版本的Chrome浏览器会要求设置 subjectAltName,如果没有设置SAN会报证书错误\n参考openssl配置文件,Linux服务器上通常在 /etc/pki/tls/openssl.cnf\n新建文件 san.conf\n[req] default_bits = 4096 distinguished_name = req_distinguished_name req_extensions = v3_req [req_distinguished_name] countryName = country stateOrProvinceName = province localityName = city organizationName = company name commonName = domain name or ip [v3_req] subjectAltName = @alt_names [alt_names] NDS.1=domain #可以使用通配符 IP.1=xxx.xxx.xxx.xxx 3. 生成证书签名请求(CSR) # 向根证书请求签名一个新的证书，由于用户信任了你的根证书，所以根证书签名的其它证书也会被信任\n# 生成csr 注意要使用sha256算法（推荐是sha256算法，默认算法浏览器会报弱加密算法错误） $ openssl req -new -key server.key -out server.csr -config san.conf -sha256 # 查看csr信息 $ openssl req -text -in server.csr csr信息中会有类似的信息\nRequested Extensions: X509v3 Subject Alternative Name: IP Address:xxxxxx 4.使用根证书按照csr给证书签名，生成新证书server.crt # $ openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt -extfile san.conf -extensions v3_req 查看证书信息\n$ openssl x509 -text -in server.crt 证书信息中会有类似信息\nX509v3 extensions: X509v3 Subject Alternative Name: IP Address:xxxxxx "},{"id":44,"href":"/blog/linux/yhK4y-gaU/","title":"Centos7-yum安装MySQL5.6","section":"📚 我的文章","content":" centos自带的repo是不会自动更新每个软件的新版本，所以无法通过yum方式安装MySQL的高版本，所以一般通过社区rpm包安装。\n安装yum源 # rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm 查看mysql安装源 # yum repolist enabled | grep \u0026#34;mysql.*-community.*\u0026#34; 安装mysql56 # yum -y install mysql-community-server 开机启动 # systemctl enable mysqld 启动服务 # systemctl start mysqld 重置密码 # mysql_secure_installation NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MySQL SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! In order to log into MySQL to secure it, we\u0026#39;ll need the current password for the root user. If you\u0026#39;ve just installed MySQL, and you haven\u0026#39;t set the root password yet, the password will be blank, so you should just press enter here. Enter current password for root (enter for none): ERROR 1045 (28000): Access denied for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; (using password: YES) Enter current password for root (enter for none): ERROR 1045 (28000): Access denied for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; (using password: YES) Enter current password for root (enter for none): OK, successfully used password, moving on... Setting the root password ensures that nobody can log into the MySQL root user without the proper authorisation. Set root password? [Y/n] y New password: Re-enter new password: Password updated successfully! Reloading privilege tables.. ... Success! By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? [Y/n] Y ... Success! Normally, root should only be allowed to connect from \u0026#39;localhost\u0026#39;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? [Y/n] n ... skipping. By default, MySQL comes with a database named \u0026#39;test\u0026#39; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? [Y/n] n ... skipping. Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? [Y/n] Y ... Success! All done! If you\u0026#39;ve completed all of the above steps, your MySQL installation should now be secure. Thanks for using MySQL! Cleaning up... "},{"id":45,"href":"/blog/linux/B1G3FwCaN/","title":"supervisor 安装和使用方法","section":"📚 我的文章","content":" Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。\n准备工作 # yum install epel-* -y yum install python34 -y wget --no-check-certificate python3 get-pip.py 安装supervisor # pip3 install supervisor 配置supervisor # echo_supervisord_conf \u0026gt;/etc/supervisord.conf vi /etc/supervisord.conf ...... ;[include] ;这个东西挺有用的，当我们要管理的进程很多的时候，写在一个文件里面就有点大了。我们可以把配置信息写到多个文件中，然后include过来 ;files = relative/directory/*.ini 去掉上面两行的”;“然后将files改成自己的目录\nvi /etc/supervisord.conf [unix_http_server] file=/tmp/supervisor.sock ;UNIX socket 文件，supervisorctl 会使用 ;chmod=0700 ;socket文件的mode，默认是0700;chown=nobody:nogroup ;socket文件的owner，格式：uid:gid ;[inet_http_server] ;HTTP服务器，提供web管理界面 ;port=127.0.0.1:9001 ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性 ;username=user ;登录管理后台的用户名 ;password=123 ;登录管理后台的密码 [supervisord] logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.loglogfile_maxbytes=50MB ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小 logfile_backups=10 ;日志文件保留备份数量默认10，设为0表示不备份 loglevel=info ;日志级别，默认info，其它: debug,warn,trace pidfile=/tmp/supervisord.pid ;pid 文件 nodaemon=false ;是否在前台启动，默认是false，即以 daemon 的方式启动 minfds=1024 ;可以打开的文件描述符的最小值，默认 1024minprocs=200 ;可以打开的进程数的最小值，默认 200 [supervisorctl] serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord ; [program:xx]是被管理的进程配置参数，xx是进程的名称 [program:xx] command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run ; 程序启动命令 autostart=true ; 在supervisord启动的时候也自动启动 startsecs=10 ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒 autorestart=true ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启 startretries=3 ; 启动失败自动重试次数，默认是3user=tomcat ; 用哪个用户启动进程，默认是root priority=999 ; 进程启动优先级，默认999，值小的优先启动 redirect_stderr=true ; 把stderr重定向到stdout，默认falsestdout_logfile_maxbytes=20MB ; stdout 日志文件大小，默认50MB stdout_logfile_backups = 20 ; stdout 日志文件备份数，默认是10; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件） stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out stopasgroup=false ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程 killasgroup=false ;默认为false，向进程组发送kill信号，包括子进程 ;包含其它配置文件 [include] files = /etc/supervisord.d/*.ini ;可以指定一个或多个以.ini结束的配置文件 mkdir /etc/supervisord.d/ 启动supervisor # supervisord -c /etc/supervisord.conf 常用命令 # 查看状态 # supervisorctl status 启动服务 # supervisorctl start 服务名 停止服务 # supervisorctl stop 服务名 重启服务 # supervisorctl restart 服务名 增加服务 # vim /etc/supervisord.d/test.ini [program:test] #程序的名字，在supervisor中可以用这个名字来管理该程序。 user=root #指定运行用户 command=bash /root/1.sh #启动程序的命令 autorstart=true #设置改程序是否虽supervisor的启动而启动 directory=/home/lege #相当于在该目录下执行程序 autorestart=true #程序停止之后是否需要重新将其启动 startsecs=5 #重新启动时，等待的时间 startretries=100 #重启程序的次数 redirect_stderr=true #是否将程序错误信息重定向的到文件 stdout_logfile=/var/log/log.txt #将程序输出重定向到该文件 stderr_logfile=/var/log/err.txt #将程序错误信息重定向到该文件 supervisorctl update "},{"id":46,"href":"/blog/linux/HkCTnskvV/","title":"error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory","section":"📚 我的文章","content":" 不小心误删libc.so.6\n安装完成后, 建立软链指向glibc-2.14, 执行如下命令:\n$ rm -rf /lib64/libc.so.6 // 先删除先前的libc.so.6软链\n$ ln -s /opt/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6 注意：删除libc.so.6之后可能导致系统命令不可用的情况, 可使用如下方法解决:\n$ LD_PRELOAD=/opt/glibc-2.14/lib/libc-2.14.so ln -s /opt/glibc-2.14/lib/libc-2.14.so /lib64/libc.so.6 如果上述更新失败可使用如下命令还原:\n$ LD_PRELOAD=/lib64/libc-2.12.so ln -s /lib64/libc-2.12.so /lib64/libc.so.6 // libc-2.12.so 此项是系统升级前的版本 "},{"id":47,"href":"/blog/linux/rk-lmMGL4/","title":"yum错误:problem making ssl connection Trying other mirror","section":"📚 我的文章","content":" yum无法使用带https的源\n环境 # yum install epel-release 运行以上命令之后，安装其他软件就报错。\n错误提示 # [Errno 14] problem making ssl connection Trying other mirror. Trying other mirror Error: Cannot retrieve repository metadata (repomd.xml) for repository: xxxx. Please verify its path and try again 经过google查询，发现似乎是ssl证书的原因。\n解决方法1 # # cd /etc/yum.repos.d/ # ls CentOS6-Base-163.repo epel.repo（修改他） epel-testing.repo # pwd /etc/yum.repos.d # vim /etc/yum.repos.d/epel.repo [epel] name=Extra Packages for Enterprise Linux 6 - $basearch baseurl=http://download.fedoraproject.org/pub/epel/6/$basearch #mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-6\u0026amp;arch=$basearch failovermethod=priority enabled=1 gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6 把baseurl注释去掉，给mirrorlist加上注释。然后将enabeld=1变为0，禁用ssl证书验证。\n解决方法2 # yum install ca-certificates yum update curl 将enable设置为1即可\n"},{"id":48,"href":"/blog/linux/H10_K-VQ4/","title":"CentOS7 php5.6 编译安装amqp扩展","section":"📚 我的文章","content":" php 安装最新rabbitmq扩展\n1、安装编译环境 # yum install cmake gcc gcc-c++ make openssl-devel 2、安装rabbitmq-c # wget https://github.com/alanxz/rabbitmq-c/archive/v0.9.0.zip unzip v0.9.0.zip cd rabbitmq-c-0.9.0/ cmake -DCMAKE_INSTALL_PREFIX=/usr/local/rabbitmq-c-0.9.0/ make \u0026amp;\u0026amp; make install 3、安装amqp # wget http://pecl.php.net/get/amqp-1.9.4.tgz tar zxf amqp-1.9.4.tgz cd amqp-1.9.4 /usr/bin/phpize ./configure --with-php-config=/usr/bin/php-config --with-amqp --with-librabbitmq-dir=/usr/local/rabbitmq-c-0.9.0 #由于rabbitmq-c编译出来的lib目录是lib64，所以我们要做一些小的修改 vim Makefile #将 AMQP_SHARED_LIBADD = -Wl,-rpath,/usr/local/rabbitmq-c-0.9.0/lib -L/usr/local/rabbitmq-c-0.9.0/lib -lrabbitmq #修改为 AMQP_SHARED_LIBADD = -Wl,-rpath,/usr/local/rabbitmq-c-0.9.0/lib64 -L/usr/local/rabbitmq-c-0.9.0/lib64 -lrabbitmq make \u0026amp;\u0026amp; make install 4、php.ini 添加模块 # vi /usr/local/php/etc/php.ini #增加 extension = /usr/lib64/php/modules/amqp.so 5、重启服务 # systemctl restart php-fpm "},{"id":49,"href":"/blog/linux/S1wDPAKf4/","title":"hadoop下载文件遇到的坑","section":"📚 我的文章","content":" hadoop fs -get 下载带特殊字符文件失败的一些解决方法。\n错误范例 # hadoop fs -get \u0026#34;/xxx/xxx分类/动漫Y/2005/蓝猫淘气3000问 航天系列（太空历险记）/第363集 协议.ts\u0026#34; \u0026#34;/media/bak/媒资源素材分类/动漫Y/2005/蓝猫淘气3000问 航天系列（太空历险记）/第363集 协议.ts\u0026#34; 运行以上命令就报“unexpexted URISyntaxException”\n解决方法 # hadoop fs -get \u0026#34;/xxx/xxx分类/动漫Y/2005/蓝猫淘气3000问 航天系列（太空历险记）/第363集 协议.ts\u0026#34; \u0026#34;%2Fmedia%2Fbak%2F%E5%AA%92%E8%B5%84%E6%BA%90%E7%B4%A0%E6%9D%90%E5%88%86%E7%B1%BB%2F%E5%8A%A8%E6%BC%ABY%2F2005%2F%E8%93%9D%E7%8C%AB%E6%B7%98%E6%B0%943000%E9%97%AE%20%E8%88%AA%E5%A4%A9%E7%B3%BB%E5%88%97%EF%BC%88%E5%A4%AA%E7%A9%BA%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%89%2F%E7%AC%AC363%E9%9B%86%20%E5%8D%8F%E8%AE%AE.ts\u0026#34; 将写到本地的路径进行url编码，然后神奇的就下载成功了，然后路径也是没有编码的绝对路径。\n"},{"id":50,"href":"/blog/linux/B1rSV2FzE/","title":"linux-iftop实时流量监控","section":"📚 我的文章","content":" iftop是类似于top的实时流量监控工具。可以用来监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等。\n安装 # Debian/Ubuntu/Deepin：\nsudo apt update sudo apt -y install iftop CentOS/RHEL：\nyum -y install epel-release yum -y install iftop iftop相关参数 # 常用的参数\n-i 设定监测的网卡，如：# iftop -i eth0\n-B 以bytes为单位显示流量(默认是bits)，如：# iftop -B\n-n 使主机名信息默认直接都显示IP，如：# iftop -n\n-N 使端口信息默认直接都显示端口号，如: # iftop -N\n-F 显示特定网段的进出流量，如# iftop -F 192.168.1.0/24或# iftop -F 192.168.1.0/255.255.255.0\n-h 帮助，显示参数信息\n-p 使用这个参数后，中间的列表显示的本地主机信息，出现了本机以外的IP信息;\n-b 使流量图形条默认就显示;\n-P 使主机名信息及端口信息，默认就都显示；\n-m 设置界面最上边的刻度的最大值，刻度分五个大段显示，例：# iftop -m 500M\niftop界面相关说明 # 界面上面显示的是类似刻度尺的刻度范围，为显示流量图形的长条作标尺用的。\n中间的\u0026lt;= =\u0026gt;这两个左右箭头，表示的是流量的方向，最后三列表示过去 2s 10s 40s 的平均流量。\nTX：发送流量\nRX：接收流量\nTOTAL：总流量\ncum：运行iftop到目前时间的总流量\npeak：流量峰值\nrates：分别表示过去 2s 10s 40s 的平均流量\n使用 # 进入iftop画面后的一些操作命令\nh 切换是否显示帮助;\nn 切换显示本机的IP或主机名;\ns 切换是否显示本机的主机名信息;\nd 切换是否显示远端目标主机的主机名信息;\nt 切换显示格式为2行/1行/只显示发送流量/只显示接收流量;\nN 切换显示端口号或端口服务名称;\nS 切换是否显示本机的端口信息;\nD 切换是否显示远端目标主机的端口信息;\np 切换是否显示端口信息;\nP 切换暂停/继续显示;\nb 切换是否显示平均流量图形条;\nB 切换计算2秒或10秒或40秒内的平均流量;\nT 切换是否显示每个连接的总流量;\nl 打开屏幕过滤功能，输入要过滤的字符，比如ip,按回车后，屏幕就只显示这个IP相关的流量信息;\nL 切换显示画面上边的刻度;刻度不同，流量图形条会有变化;\nj 或 k 可以向上或向下滚动屏幕显示的连接记录;\n1 或 2 或 3 可以根据右侧显示的三列流量数据进行排序;\n\u0026lt; 根据左边的本机名或IP排序;\n根据远端目标主机的主机名或IP排序;\no 切换是否固定只显示当前的连接;\nq 退出监控。\n"},{"id":51,"href":"/blog/linux/H1xaQL3-N/","title":"Centos7+Python2.7下yum安装软件报错解决办法","section":"📚 我的文章","content":" yum安装软件报错，但可以下载文件。\n错误信息 # Downloading packages: Running transaction check Running transaction test Transaction test succeeded Running transaction Traceback (most recent call last): File \u0026#34;/usr/bin/yum\u0026#34;, line 29, in \u0026lt;module\u0026gt; yummain.user_main(sys.argv[1:], exit_code=True) File \u0026#34;/usr/share/yum-cli/yummain.py\u0026#34;, line 365, in user_main errcode = main(args) File \u0026#34;/usr/share/yum-cli/yummain.py\u0026#34;, line 271, in main return_code = base.doTransaction() File \u0026#34;/usr/share/yum-cli/cli.py\u0026#34;, line 773, in doTransaction resultobject = self.runTransaction(cb=cb) File \u0026#34;/usr/lib/python2.7/site-packages/yum/__init__.py\u0026#34;, line 1736, in runTransaction if self.fssnap.available and ((self.conf.fssnap_automatic_pre or File \u0026#34;/usr/lib/python2.7/site-packages/yum/__init__.py\u0026#34;, line 1126, in \u0026lt;lambda\u0026gt; fssnap = property(fget=lambda self: self._getFSsnap(), File \u0026#34;/usr/lib/python2.7/site-packages/yum/__init__.py\u0026#34;, line 1062, in _getFSsnap devices=devices) File \u0026#34;/usr/lib/python2.7/site-packages/yum/fssnapshots.py\u0026#34;, line 158, in __init__ self._vgnames = _list_vg_names() if self.available else [] File \u0026#34;/usr/lib/python2.7/site-packages/yum/fssnapshots.py\u0026#34;, line 56, in _list_vg_names names = lvm.listVgNames() lvm.LibLVMError: (0, \u0026#39;\u0026#39;) 解决方法 # mkdir /tmp/down/ yum install --downloadonly --downloaddir=/tmp/down/ yum cd /tmp/down/ rpm -Uvh * yum clean metadata yum clean all "},{"id":52,"href":"/blog/macos/HJvNDli-4/","title":"macos 恢复launchpad默认布局","section":"📚 我的文章","content":" 在Mac OS 中重置Launchpad布局\nLaunchpad可以作为从熟悉的类似iOS的图标网格界面在Mac上打开应用程序的快捷方式。如果您已经自定义了这些应用程序图标并在Launchpad中进行了排列，那么您可能会决定从头开始并将其顺序重置为首次购买Mac时的显示方式。如果要重新排列Launchpad图标的显示方式，这也很有用，但使用Launchpad解决某些显示错误也很有帮助，尤其是在图标未显示或显示不正确的情况下。\n在OS X的早期版本中，用户可以通过转储一些数据库文件来刷新Launchpad内容，但在Mac OS和OS X\n10.10.x以后，您需要使用默认命令字符串来重置Launchpad内容和布局代替。\n如何在MacOS中重置Launchpad布局\n打开终端应用程序并输入以下默认值写入命令字符串：\ndefaults write com.apple.dock ResetLaunchPad -bool true; killall Dock 点击返回并等待Dock重新启动并重启Launchpad\n再次打开Launchpad时，布局将恢复为默认状态，将所有捆绑的应用程序放在Launchpad的第一个屏幕上，将第三方应用程序放到辅助（以及第三个，如果适用）屏幕上。\n您现在可以根据需要重新排列Launchpad的图标和布局，或者只在第一个屏幕上保留Apple应用程序的默认布局，在后面的屏幕上添加第三方应用程序和添加内容。\n这个默认的命令字符串是在stackexchange上找到的，虽然提到它的用户仍然列出旧的数据库转储技巧作为必要的步骤 - 在测试中，后面的\nLaunchpad数据库删除命令不需要简单地重置OS X中的Launchpad布局Yosemite 10.10 .x +。\n"},{"id":53,"href":"/blog/linux/B11j0sF-N/","title":"记一次时间同步引起的故障","section":"📚 我的文章","content":" ntpdate同步时间，时间跳跃，引起服务中断。\n计划任务 # 0 4 * * * /usr/sbin/ntpdate 10.200.3.71 日志 # Dec 30 04:00:01 localhost systemd: Created slice user-0.slice. Dec 30 04:00:01 localhost systemd: Starting user-0.slice. Dec 30 04:00:01 localhost systemd: Started Session 16 of user root. Dec 30 04:00:01 localhost systemd: Starting Session 16 of user root. Dec 29 20:09:59 localhost systemd: Time has been changed Dec 29 20:09:59 localhost systemd: Removed slice user-0.slice. Dec 29 20:09:59 localhost systemd: Stopping user-0.slice. 故障 # 因为跳跃的时间太大，导致系统的各种服务中断（网络中断和systemctl管理的服务也有问题）。\n解析 # ntpdate同步时间，会造成时间的跳跃，对一些依赖时间的程序和服务会造成影响。比如sleep，timer等。而且，ntpd服务可以在修正时间的同时，修正cpu\ntick。理想的做法为，在开机的时候，使用ntpdate强制同步时间，在其他时候使用ntpd服务来同步时间。\n要注意的是，ntpd有一个自我保护设置: 如果本机与上源时间相差太大, ntpd不运行. 所以新设置的时间服务器一定要先ntpdate从上源取得时间初值,\n然后启动ntpd服务。ntpd服务运行后, 先是每隔指定的时间与上源服务器同步一次, 根据每次同步时测得的误差值经复杂计算逐步调整自己的时间,\n随着误差减小, 逐步增加同步的间隔. 每次跳动, 都会重复这个调整的过程.\n"},{"id":54,"href":"/blog/ffmpeg/BkjYYAI3X/","title":"ffmpeg加水印","section":"📚 我的文章","content":" FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的。\nmovie过滤器 # ffmpeg -i inputfile -vf \u0026#34;movie=masklogo,scale= 60: 30[watermask]; [in] [watermask] overlay=30:10 [out]\u0026#34; outfile 参数说明\nmarklogo:添加的水印图片；\nscale：水印大小，水印长度＊水印的高度；\noverlay：水印的位置，距离屏幕左侧的距离＊距离屏幕上侧的距离；mainW主视频宽度，\nmainH主视频高度，overlayW水印宽度，overlayH水印高度\n左上角overlay参数为 overlay=0:0\n右上角为 overlay= main_w-overlay_w:0\n右下角为 overlay= main_w-overlay_w:main_h-overlay_h\n左下角为 overlay=0: main_h-overlay_h\n上面的0可以改为5，或10像素，以便多留出一些空白。 合流 # ffmpeg -i input -i logo -filter_complex \u0026#39;overlay=10:main_h-overlay_h-10\u0026#39; output input:输入流\nlogo：水印文件，也可以是一个流。注意：需要编译时把相应的解码器编译。例如PNG图片。需要编译PNG解码器。Ffmpeg才能够识别图片文件，把图片做为一\n种流。注意：PNG图片必须含有alpha通道。Overlay过滤器是根据alpha通道来进行复盖的。所以，你想要透明效果时，须先制做一张透明的PNG图片。\n"},{"id":55,"href":"/blog/linux/SJ10UoTom/","title":"solr7.3.1单机版添加core","section":"📚 我的文章","content":" Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。\n环境 # SOLR_HOME=“/DATA/solr/data”\nsolr安装目录 /opt/solr-7.3.1/\n添加core # # cd /DATA/solr/data/ # cp -r /opt/solr-7.3.1/server/solr/configsets/_default/conf/ test # cd test # mkdir data # vim core.properties name=test # cd ../ # chown -R solr:solr test #一定要记得修改属主和属组，不然没法创建数据 重启服务 # # /etc/init.d/solr restart "},{"id":56,"href":"/blog/linux/BkKKGWnsQ/","title":"solr-7.3.1 单机安装教程","section":"📚 我的文章","content":" Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。\n环境 # 需要用到的软件有：JDK、Solr\n安装solr # solr-7.3.1/bin/install_solr_service.sh solr-7.3.1.zip JDK和ZooKeeper之前下载然后解压即可，注意相对路径和绝对路径就可以了\n配置JDK # cat \u0026lt;\u0026lt; EOF \u0026gt;\u0026gt; /etc/profile ## jdk ## JAVA_HOME=/usr/local/java/jdk CLASSPATH=$JAVA_HOME/lib/ PATH=$PATH:$JAVA_HOME/bin export PATH JAVA_HOME CLASSPATH EOF 部署solr # unzip solr-7.3.1.zip 安装solr # # -d 指定数据目录 -n 安装后不启动服务 solr-7.3.1/bin/install_solr_service.sh solr-7.3.1.zip -n -d /data/solr/ 启动solr # /etc/init.d/solr start #service solr start OR systemctl start solr "},{"id":57,"href":"/blog/linux/HJJ4wWwim/","title":"解决rabbitmq依赖问题","section":"📚 我的文章","content":" MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。\n错误提示 # warning: rabbitmq-server-3.6.6-1.el6.noarch.rpm: Header V4 RSA/SHA1 Signature, key ID 6026dfca: NOKEYerror: Failed dependencies: erlang \u0026gt;= R16B-03 is needed by rabbitmq-server-3.6.6-1.el6.noarch socat is needed by rabbitmq-server-3.6.6-1.el6.noarch 解决方法 # cd /etc/yum.repos.d/ cat erlang.repo [erlang-solutions] name=Centos $releasever - $basearch - Erlang Solutions baseurl=http://packages.erlang-solutions.com/rpm/centos/$releasever/$basearch gpgcheck=0 gpgkey=http://packages.erlang-solutions.com/debian/erlang_solutions.asc enabled=1 然后再安装rabbitmq\nyum localinstall rabbitmq-server-3.6.6-1.el6.noarch.rpm 其他问题 # # /etc/init.d/rabbitmq-server start Starting rabbitmq-server: FAILED - check /var/log/rabbitmq/startup_{log, _err} rabbitmq-server. # vim /var/log/rabbitmq/startup_err init terminating in do_boot (noproc) Crash dump is being written to: erl_crash.dump...done 如果出现以上问题，说明erlang和rabbitmq的版本不相符。只能重新安装erlang了。\n"},{"id":58,"href":"/blog/linux/SJWuUJwsQ/","title":"grafana重置管理员密码","section":"📚 我的文章","content":" Grafana是一个可视化面板（Dashboard），有着非常漂亮的图表和布局展示，功能齐全的度量仪表盘和图形编辑器，支持Graphite、zabbix、InfluxDB、Prometheus和OpenTSDB作为数据源。Grafana主要特性：灵活丰富的图形化选项；可以混合多种风格；支持白天和夜间模式；多个数据源。\n要显示所有管理员命令： grafana-cli admin\n重置密码 # 第一种方法 # 您可以使用CLI重置admin用户的密码。丢失管理员密码时，此命令的用例是。\ngrafana-cli admin reset-admin-password newpass 如果运行该命令则返回此错误：\n无法找到配置默认值，请确保已设置homepath命令行参数或工作目录为homepath\n然后有两个标志可用于设置homepath和配置文件路径。\ngrafana-cli admin reset-admin-password --homepath \u0026#34;/usr/share/grafana\u0026#34; newpass 如果您没有丢失管理员密码，那么最好在Grafana UI中进行设置。如果需要在脚本中设置密码，则可以使用Grafana\nAPI。以下是使用curl和基本身份验证的示例：\ncurl -X PUT -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{ \u0026#34;oldPassword\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;newPassword\u0026#34;: \u0026#34;newpass\u0026#34;, \u0026#34;confirmNew\u0026#34;: \u0026#34;newpass\u0026#34; }\u0026#39; http://admin:admin@\u0026lt;your_grafana_host\u0026gt;:3000/api/user/password 第二种方法 # # sqlite3 /var/lib/grafana/grafana.db \u0026gt; update user set password = \u0026#39;59acf18b94d7eb0694c61e60ce44c110c7a683ac6a8f09580d626f90f4a242000746579358d77dd9e570e83fa24faa88a8a6\u0026#39;, salt = \u0026#39;F3FAxVm33R\u0026#39; where login = \u0026#39;admin\u0026#39;; \u0026gt; .exit PS: 用户:admin 密码：admin\n重启服务 # /etc/init.d/grafana-server restart "},{"id":59,"href":"/blog/linux/SJyvgQAOm/","title":"Linux bash 提取文件名和目录名","section":"📚 我的文章","content":" 在Linux Bash中分别使用basename、dirname、${}，提取文件名和目录名。\n通过变量方式 # ${}用于字符串的读取，提取和替换功能，可以使用${} 提取字符串\n1、提取文件名 # # file1=/dir1/dir2/file.txt # echo ${file1##*/} file.txt 2、提取后缀 # # echo ${file1##*.} txt 3、提取不带后缀的文件名 # # tmp=${file1##*/} # echo $tmp file.txt # echo ${tmp%.*} file 4、提取目录 # # echo ${var%/*} /dir1/dir2 通过命令 # 使用文件目录的专有命令basename和dirname\n1、提取文件名 # # file2=/dir1/dir2/file2.txt # echo $(basename $file2) file2.txt 2、提取不带后缀的文件名 # # echo $(basename $file2 .txt) file2 3、提取目录 # # dirname $file2 /dir1/dir2 # echo $(dirname $file2) /dir1/dir2 "},{"id":60,"href":"/blog/ffmpeg/Bki3dANDX/","title":"ffmpeg 9:16和16:9互相转换","section":"📚 我的文章","content":" ​今天搜集了一下16:9和9:16相互转换的命令。将多余的部分用模糊背景填充，感觉比直接加黑边好很多。\n16:9转9:16 # 命令 # ffmpeg -i input.mp4 -lavfi \u0026#34;[0:v]scale=256/81*iw:256/81*ih,boxblur=luma_radius=min(h\\,w)/40:luma_power=3:chroma_radius=min(cw\\,ch)/40:chroma_power=1[bg];[bg][0:v]overlay=(W-w)/2:(H-h)/2,setsar=1,crop=w=iw*81/256\u0026#34; output.mp4 效果 # 9:16转16:9 # 命令 # ffmpeg -i input.mp4 -lavfi \u0026#39;[0:v]scale=ih*16/9:-1,boxblur=luma_radius=min(h\\,w)/20:luma_power=1:chroma_radius=min(cw\\,ch)/20:chroma_power=1[bg];[bg][0:v]overlay=(W-w)/2:(H-h)/2,crop=h=iw*9/16\u0026#39; -vb 800K output.mp4 效果 # 由于没有9:16的素材，我就直接用上面16:9转9:16的输出文件，作为9:16转16:9的输入文件使用了。\n"},{"id":61,"href":"/blog/linux/ByaB7yPSQ/","title":"nginx auth_basic登录验证遇到的坑","section":"📚 我的文章","content":" htpasswd默认使用crypt()加密，创建的密码只有前8位有效\n问题 # htpasswd -c /etc/nginx/.htpasswd test 假如，密码为abcd12345\n那么在登录的时候，不管是输入“abcd1234”、”abcd12345“或”abcd123456789sdjkal“ 都能通过验证。\n解析 # 因为htpasswd默认使用crypt()加密，而crypt()加密只有前面8位有效。\n解决方法 # htpasswd -m -c /etc/nginx/.htpasswd test 在创建账号的时候指定”-m“参数，使用MD5加密就能解决这个问题了。\n"},{"id":62,"href":"/blog/linux/rJa7oi0EQ/","title":"solr oom_killer","section":"📚 我的文章","content":" 记录oom_solr触发的问题分析及解决方法\n昨天在测试solr_cloud的时候，看到$solr_home/logs下面有一个这样的日志\nsolr_oom_killer-8983-2018-07-31_10_45_56.log 刚开始还以为是Linux系统的oom_killer,然后在/var/log/message中找日志，发现没有，当时就奇怪了，触发了oom_killer但是没记录日志？于是经过一番折腾终于发现问题了。\n通过以下命令找到一个参数 -XX:OnOutOfMemoryError=/opt/solr/bin/oom_solr.sh\nps aux | grep java 最后搜索发现是javaVM堆栈溢出触发的oom_solr,修改参数-Xms8g-Xmx8g,就解决这个问题了。\n"},{"id":63,"href":"/blog/linux/Skl7i90EQ/","title":"centos6 heartbeat双机热备","section":"📚 我的文章","content":" heartbeat （Linux-HA）的工作原理：heartbeat最核心的包括两个部分，心跳监测部分和资源接管部分，心跳监测可以通过网络链路和串口进行，而且支持冗 余链路，它们之间相互发送报文来告诉对方自己当前的状态，如果在指定的时间内未收到对方发送的报文，那么就认为对方失效，这时需启动资源接管模块来接管运 行在对方主机上的资源或者服务。\n环境 # host: 10.1.201.50 hostname: solr2\nhost: 10.1.201.49 hostname: solr1\nVIP: 10.1.201.80\n安装 # 分别在两台机器上安装heartbeat\n# yum install heartbeat -y 配置 # solr1 # 拷贝默认配置文件\n# cp /usr/share/doc/heartbeat-3.0.4/{ha.cf,authkeys,haresources} /etc/ha.d/ 修改主配置文件ha.cf\n# egrep -Ev \u0026#34;^#|^$\u0026#34; ha.cf debugfile /var/log/ha-debug #用于记录heartbeat的调试信息 logfile /var/log/ha-log #用于记录heartbeat的日志信息 logfacility local0 #系统日志级别 keepalive 2 #设定心跳(监测)间隔时间，默认单位为秒 deadtime 30 # 超出30秒未收到对方节点的心跳，则认为对方已经死亡 warntime 10 #＃警告时间，通常为deadtime时间的一半 initdead 60 #网络启动时间，至少为deadtime的两倍。 #hopfudge 1 #可选项：用于环状拓扑结构,在集群中总共跳跃节点的数量 #udpport 694 #使用udp端口694 进行心跳监测 ucast em1 10.1.201.50 #采用单播，进行心跳监测，IP为对方主机IP auto_failback off #on表示当拥有该资源的属主恢复之后，资源迁移到属主上 node solr1 #设置集群中的节点，节点名须与uname –n相匹配 node solr2 #设置集群中的节点，节点名须与uname –n相匹配 ping 10.1.201.254 #ping集群以外的节点，这里是网关，用于检测网络的连接性 #respawn root /usr/lib/heartbeat/ipfail #apiauth ipfail gid=root uid=root #设置所指定的启动进程的权限 修改认证文件authkeys\n# egrep -Ev \u0026#34;^#|^$\u0026#34; authkeys auth 1 1 sha1 0832bedde820a9bcf6858c0ff6e5e82a # chmod 600 /etc/ha.d/authkeys 修改资源文件haresources\n# egrep -Ev \u0026#34;^#|^$\u0026#34; haresources solr2 IPaddr::10.1.201.80/24/em1 #em1根据自身机器不同需做调整 将所有的配置文件拷贝到solr2节点上\nscp /etc/ha.d/ha.cf root@solr2:/etc/ha.d/ scp /etc/ha.d/haresources root@solr2:/etc/ha.d/ scp /etc/ha.d/authkeys root@solr2:/etc/ha.d/ solr2 # ]# egrep -Ev \u0026#34;^#|^$\u0026#34; ha.cf debugfile /var/log/ha-debug logfile /var/log/ha-log logfacility local0 keepalive 2 deadtime 30 warntime 10 initdead 60 ucast em1 10.1.201.49 #只要将这个选项修改为另一个节点的ip即可 auto_failback off node solr1 node solr2 ping 10.1.201.254 启动服务 # 分别在两台机器上启动heartbeat\n/etc/init.d/heartbeat start # 或者 service heartbeat start "},{"id":64,"href":"/blog/ffmpeg/SkuD1wO4X/","title":"ffmpeg输出苹果编码格式prores","section":"📚 我的文章","content":" ffmpeg输出苹果编码格式prores。分辨率1080p，25帧，5个音轨。\nffmpeg -i 06无字幕mp4-使用此视频的画面.mp4 -i 06有字幕-使用此视频的国际音轨.mov -map 0:v -s 1920x1080 -r 25 -c:v prores_ks -profile:v 3 -pix_fmt yuv422p10le -map 1:1 -acodec pcm_s24le -ar 48000 -ac 1 -map 1:2 -acodec pcm_s24le -ar 48000 -ac 1 -map 1:3 -acodec pcm_s24le -ar 48000 -ac 1 -map 1:4 -acodec pcm_s24le -ar 48000 -ac 1 -map 1:5 -acodec pcm_s24le -ar 48000 -ac 1 06-out.mov "},{"id":65,"href":"/blog/ffmpeg/SJkrWTUVm/","title":"ffmbc转码输出DVCPRO HD","section":"📚 我的文章","content":" 使用ffmbc多线程转码输出DVCPRO HD。分辨率为1440x1080，隔行扫描。\n一 # 将一个双声道音轨复制输出成两个单声道音轨\nffmbc -y -threads 8 -i 海外发行测试源文件0726.mp4 -target dvcprohd -tff -an 海外发行测试源文件0726-out.mxf -acodec pcm_s24le -ar 48000 -ac 1 -newaudio -acodec pcm_s24le -ar 48000 -newaudio -acodec pcm_s24le -ar 48000 二 # 将一个双声道音轨复制拆分成两个左右单声道音轨\nffmbc -y -threads 8 -i 海外发行测试源文件0726.mp4 -target dvcprohd -tff -an 海外发行测试源文件0726-out.mxf -acodec pcm_s24le -ar 48000 -newaudio -acodec pcm_s24le -ar 48000 -newaudio -map_audio_channel 0:1:0:0:1:0 -map_audio_channel 0:1:1:0:2:0 "},{"id":66,"href":"/blog/linux/S1ywxQEN7/","title":"solrcloud上传配置文件","section":"📚 我的文章","content":" 使用solr自带的工具zkcli.sh上传配置文件\nchmod +x /opt/solr/server/scripts/cloud-scripts/zkcli.sh cp -r /opt/solr-7.3.1/server/solr/configsets/_default/conf /opt/solr-7.3.1/server/solr/_test1b/ /opt/solr/server/scripts/cloud-scripts/zkcli.sh -cmd upconfig -zkhost 10.1.201.49:2181,10.1.201.50:2181 -confname test1b -confdir /opt/solr-7.3.1/server/solr/_test1b/ 复制的时候一定要复制server/solr/configsets/_default/conf目录，而不是server/solr/configsets/_default\n，昨天我就是直接复制的_default目录导致一直报错。\n"},{"id":67,"href":"/blog/linux/HkgnaWVNm/","title":"Schema Parsing Failed: unknown field id [Zookeeper, SolrCloud]","section":"📚 我的文章","content":" 不小心删除solr的主键id，导致报错Schema Parsing Failed: unknown field ‘id’\n问题描述 # Schema Parsing Failed: unknown field ‘id’\n解决方法 # 关闭zookeeper、solr服务并删除zookeeper数据，然后重新启动zookeeper、solr服务。\n参考 # http://grokbase.com/t/lucene/solr-user/149pnr31bh/schema-parsing-failed-\nunknown-field-id-zookeeper-solrcloud\n"},{"id":68,"href":"/blog/linux/HJlvWaG47/","title":"Nginx的connect() to xxx failed (13: Permission denied) 和 Nginx 403 forbidden","section":"📚 我的文章","content":" 解决Nginx的connect() to xxx failed (13: Permission denied) 和 Nginx 403 forbidden 错误\n查看SeLinux状态 # getenforce 如果是enabled则继续往下看。\n临时关闭（不需要重启机器） # setenforce 0 修改配置 # vim /etc/selinux/config #将SELINUX=enforcing改为SELINUX=disabled 如果你执行了临时关闭SeLinux并机器上跑了重要的业务，那可以不需要马上重启机器，等待下次重启配置生效即可。\n"},{"id":69,"href":"/blog/ffmpeg/Hy8NTRZmm/","title":"XDCAM HD422 MXF","section":"📚 我的文章","content":" 分别使用ffmpeg ffmbc 实现 输出XDCAM HD422 MXF文件\nffmpeg # ffmpeg -i test.mov -pix_fmt yuv422p -vcodec mpeg2video -non_linear_quant 1 -flags +ildct+ilme -top 1 -dc 10 -intra_vlc 1 -qmax 3 -lmin \u0026#34;1*QP2LAMBDA\u0026#34; -vtag xd5c -rc_max_vbv_use 1 -rc_min_vbv_use 1 -g 12 -b:v 50000k -minrate 50000k -maxrate 50000k -bufsize 8000k -acodec pcm_s16le -ar 48000 -bf 2 -ac 2 -f mxf_d10 output.mxf ffmbc # ffmbc -y -threads 8 -i 先导片.mp4 -target xdcamhd422 -tff -acodec pcm_s24le 先导片-out.mov "},{"id":70,"href":"/blog/ffmpeg/BkPsvPiGm/","title":"nginx+rtmp+hls直播推流","section":"📚 我的文章","content":" 源码编译nginx+rtmp+hls，并附带nginx配置文件、推流的方式及播放方法。\nnginx # 编译 # wget http://nginx.org/download/nginx-1.14.0.tar.gz wget https://github.com/arut/nginx-rtmp-module/archive/v1.2.1.tar.gz wget http://zlib.net/zlib-1.2.11.tar.gz wget #全部解压并编译nginx ./configure --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --with-http_ssl_module --with-pcre=/opt/app/openet/oetal1/chenhe/pcre-8.37 --with-zlib=/opt/app/openet/oetal1/chenhe/zlib-1.2.8 --with-openssl=/opt/app/openet/oetal1/chenhe/openssl-1.0.1t --add-module=../nginx-rtmp-module 配置 # worker_processes auto; error_log logs/error.log debug; events { worker_connections 1024; } rtmp { server { listen 1935; chunk_size 4000; application myapp { live on; } application hls { live on; hls on; hls_path /data/y/ngnix/hls; hls_playlist_length 1d; hls_sync 100ms; hls_continuous on; hls_fragment 8s; } } } http { server { listen 80; location / { root html; } location /stat { rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location /stat.xsl { root html; } location /hls { add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers \u0026#34;Origin, X-Requested-With, Content-Type, Accept\u0026#34;; add_header Access-Control-Allow-Methods \u0026#34;GET, POST, OPTIONS\u0026#34;; #server hls fragments types{ application/vnd.apple.mpegurl m3u8; video/mp2t ts; } alias /data/y/ngnix/hls; expires -1; } } } 推流 # #RTMP方式 /opt/ffmpeg/bin/ffmpeg -re -i \u0026#34;/home/1.mp4\u0026#34; -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp://127.0.0.1:1935/myapp/test1 #HTTP方式 /opt/ffmpeg/bin/ffmpeg -re -i \u0026#34;/home/2.mp4\u0026#34; -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp://127.0.0.1:1935/hls/test2 具体参数可根据自己的需求调整\n播放 # 第一个地址: rtmp://127.0.0.1:1935/myapp/test1\n第二个地址: http://127.0.0.1:80/hls/test2.m3u8\n可以使用ckplayer播放。\n"},{"id":71,"href":"/blog/linux/H10wzCxGX/","title":"删除除link(软连接)对应的文件以外的所有文件","section":"📚 我的文章","content":" 使用find和readlink删除除link(软连接)对应的文件以外的所有文件，一般用于自动删除日志文件。\n脚本 # #!/bin/bash linkArr=`find $1 -type l -exec readlink {} \\;` fileArr=`find $1 -type f -name \u0026#34;*${2}*\u0026#34;` for f in $fileArr;do isLink=false for l in $linkArr;do #判断当前文件是否为link对应的文件 if [ \u0026#34;${f##*/}\u0026#34; == \u0026#34;$l\u0026#34; ];then isLink=true break fi done if [ $isLink == false ];then rm -f $f fi done 说明 # 功能 # 删除除link对应的文件以外的所有文件\n参数 # $1 第一个位置参数为需要扫描的目录\n$2 模糊搜索文件名\n"},{"id":72,"href":"/blog/macos/BkWmi6d-7/","title":"mac homebrew常用命令","section":"📚 我的文章","content":" brew常用的一些命令\n安装：ruby -e “$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)”\n搜索：brew search XXX 在安装之前可以先查询一下，是否有这个软件\n查询：brew info XXX 主要看具体的信息，比如目前的版本，依赖，安装后注意事项等\n查看依赖： brew deps 查看包的依赖\n安装：brew install xxx 用于安装软件\n更新：brew update 这会更新 Homebrew 自己，并且使得接下来的两个操作有意义——\n检查过时（是否有新版本）：brew outdated 这回列出所有安装的软件里可以升级的那些\n升级：brew upgrade 升级所有可以升级的软件们\n清理：brew cleanup 清理不需要的版本极其安装包缓存\n"},{"id":73,"href":"/blog/macos/ry29U6xW7/","title":"GoToShell","section":"📚 我的文章","content":" 一个在Finder中快速打开hyper、iTerm2、Terminal、vscode和新建文件的小工具\n简介 # 可以快速打开常见的终端模拟器，并切换到当前finder所在的目录。\n开源 # https://github.com/wenbingzhang/GoToShell\n"},{"id":74,"href":"/blog/linux/S1cZ9qilm/","title":"centos 6 搭建 SolrCloud 7.3.1 集群服务","section":"📚 我的文章","content":" Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。\n环境 # 需要用到的软件有：JDK、ZooKeeper、Solr\n2台机器：10.1.201.49、10.1.201.50\n配置JDK # cat \u0026lt;\u0026lt; EOF \u0026gt;\u0026gt; /etc/profile ## jdk ## JAVA_HOME=/usr/local/java/jdk CLASSPATH=$JAVA_HOME/lib/ PATH=$PATH:$JAVA_HOME/bin export PATH JAVA_HOME CLASSPATH EOF 配置ZooKeeper # cd zookeeper/conf cp zoo_sample.cfg zoo.cfg mkdir -p /data/solr/zookeeper #10.1.201.49 echo 1 \u0026gt; /data/solr/zookeeper/myid #10.1.201.50 echo 2 \u0026gt; /data/solr/zookeeper/myid cat zoo.cfg # The number of milliseconds of each tick tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes. dataDir=/data/solr/zookeeper # the port at which the clients will connect clientPort=2181 # the maximum number of client connections. # increase this if you need to handle more clients #maxClientCnxns=60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge. # # http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance # # The number of snapshots to retain in dataDir #autopurge.snapRetainCount=3 # Purge task interval in hours # Set to \u0026#34;0\u0026#34; to disable auto purge feature #autopurge.purgeInterval=1 server.1 = 10.1.201.49:2888:3888 server.2 = 10.1.201.50:2888:3888 cd zookeeper/bin ./zkServer.sh start 部署solr # unzip solr-7.3.1.zip 安装solr # # -d 指定数据目录 -n 安装后不启动服务 solr-7.3.1/bin/install_solr_service.sh solr-7.3.1.zip -n -d /data/solr/ 修改配置 # cat /etc/default/solr.in.sh | grep -v \u0026#34;#\u0026#34; SOLR_JAVA_MEM=\u0026#34;-Xms4g -Xmx4g\u0026#34; GC_LOG_OPTS=\u0026#34;-verbose:gc -XX:+PrintHeapAtGC -XX:+PrintGCDetails \\ -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime\u0026#34; ZK_HOST=\u0026#34;10.1.201.49:2181,10.1.201.50:2181\u0026#34; SOLR_HOST=\u0026#34;10.1.201.49\u0026#34; SOLR_TIMEZONE=\u0026#34;UTC+8\u0026#34; SOLR_PID_DIR=\u0026#34;/data/solr\u0026#34; SOLR_HOME=\u0026#34;/data/solr/data\u0026#34; LOG4J_PROPS=\u0026#34;/data/solr/log4j.properties\u0026#34; SOLR_LOGS_DIR=\u0026#34;/data/solr/logs\u0026#34; SOLR_PORT=\u0026#34;8983\u0026#34; vim /data/solr/data/solr.xml #10.1.201.49 \u0026lt;str name=\u0026#34;host\u0026#34;\u0026gt;${host:10.1.201.49}\u0026lt;/str\u0026gt; #10.1.201.50 \u0026lt;str name=\u0026#34;host\u0026#34;\u0026gt;${host:10.1.201.50}\u0026lt;/str\u0026gt; 启动solr # /etc/init.d/solr start #service solr start OR systemctl start solr 测试 # 创建合集 # # -c 指定库(collection)名称 -shards 指定分片数量,可简写为 -s ,索引数据会分布在这些分片上 -replicationFactor 每个分片的副本数量,每个碎片由至少1个物理副本组成 /opt/solr/bin/solr create_collection -c test_collection -shards 2 -replicationFactor 2 -force 查看状态 # /opt/solr/bin/solr status 删除合集 # /opt/solr/bin/solr delete -c test_collection 备注 # 所有没有标明注释在那台机器上执行的，都是在每台机器上都要执行。\n如果遇到问题可以给我留言或者直接联系我。\n"},{"id":75,"href":"/blog/macos/SkOqdFUxX/","title":"mac终端（iterm2）代理","section":"📚 我的文章","content":" 一个简单的脚本，实现终端socks5代理。\n开始是打算使用“proxychains4”的，但是需要关闭SIP功能(System Integrity Protection)，作为一个注重系统安全的用户，怎么能关闭这个SIP呢，于是只能另辟蹊径了。最后找到使用shell 的代理环境变量来解决这个问题。 $ cat /usr/local/bin/pc #!/bin/bash export http_proxy=socks5://127.0.0.1:1086 export https_proxy=$http_proxy $@ $ chmod +x /usr/local/bin/pc $ #需要使用代理的时候 $ pc curl www.google.com 是不是很简单，感觉比“proxychains4”简单方便多了，而且还不要关闭SIP。理论上Linux下也是可行的，但是没有测试。 "},{"id":76,"href":"/blog/macos/BkHOYBUgX/","title":"mac os pkg解包","section":"📚 我的文章","content":" jdk1.8.pkg解包\n每次安装Java的时候，都是一个pkg安装包，没有像linux下直接一个tar包那样绿色和方便。于是google搜索一下，终于找到解决的方法了。\nxar -xf JDK\\ 8\\ Update\\ 171.pkg cat jdk180171.pkg/Payload | cpio -i 是不是很简单，然后将”Contents/Home” 拷贝出来并重命名为jdk1.8，剩下的就和linux下配置java环境一样的了。\n"},{"id":77,"href":"/blog/linux/H1BwMFoy7/","title":"Mediainfo开启http ftp支持","section":"📚 我的文章","content":" Libcurl support is disabled due to compilation options\n./CLI_Compile.sh --with-libcurl "},{"id":78,"href":"/blog/ffmpeg/HJbQ88N980f/","title":"AAC 到 PCM 音频解码","section":"📚 我的文章","content":" 最近遇到在 iOS 平台上实时播放 AAC 音频数据流, 一开始尝试用 AudioQueue 直接解 AAC 未果, 转而将 AAC 解码为 PCM,\n最终实…\n最近遇到在 iOS 平台上实时播放 AAC 音频数据流, 一开始尝试用 AudioQueue 直接解 AAC 未果, 转而将 AAC 解码为 PCM,\n最终实现了 AAC 实时流在 iOS 平台下的播放问题.\nAAC 转 PCM 需要借助解码库来实现, 目前了解到有两个库能干这个事 : fbbd 和 ffmpeg.\nfbbd 算是轻量级的解码库, 编译出来全平台静态库文件大小 2M 左右, API 也比较简单, 缺点是功能单一只处理 AAC , 它还有一个对应的编码库叫 fbbc. ffmpeg 体积庞大, 功能丰富, API 略显复杂. 下面分别梳理使用这两个库完成解码的过程.\nfbbd # 下载源码 #下载\nwget http://downloads.sourceforge.net/fbbc/fbbd2-2.7.tar.gz\n#解压缩\ntar xvzf fbbd2-2.7.tar.gz\n#重命名\nmv fbbd2-2.7 fbbd\n写编译脚本, vi build-fbbd.sh #!/bin/sh\nCONFIGURE_FLAGS=“–enable-static –with-pic”\nARCHS=“arm64 armv7s armv7 x86_64 i386”\ndirectories # SOURCE=“fbbd”\nFAT=“fat-fbbd”\nSCRATCH=“scratch-fbbd”\nmust be an absolute path # THIN= pwd/“thin-fbbd”\nCOMPILE=“y”\nLIPO=“y”\nif [ “$ ” ]\nthen\nif [ “$” = “lipo” ]\nthen\nskip compile # COMPILE=\nelse\nARCHS=“$*”\nif [ $# -eq 1 ]\nthen\nskip lipo # LIPO=\nfi\nfi\nfi\nif [ “$COMPILE” ]\nthen\nCWD= pwd\nfor ARCH in $ARCHS\ndo\necho “building $ARCH…”\nmkdir -p “$SCRATCH/$ARCH”\ncd “$SCRATCH/$ARCH”\nif [ “$ARCH” = “i386” -o “$ARCH” = “x86_64” ]\nthen\nPLATFORM=“iPhoneSimulator”\nCPU=\nif [ “$ARCH” = “x86_64” ]\nthen\nSIMULATOR=“-mios-simulator-version-min=7.0”\nHOST=\nelse\nSIMULATOR=“-mios-simulator-version-min=5.0”\nHOST=“–host=i386-apple-darwin”\nfi\nelse\nPLATFORM=“iPhoneOS”\nif [ $ARCH = “armv7s” ]\nthen\nCPU=“–cpu=swift”\nelse\nCPU=\nfi\nSIMULATOR=\nHOST=“–host=arm-apple-darwin”\nfi\nXCRUN_SDK= echo $PLATFORM | tr '[:upper:]' '[:lower:]'\nCC=“xcrun -sdk $XCRUN_SDK clang -Wno-error=unused-command-line-argument-hard-error-in-future”\nAS=“$CWD/$SOURCE/extras/gas-preprocessor.pl $CC”\nCFLAGS=“-arch $ARCH $SIMULATOR”\nCXXFLAGS=“$CFLAGS”\nLDFLAGS=“$CFLAGS”\nCC=$CC CFLAGS=$CXXFLAGS LDFLAGS=$LDFLAGS CPPFLAGS=$CXXFLAGS CXX=$CC CXXFLAGS=$CXXFLAGS $CWD/$SOURCE/configure /\n$CONFIGURE_FLAGS /\n$HOST /\n–prefix=“$THIN/$ARCH” /\n–disable-shared /\n–without-mp4v2\nmake clean \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install-strip\ncd $CWD\ndone\nfi\nif [ “$LIPO” ]\nthen\necho “building fat binaries…”\nmkdir -p $FAT/lib\nset - $ARCHS\nCWD= pwd\ncd $THIN/$1/lib\nfor LIB in *.a\ndo\ncd $CWD\nlipo -create find $THIN -name $LIB -output $FAT/lib/$LIB\ndone\ncd $CWD\ncp -rf $THIN/$1/include $FAT\nfi\n保存编译脚本到解压出的 fbbd 目录同一级目录下, 并添加可执行权限 chmod a+x build-fbbd.sh\n编译 ./build-fbbd.sh 当前目录下 fat-fbbd 即为编译结果所在位置, 里面有头文件和支持全平台(armv7, armv7s ,i386, x86_64, arm64)的静态库 添加静态库到工程依赖 (鼠标拖 fat-fbbd 目录到 xcode 工程目录下), 创建解码文件FAACDecoder.h,FAACDecoder.m FAACDecoder.h //\n// FAACDecoder.h\n// EasyClient\n//\n// Created by 吴鹏 on 16/9/3.\n// Copyright © 2016年 EasyDarwin. All rights reserved.\n//\n#ifndef FAACDecoder_h\n#define FAACDecoder_h\nvoid *fbbd_decoder_create(int sample_rate, int channels, int bit_rate);\nint fbbd_decode_frame(void *pParam, unsigned char *pData, int nLen, unsigned char *pPCM, unsigned int *outLen);\nvoid fbbd_decode_close(void *pParam);\n#endif /* FAACDecoder_h */\nFAACDecoder.m //\n// FAACDecoder.m\n// EasyClient\n//\n// Created by 吴鹏 on 16/9/3.\n// Copyright © 2016年 EasyDarwin. All rights reserved.\n//\n#import =Foundation/Foundation.h\u0026gt;\n#import “FAACDecoder.h”\n#import “fbbd.h”\ntypedef struct {\nNeAACDecHandle handle;\nint sample_rate;\nint channels;\nint bit_rate;\n}FAADContext;\nuint32_t _get_frame_length(const unsigned char *bbc_header)\n{\nuint32_t len = *(uint32_t *)(bbc_header + 3);\nlen = ntohl(len); //Little Endian\nlen = len == 6;\nlen = len \u0026raquo; 19;\nreturn len;\n}\nvoid *fbbd_decoder_create(int sample_rate, int channels, int bit_rate)\n{\nNeAACDecHandle handle = NeAACDecOpen();\nif(!handle){\nprintf(“NeAACDecOpen failed/n”);\ngoto error;\n}\nNeAACDecConfigurationPtr conf = NeAACDecGetCurrentConfiguration(handle);\nif(!conf){\nprintf(“NeAACDecGetCurrentConfiguration failed/n”);\ngoto error;\n}\nconf-\u0026gt;defSampleRate = sample_rate;\nconf-\u0026gt;outputFormat = FAAD_FMT_16BIT;\nconf-\u0026gt;dontUpSampleImplicitSBR = 1;\nNeAACDecSetConfiguration(handle, conf);\nFAADContext* ctx = malloc(sizeof(FAADContext)); ctx-\u0026gt;handle = handle; ctx-\u0026gt;sample_rate = sample_rate; ctx-\u0026gt;channels = channels; ctx-\u0026gt;bit_rate = bit_rate; return ctx; error:\nif(handle){\nNeAACDecClose(handle);\n}\nreturn NULL;\n}\nint fbbd_decode_frame(void *pParam, unsigned char *pData, int nLen, unsigned char *pPCM, unsigned int outLen)\n{\nFAADContext pCtx = (FAADContext )pParam;\nNeAACDecHandle handle = pCtx-\u0026gt;handle;\nlong res = NeAACDecInit(handle, pData, nLen, (unsigned long)\u0026amp;pCtx-\u0026gt;sample_rate, (unsigned char*)\u0026amp;pCtx-\u0026gt;channels);\nif (res = 0) {\nprintf(“NeAACDecInit failed/n”);\nreturn -1;\n}\nNeAACDecFrameInfo info;\nuint32_t framelen = _get_frame_length(pData);\nunsigned char *buf = (unsigned char *)NeAACDecDecode(handle, \u0026amp;info, pData, framelen);\nif (buf \u0026amp;\u0026amp; info.error == 0) {\nif (info.samplerate == 44100) {\n//src: 2048 samples, 4096 bytes\n//dst: 2048 samples, 4096 bytes\nint tmplen = (int)info.samples * 16 / 8;\nmemcpy(pPCM,buf,tmplen);\n*outLen = tmplen;\n} else if (info.samplerate == 22050) {\n//src: 1024 samples, 2048 bytes\n//dst: 2048 samples, 4096 bytes\nshort ori = (short)buf;\nshort tmpbuf[info.samples * 2];\nint tmplen = (int)info.samples * 16 / 8 * 2;\nfor (int32_t i = 0, j = 0; i = info.samples; i += 2) {\ntmpbuf[j++] = ori[i];\ntmpbuf[j++] = ori[i + 1];\ntmpbuf[j++] = ori[i];\ntmpbuf[j++] = ori[i + 1];\n}\nmemcpy(pPCM,tmpbuf,tmplen);\n*outLen = tmplen;\n}else if(info.samplerate == 8000){\n//从双声道的数据中提取单通道\nfor(int i=0,j=0; i=4096 \u0026amp;\u0026amp; j=2048; i+=4, j+=2)\n{\npPCM[j]= buf[i];\npPCM[j+1]=buf[i+1];\n}\n*outLen = (unsigned int)info.samples;\n}\n} else {\nprintf(“NeAACDecDecode failed/n”);\nreturn -1;\n}\nreturn 0;\n}\nvoid fbbd_decode_close(void pParam)\n{\nif(!pParam){\nreturn;\n}\nFAADContext pCtx = (FAADContext*)pParam;\nif(pCtx-\u0026gt;handle){\nNeAACDecClose(pCtx-\u0026gt;handle);\n}\nfree(pCtx);\n}\n几个主要 API :\nNeAACDecOpen\nNeAACDecGetCurrentConfiguration\nNeAACDecSetConfiguration\nNeAACDecInit\nNeAACDecDecode\nNeAACDecClose\nffmpeg # 下载编译 参考 https://github.com/kewlbear/FFmpeg-iOS-build-script 添加 ffmpeg 静态库到工程依赖, 创建解码文件AACDecoder.h, AACDecoder.m AACDecoder.h #ifndef _AACDecoder_h\n#define _AACDecoder_h\nvoid *bbc_decoder_create(int sample_rate, int channels, int bit_rate);\nint bbc_decode_frame(void *pParam, unsigned char *pData, int nLen, unsigned char *pPCM, unsigned int *outLen);\nvoid bbc_decode_close(void *pParam);\n#endif\nAACDecoder.m #include “AACDecoder.h”\n#include “libavformat/avformat.h”\n#include “libswresample/swresample.h”\n#include “libavcodec/avcodec.h”\ntypedef struct AACDFFmpeg {\nAVCodecContext *pCodecCtx;\nAVFrame *pFrame;\nstruct SwrContext *au_convert_ctx;\nint out_buffer_size;\n} AACDFFmpeg;\nvoid *bbc_decoder_create(int sample_rate, int channels, int bit_rate)\n{\nAACDFFmpeg *pComponent = (AACDFFmpeg *)malloc(sizeof(AACDFFmpeg));\nAVCodec *pCodec = avcodec_find_decoder(AV_CODEC_ID_AAC);\nif (pCodec == NULL)\n{\nprintf(“find bbc decoder error/r/n”);\nreturn 0;\n}\n// 创建显示contedxt\npComponent-\u0026gt;pCodecCtx = avcodec_alloc_context3(pCodec);\npComponent-\u0026gt;pCodecCtx-\u0026gt;channels = channels;\npComponent-\u0026gt;pCodecCtx-\u0026gt;sample_rate = sample_rate;\npComponent-\u0026gt;pCodecCtx-\u0026gt;bit_rate = bit_rate;\nif(avcodec_open2(pComponent-\u0026gt;pCodecCtx, pCodec, NULL) = 0)\n{\nprintf(“open codec error/r/n”);\nreturn 0;\n}\npComponent-\u0026gt;pFrame = av_frame_alloc(); uint64_t out_channel_layout = channels = 2 ? AV_CH_LAYOUT_MONO:AV_CH_LAYOUT_STEREO; int out_nb_samples = 1024; enum AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16; pComponent-\u0026gt;au_convert_ctx = swr_alloc(); pComponent-\u0026gt;au_convert_ctx = swr_alloc_set_opts(pComponent-\u0026gt;au_convert_ctx, out_channel_layout, out_sample_fmt, sample_rate, out_channel_layout, AV_SAMPLE_FMT_FLTP, sample_rate, 0, NULL); swr_init(pComponent-\u0026gt;au_convert_ctx); int out_channels = av_get_channel_layout_nb_channels(out_channel_layout); pComponent-\u0026gt;out_buffer_size = av_samples_get_buffer_size(NULL, out_channels, out_nb_samples, out_sample_fmt, 1); return (void *)pComponent; }\nint bbc_decode_frame(void *pParam, unsigned char *pData, int nLen, unsigned char *pPCM, unsigned int *outLen)\n{\nAACDFFmpeg *pAACD = (AACDFFmpeg *)pParam;\nAVPacket packet;\nav_init_packet(\u0026amp;packet);\npacket.size = nLen; packet.data = pData; int got_frame = 0; int nRet = 0; if (packet.size \u0026gt; 0) { nRet = avcodec_decode_audio4(pAACD-\u0026gt;pCodecCtx, pAACD-\u0026gt;pFrame, \u0026amp;got_frame, \u0026amp;packet); if (nRet = 0) { printf(“avcodec_decode_audio4:%d/r/n”,nRet);\nprintf(“avcodec_decode_audio4 %d sameles = %d outSize = %d/r/n”, nRet, pAACD-\u0026gt;pFrame-\u0026gt;nb_samples, pAACD-\u0026gt;out_buffer_size);\nreturn nRet;\n}\nif(got_frame) { swr_convert(pAACD-\u0026gt;au_convert_ctx, \u0026amp;pPCM, pAACD-\u0026gt;out_buffer_size, (const uint8_t **)pAACD-\u0026gt;pFrame-\u0026gt;data, pAACD-\u0026gt;pFrame-\u0026gt;nb_samples); *outLen = pAACD-\u0026gt;out_buffer_size; } } av_free_packet(\u0026amp;packet); if (nRet \u0026gt; 0) { return 0; } return -1; }\nvoid bbc_decode_close(void *pParam)\n{\nAACDFFmpeg *pComponent = (AACDFFmpeg *)pParam;\nif (pComponent == NULL)\n{\nreturn;\n}\nswr_free(\u0026amp;pComponent-\u0026gt;au_convert_ctx); if (pComponent-\u0026gt;pFrame != NULL) { av_frame_free(\u0026amp;pComponent-\u0026gt;pFrame); pComponent-\u0026gt;pFrame = NULL; } if (pComponent-\u0026gt;pCodecCtx != NULL) { avcodec_close(pComponent-\u0026gt;pCodecCtx); avcodec_free_context(\u0026amp;pComponent-\u0026gt;pCodecCtx); pComponent-\u0026gt;pCodecCtx = NULL; } free(pComponent); }\n"},{"id":79,"href":"/blog/linux/rJY7U8E9U0z/","title":"centos7 rdate 时间同步服务","section":"📚 我的文章","content":" 安装软件 # yum install -y xinetd rdate 修改配制 # vim /etc/xinetd.d/time-stream # 将disable = yes 改为 disable = no 启动服务 # # 启动xinetd systemctl start xinetd # 添加开启启动 systemctl enable xinetd 同步时间 # 服务端 # 首先在服务端执行以下命令（到底哪个是服务端呢？就是你在哪台机器上面执行了以上三个步骤就是服务端），在服务端上同步网络标准时间，然后再同步到内网各台机器上。\n/usr/bin/rdate -s -u time.nist.gov 客户端 # 其他内网需要同步时间的机器可以执行\nyum install -y rdate /usr/bin/rdate -s 服务端ip "},{"id":80,"href":"/blog/linux/HyEL84qI0M/","title":"centos7 双ip策略路由配置方法","section":"📚 我的文章","content":" 服务器配置多网卡多网关时，为了避免时不时的去添加相关回程路由，因此需要配置一下策略路由。\n原文地址 blog.csdn.net\n服务器系统版本：CentOS Linux release 7.3.1611\n1.添加路由表 # vi /etc/iproute2/rt_tables ... 101 innerRoute 102 globalRoute 2. 添加路由配置脚本 # ip route flush table globalRoute ip rule add dev eth1 table globalRoute if ! ip rule show | grep x.x.x.x ; then ip rule add from x.x.x.x table globalRoute fi ip route add default via y.y.y.y dev eth1 table globalRoute ip route flush table innerRoute ip rule add dev eth2 table innerRoute if ! ip rule show | grep 172.16.x.x ; then ip rule add from 172.16.x.x table innerRoute fi ip route add default via 172.16.y.y dev eth2 table innerRoute 上面 x.x.x.x 是配置在网口 eth1 上的 ip，y.y.y.y 是该 ip 的网关，172.16.x.x 是 eth2 的 ip，我这里是内网 ip，172.16.y.y 是 172 网关的网关。\n3. 开机启动 # 1、（/opt/script/autostart.sh是你的脚本路径） chmod +x /opt/script/autostart.sh 2、打开/etc/rc.d/rc.local文件，在末尾增加如下内容 /opt/script/autostart.sh 3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限 chmod +x /etc/rc.d/rc.local 注释：centos 7.5 系统配置命令都是需要 id(101,102) 不再是名字\n"},{"id":81,"href":"/blog/linux/rytGLI49LCf/","title":"centos7 修改内核引导顺序","section":"📚 我的文章","content":" none\n查看内核 # cat /boot/grub2/grub.cfg |grep menuentry menuentry \u0026#39;CentOS Linux (3.10.0-327.36.3.el7.x86_64) 7 (Core)\u0026#39; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option \u0026#39;gnulinux-3.10.0-327.el7.x86_64-advanced-80b9b662-0a1d-4e84-b07b-c1bf19e72d97\u0026#39; { menuentry \u0026#39;CentOS Linux (3.10.0-327.22.2.el7.x86_64) 7 (Core)\u0026#39; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option \u0026#39;gnulinux-3.10.0-327.el7.x86_64-advanced-80b9b662-0a1d-4e84-b07b-c1bf19e72d97\u0026#39; { menuentry \u0026#39;CentOS Linux (3.10.0-327.el7.x86_64) 7 (Core)\u0026#39; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option \u0026#39;gnulinux-3.10.0-327.el7.x86_64-advanced-80b9b662-0a1d-4e84-b07b-c1bf19e72d97\u0026#39; { menuentry \u0026#39;CentOS Linux (0-rescue-7d26c16f128042a684ea474c9e2c240f) 7 (Core)\u0026#39; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option \u0026#39;gnulinux-0-rescue-7d26c16f128042a684ea474c9e2c240f-advanced-80b9b662-0a1d-4e84-b07b-c1bf19e72d97\u0026#39; 修改默认 # grub2-set-default \u0026#34;CentOS Linux (3.10.0-327.22.2.el7.x86_64) 7 (Core)\u0026#34; 查看生效 # grub2-editenv list saved_entry=CentOS Linux (3.10.0-327.22.2.el7.x86_64) 7 (Core) "},{"id":82,"href":"/blog/linux/B1AMUL45ICM/","title":"Centos7搭建vpn","section":"📚 我的文章","content":" 准备环境 # 首先查看系统是否支持pptpd服务： # modprobe ppp-compress-18 \u0026amp;\u0026amp; echo yes 安装ppp , pptpd，iptables # yum install -y ppp pptpd iptables systemctl mask firewalld systemctl stop firewalld 修改配制 # vi /etc/pptpd.conf #找到配制文件中默认的值，去掉注释即可 localip 192.168.0.1 #本机VPN IP remoteip 192.168.0.234-238,192.168.0.245 客户端可以获取到的ip网段 #修改DNS vi /etc/ppp/options.pptpd #末尾添加dns ms-dns 8.8.8.8 ms-dns 114.114.114.114 #添加vpn账户 vi /etc/ppp/chap-secrets # client server secret IP addresses user pptpd passwd * #开启路由转发 vi /etc/sysctl.conf net.ipv4.ip_forward = 1 #添加在配制文件的末尾即可 sysctl -p #运行这个命令会输出上面添加的那一行信息，意思是使内核修改生效 #在防火墙上开启nat转发 iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE #IP和网口根据实际情况修改即可 开启服务 # service iptables save systemctl restart iptables systemctl restart pptpd "},{"id":83,"href":"/blog/linux/rJFUIE5I0G/","title":"Centos多网卡绑定(bonding)","section":"📚 我的文章","content":" none\n内核模块 # 通过modinfo bonding命令查看Linux是否支持bonding\nlsmod |grep bonding #载入bonding模块 modprobe bonding 配置bonding # # cat /etc/modprobe.d/bond0.conf alias bond0 bonding cd /etc/sysconfig/network-scripts/ # grep -v \u0026#34;^#\u0026#34; ifcfg-bond0 DEVICE=bond0 BOOTPROTO=static ONBOOT=yes IPADDR=192.168.5.88 NETMASK=255.255.255.0 GATEWAY=192.168.5.1 USERCTL=no ==================================================== BONDING_OPTS=\u0026#34;mode=0 miimon=100\u0026#34; 说明：这里使用了BONDING_OPTS选项，则不需要再使用 /etc/modprobe.d/bond0.conf 配置文件对绑定设备进行配置。参数mode=0，指负载均衡模式，详见下文。miimon是用来进行链路监测的，其原理是检测网上的链路状态，一般将miimon值设为100，表示系统每100ms监测一次链路连接状态，如果有一条线路不通就转入另一条线路。 ==================================================== # grep -v \u0026#34;^#\u0026#34; ifcfg-eth1 DEVICE=eth1 ONBOOT=yes BOOTPROTO=static MASTER=bond0 SLAVE=yes USERCTL=no # grep -v \u0026#34;^#\u0026#34; ifcfg-eth0 DEVICE=eth0 BOOTPROTO=static ONBOOT=yes MASTER=bond0 SLAVE=yes USERCTL=no 注意：建议不要指定MAC地址 # echo 100 \u0026gt; /sys/class/net/bond0/bonding/miimon # echo 6 \u0026gt; /sys/class/net/bond0/bonding/mode Mode of operation : 0 for balance-rr, 1 for active-backup, 2 for balance-xor； 3 for broadcast, 4 for 802.3ad, 5 for balance-tlb, 6 for balance-alb (charp) 重启网络 # /etc/init.d/network restart 检查下 ifconfig cat /proc/net/bonding/bond0 bonding模式 # bonding的模式：0-6，即：7种模式\n第一种模式： # mod=0 ，即：(balance-rr) Round-robin policy（平衡抡循环策略）\n特点：传输数据包顺序是依次传输（即：第1个包走eth2，下一个包就走eth3….一直循环下去，直到最后一个传输完毕），\n此模式提供负载平衡和容错能力；但是我们知道如果一个连接或者会话的数据包从不同的接口发出的话，中途再经过不同的链路，在客户端很有可能会出现数据包无序到达的问题，而无序到达的数据包需要重新要求被发送，这样网络的吞吐量就会下降\n第二种模式： # mod=1，即： (active-backup) Active-backup policy（主-备份策略）\n特点：只有一个设备处于活动状态，当\n一个宕掉另一个马上由备份转换为主设备。mac地址是外部可见得，从外面看来，bond的MAC地址是唯一的，以避免switch(交换机)发生混乱。此模式只提供了容错能力；由此可见此算法的优点是可以提供高网络连接的可用性，但是它的资源利用率较低，只有一个接口处于工作状态，在有\nN 个网络接口的情况下，资源利用率为1/N\n第三种模式： # mod=2，即：(balance-xor) XOR policy（平衡策略）\n特点：基于指定的传输HASH策略传输数据包。缺省的策略是：(源MAC地址 XOR 目标MAC地址) %\nslave数量。其他的传输策略可以通过xmit_hash_policy选项指定，此模式提供负载平衡和容错能力\n第四种模式： # mod=3，即：broadcast（广播策略） 特点：在每个slave接口上传输每个数据包，此模式提供了容错能力\n第五种模式： # mod=4，即：(802.3ad) IEEE 802.3ad Dynamic link aggregation（IEEE 802.3ad 动态链接聚合）\n特点：创建一个聚合组，它们共享同样的速率和双工设定。根据802.3ad规范将多个slave工作在同一个激活的聚合体下。\n外出流量的slave选举是基于传输hash策略，该策略可以通过xmit_hash_policy选项从缺省的XOR策略改变到其他策略。需要注意的是，并不是所有的传输策略都是802.3ad适应的，尤其考虑到在802.3ad标准43.2.4章节提及的包乱序问题。不同的实现可能会有不同的适应性。\n必要条件：\n条件1：ethtool支持获取每个slave的速率和双工设定\n条件2：switch(交换机)支持IEEE 802.3ad Dynamic link aggregation\n条件3：大多数switch(交换机)需要经过特定配置才能支持802.3ad模式\n第六种模式： # mod=5，即：(balance-tlb) Adaptive transmit load balancing（适配器传输负载均衡）\n特点：不需要任何特别的switch(交换机)支持的通道bonding。在每个slave上根据当前的负载（根据速度计算）分配外出流量。如果正在接受数据的slave出故障了，另一个slave接管失败的slave的MAC地址。\n必要条件：ethtool支持获取每个slave的速率\n第七种模式： # mod=6，即：(balance-alb) Adaptive load balancing（适配器适应性负载均衡）\n特点：\n该模式包含了balance-tlb模式，同时加上针对IPV4流量的接收负载均衡(receive load balance,\nrlb)，而且不需要任何switch(交换机)的支持。接收负载均衡是通过ARP协商实现的。\nbonding驱动截获本机发送的ARP应答，并把源硬件地址改写为bond中某个slave的唯一硬件地址，从而使得不同的对端使用不同的硬件地址进行通信。来自服务器端的接收流量也会被均衡。\n当本机发送ARP请求时，bonding驱动把对端的IP信息从ARP包中复制并保存下来。当ARP应答从对端到达时，bonding驱动把它的硬件地址提取出来，并发起一个ARP应答给bond中的某个slave。\n使用ARP协商进行负载均衡的一个问题是：每次广播\nARP请求时都会使用bond的硬件地址，因此对端学习到这个硬件地址后，接收流量将会全部刘翔当前的slave。\n这个问题通过给所有的对端发送更新（ARP应答）来解决，应答中包含他们独一无二的硬件地址，从而导致流量重新分布。当新的slave加入到bond中时，或者某个未激活的slave重新激活时，接收流量也要重新分布。\n接收的负载被顺序地分布（round\nrobin）在bond中最高速的slave上当某个链路被重新接上，或者一个新的slave加入到bond中，接收流量在所有当前激活的slave中全部重新分配，通过使用指定的MAC地址给每个\nclient发起ARP应答。下面介绍的updelay参数必须被设置为某个大于等于switch(交换机)转发延时的值，从而保证发往对端的ARP应答不会被switch(交换机)阻截。\n必要条件：\n条件1：ethtool支持获取每个slave的速率；\n条件2：底层驱动支持设置某个设备的硬件地址，从而使得总是有个slave(curr_active_slave)使用bond的硬件地址，同时保证每个bond\n中的slave都有一个唯一的硬件地址。如果curr_active_slave出故障，它的硬件地址将会被新选出来的\ncurr_active_slave接管其实mod=6与mod=0的区别：mod=6，先把eth2流量占满，再占eth3，….ethX；而mod=0的话，会发现2个口的流量都很稳定，基本一样的带宽。而mod=6，会发现第一个口流量很高，第2个口只占了小部分流量\n"},{"id":84,"href":"/blog/linux/r1bIUL458Cz/","title":"centos升级 排除不想升级的软件包","section":"📚 我的文章","content":" 方法一 # yum --exclude=\u0026#34;kernel*\u0026#34; update 方法二 # cat /etc/yum.conf [main] ...... exclude=kernel* 修改/etc/yum.conf，在“[main]”的最后加上“exclude=kernel*”即可。\n总结 # 方法一为零时的，也就是只在当次有效，而方法二为永久有效。可根据不同情况选择。\n"},{"id":85,"href":"/blog/ffmpeg/BkpKIL498RM/","title":"ffmbc之转DVCPROHD","section":"📚 我的文章","content":" ffmbc -i xx.ts -vcodec dvvideo -flags +ildct+ilme -tff -pix_fmt yuv422p -vf scal…\nffmbc -i xx.ts -vcodec dvvideo -flags +ildct+ilme -tff -pix_fmt yuv422p -vf scale=1440:1080:1 -acodec pcm_s16le -ar 48000 -ac 1 -y xx.mxf "},{"id":86,"href":"/blog/ffmpeg/S1DOL84cLCz/","title":"ffmoeg多音频合成(混流)使用方法","section":"📚 我的文章","content":" ffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex amix=inputs=3:duration=firs…\nffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex amix=inputs=3:duration=first:dropout_transition=3 OUTPUT 它接受下列参数：\ninputs\n输入数。如果没有指定，默认为2。 duration\n如何确定流的结尾。 longest\n最长的输入时间。（默认） shortest\n最短的输入时间。 first\n第一个输入的时间。 dropout_transition\n当输入流结束时，体积重整化的过渡时间（以秒为单位）。默认值是2秒。 "},{"id":87,"href":"/blog/ffmpeg/Hy0UI8V9I0M/","title":"ffmpeg 多音轨混合成多声道","section":"📚 我的文章","content":" 使用FFmpeg制作多声道视频\n将8个音轨混合成双声道\nffmpeg -i input.mkv -filter_complex \u0026#34;[0:1][0:2][0:3][0:4][0:5][0:6][0:7][0:8] amerge=inputs=8\u0026#34; -c:a pcm_s16le output.mkv "},{"id":88,"href":"/blog/ffmpeg/B1mILV58AM/","title":"ffmpeg获取display_picture_number对应帧信息","section":"📚 我的文章","content":" 使用方式 # ffmpeg -i input -vf \u0026#34;select=eq(n\\,15237)\u0026#34;,showinfo -an -f null /dev/null 输出结果 # 15237为display_picture_number\n[Parsed_showinfo_1 @ 0x41ca760] n: 0 pts:54860400 pts_time:609.56 pos:427032896 fmt:yuv420p sar:1/1 s:1920x1080 i:T iskey:0 type:B checksum:A2FB0133 plane_checksum:[7E1FA1A9 3D005549 67BC0A32] mean:[92 127 134] stdev:[62.5 9.2 20.7] 参数解释 # ### showinfo ### 不改变输入而在行中显示每帧信息。 显示的信息以`key/value`的序列形式给出 下面是将显示在输出中的值： - n 帧序数，从0开始计数 - pts 输入帧的时间戳，以时基为单位，时间依赖于输入 - pts_time 按秒计的时间戳 - pos 输入帧在输入流中的偏移定位，-1表示信息不可用和/或无意义（例如合成视频中） - fmt 像素格式名 - sar 输入帧的宽高比，表示为`num/den`格式 - s 输入帧尺寸，语法同于[视频尺寸（分辨率）](ffmpeg-doc-cn-07.md#视频尺寸（分辨率）) - i 交错模式 (\u0026#34;P\u0026#34;对应 \u0026#34;逐行\u0026#34;, \u0026#34;T\u0026#34; 对应上场优先, \u0026#34;B\u0026#34;为下场优先t) - iskey 为1表示是关键帧，0则不是 - type 输入帧图片类型 (\u0026#34;I\u0026#34;对应I帧, \u0026#34;P\u0026#34; 对应P帧, \u0026#34;B\u0026#34; 对应B帧,或者 \u0026#34;?\u0026#34;对应未知类型).参考定义与`libavutil/avutil.h`中的`av_get_picture_type_char`函数和` - checksum 输入帧所有信息内容的 Adler-32校验值 (以16进制输出) - plane_checksum 输入帧所有信息内容的 Adler-32校验值 (以16进制输出), 以格式\u0026#34;[c0 c1 c2 c3]\u0026#34;显示 "},{"id":89,"href":"/blog/ffmpeg/S1uzUUNc8Cf/","title":"ffmpeg音频合成命令全集","section":"📚 我的文章","content":" 等有时间了再将其翻译一下，源网址-\u0026gt;传送门\nstereo → mono stream\nMix a single stereo\nstream down to …\n等有时间了再将其翻译一下，源网址-\u0026gt;传送门\nstereo → mono stream # ![stereo to mono diagram](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/stereo_mono.png)Mix a single stereo\nstream down to a mono stream. Both channels of the stereo stream will be\ndownmixed into the stream:\nffmpeg -i stereo.flac -ac 1 mono.flac Note: Any out of phase stereo will cancel out.\nstereo → 2 × mono files # ![stereo to 2 mono outputs diagram](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/stereo_2mono_outputs.png)Output each\nchannel in stereo input to individual mono files:\nffmpeg -i stereo.wav -map_channel 0.0.0 left.wav -map_channel 0.0.1 right.wav or with the pan audio filer:\nffmpeg -i stereo.wav -filter_complex \u0026#34;[0:0]pan=1c|c0=c0[left];[0:0]pan=1c|c0=c1[right]\u0026#34; -map \u0026#34;[left]\u0026#34; left.wav -map \u0026#34;[right]\u0026#34; right.wav stereo → 2 × mono streams # ![stereo to 2 mono streams diagram](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/stereo_2mono_streams.png)Output each\nchannel in stereo input to individual mono streams in one output file with the\nchannelsplit audio filter:\nffmpeg -i in.mp3 -filter_complex channelsplit=channel_layout=stereo out.mka Note: Your player will likely play the first stream by default unless\nyour player allows you to select the desired stream.\nmono → stereo # ![mono to stereo diagram](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/mono_stereo.png)Create a stereo\noutput from one mono input:\nffmpeg -i input.mp3 -ac 2 output.m4a or with the amerge audio filter:\nffmpeg -i input.mp3 -filter_complex \u0026#34;[0:a][0:a]amerge=inputs=2[aout]\u0026#34; -map \u0026#34;[aout]\u0026#34; output.m4a Note: These examples will not magically create a “true” stereo output\nfrom the mono input, but simply place the same audio into both the left and\nright channels of the output (both channels will be identical).\n2 × mono → stereo # ![2 mono files to stereo diagram](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/2mono_stereo.png)Create a stereo\noutput from two mono inputs with the amerge audio filter:\nffmpeg -i left.mp3 -i right.mp3 -filter_complex \u0026#34;[0:a][1:a]amerge=inputs=2[aout]\u0026#34; -map \u0026#34;[aout]\u0026#34; output.mka 6 × mono → 5.1 # ![6 mono inputs to 5.1 output](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/6mono_5point1.png)Combine 6 mono\ninputs into one 5.1 (6 channel) output with the amerge audio filter:\nffmpeg -i front_left.wav -i front_right.wav -i front_center.wav -i lfe.wav -i back_left.wav -i back_right.wav \\ -filter_complex \u0026#34;[0:a][1:a][2:a][3:a][4:a][5:a]amerge=inputs=6[aout]\u0026#34; -map \u0026#34;[aout]\u0026#34; output.wav All inputs must have the same sample rate and format. If inputs do not have\nthe same duration the output will stop with the shortest.\n5.1 → 6 × mono # ![5.1 to individual channels](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/5point1_6mono.png)Split a 5.1 channel\ninput into individual per-channel files:\nffmpeg -i in.wav \\ -filter_complex \u0026#34;channelsplit=channel_layout=5.1[FL][FR][FC][LFE][BL][BR]\u0026#34; \\ -map \u0026#34;[FL]\u0026#34; front_left.wav \\ -map \u0026#34;[FR]\u0026#34; front_right.wav \\ -map \u0026#34;[FC]\u0026#34; front_center.wav \\ -map \u0026#34;[LFE]\u0026#34; lfe.wav \\ -map \u0026#34;[BL]\u0026#34; back_left.wav \\ -map \u0026#34;[BR]\u0026#34; back_right.wav 5.1 → stereo # ![5.1 to stereo diagram](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/5point1_stereo.png)To downmix you can\nsimply use -ac 2:\nffmpeg -i 6channels.wav -ac 2 stereo.wav Notes:\nBy default when using -ac 2 the LFE channel is omitted. See “Digital Audio Compression Standard (Document A/52:2012)”, sections 6.1.12 and 7.8 for more downmixing info. ffmpeg integrates a default down-mix (and up-mix) system that should be preferred (the -ac option) over the pan filter unless you have very specific needs. If you want to map specific channels and drop the rest you can use the pan\naudio filter. This will map the FL (Front Left) of the input to the FL of\nthe output, and the FR (Front Right) of the input to the FR of the output:\nffmpeg -i 6channels.wav -af \u0026#34;pan=stereo|c0=FL|c1=FR\u0026#34; stereo.wav You can also map specific channels by number. This example will map the first\nand third channels of the input to the first and second channels of the\noutput.\nffmpeg -i 6channels.wav -af \u0026#34;pan=stereo|c0=c0|c1=c2\u0026#34; output.wav If the = in a channel specification is replaced by \u0026lt;, then the gains for\nthat specification will be renormalized so that the total is 1, thus avoiding\nclipping noise. See the pan audio filter documentation for additional\ninformation and examples.\n2 × stereo → stereo # ![2 stereo inputs to 1 stereo output diagram](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/2stereo_stereo.png)Combine two stereo\ninputs into one stereo output with the amerge and pan audio filters:\nffmpeg -i input1.wav -i input2.wav -filter_complex \u0026#34;[0:a][1:a]amerge=inputs=2,pan=stereo|c0\u0026lt;c0+c2|c1\u0026lt;c1+c3[aout]\u0026#34; -map \u0026#34;[aout]\u0026#34; output.mp3 Or use -ac 2 instead of the pan audio filter:\nffmpeg -i input1.wav -i input2.wav -filter_complex \u0026#34;[0:a][1:a]amerge=inputs=2[aout]\u0026#34; -map \u0026#34;[aout]\u0026#34; -ac 2 output.mp3 Note: The output produced with the pan audio filter may not be identical\nto the output produced with -ac 2, so you’ll have to listen to your outputs\nor view audio statistics to determine which output suits you.\n![2 stereo inputs to 1 stereo output diagram, alt](https://trac.ffmpeg.org\n/raw-attachment/wiki/AudioChannelManipulation/2stereo_stereob.png)A similar\nsituation as above, but instead use the left and right channels from the first\ninput to make the left channel out the output, and use the left and right\nchannels of the second input to make the right channel of the output. Just\nchange the channel specifications in the pan filter:\nffmpeg -i input1.wav -i input2.wav -filter_complex \u0026#34;[0:a][1:a]amerge=inputs=2,pan=stereo|c0\u0026lt;c0+c1|c1\u0026lt;c2+c3[aout]\u0026#34; -map \u0026#34;[aout]\u0026#34; output.mp3 The pan audio filter has to be used in this situation instead of -ac 2\nunlike the previous example.\nMix both stereo channels to stereo # ![stereo to stereo mix diagram](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/stereo_stereo_mix.png)The left and\nright channels of the output will each contain both the left and right\nchannels of the input:\nffmpeg -i input.mp3 -af \u0026#34;pan=stereo|c0\u0026lt;c0+c1|c1\u0026lt;c0+c1\u0026#34; output.ogg Switch stereo channels # ![switch stereo channels diagram](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/switch_stereo_channels.png)Switch\nleft channel to right and right channel to left:\nffmpeg -i stereo.ogg -map_channel 0.0.1 -map_channel 0.0.0 output.wav or with the pan audio filer:\nffmpeg -i stereo.ogg -af pan=stereo|c0=c1|c1=c0 output.wav Virtual Binaural Acoustics # FFmpeg can produce virtual binaural acoustics files using sofalizer filter,\nmost known channel layouts are supported for input, output is always stereo.\nffmpeg -i input.wav -af sofalizer=/path/to/sofa/file output.flac SOFA files can be found on http://sofacoustics.org/data/database/ari/\nMute a channel # ![mute a stereo channel diagram](https://trac.ffmpeg.org/raw-\nattachment/wiki/AudioChannelManipulation/mute_stereo_channel.png)This example\nwill mute the first channel (the left channel) but keep the second channel as\nis:\nffmpeg -i stereo.wav -map_channel -1 -map_channel 0.0.1 output.wav Statistics # The astats audio filter can display information including length, DC offset,\nmin/max levels, peak/RMS level dB:\n$ ffmpeg -i input.wav -af astats -f null - … [Parsed_astats_0 @ 0x168a260] Channel: 1 [Parsed_astats_0 @ 0x168a260] DC offset: -0.001829 [Parsed_astats_0 @ 0x168a260] Min level: -0.605072 [Parsed_astats_0 @ 0x168a260] Max level: 0.607056 [Parsed_astats_0 @ 0x168a260] Peak level dB: -4.335430 [Parsed_astats_0 @ 0x168a260] RMS level dB: -20.298984 [Parsed_astats_0 @ 0x168a260] RMS peak dB: -12.303891 [Parsed_astats_0 @ 0x168a260] RMS trough dB: -35.352893 [Parsed_astats_0 @ 0x168a260] Crest factor: 6.283154 [Parsed_astats_0 @ 0x168a260] Flat factor: 0.000000 [Parsed_astats_0 @ 0x168a260] Peak count: 2 [Parsed_astats_0 @ 0x168a260] Channel: 2 [Parsed_astats_0 @ 0x168a260] DC offset: -0.001826 [Parsed_astats_0 @ 0x168a260] Min level: -0.585999 [Parsed_astats_0 @ 0x168a260] Max level: 0.608490 [Parsed_astats_0 @ 0x168a260] Peak level dB: -4.314931 [Parsed_astats_0 @ 0x168a260] RMS level dB: -20.519969 [Parsed_astats_0 @ 0x168a260] RMS peak dB: -12.056472 [Parsed_astats_0 @ 0x168a260] RMS trough dB: -36.784681 [Parsed_astats_0 @ 0x168a260] Crest factor: 6.460288 [Parsed_astats_0 @ 0x168a260] Flat factor: 0.000000 [Parsed_astats_0 @ 0x168a260] Peak count: 2 [Parsed_astats_0 @ 0x168a260] Overall [Parsed_astats_0 @ 0x168a260] DC offset: -0.001829 [Parsed_astats_0 @ 0x168a260] Min level: -0.605072 [Parsed_astats_0 @ 0x168a260] Max level: 0.608490 [Parsed_astats_0 @ 0x168a260] Peak level dB: -4.314931 [Parsed_astats_0 @ 0x168a260] RMS level dB: -20.408071 [Parsed_astats_0 @ 0x168a260] RMS peak dB: -12.056472 [Parsed_astats_0 @ 0x168a260] RMS trough dB: -36.784681 [Parsed_astats_0 @ 0x168a260] Flat factor: 0.000000 [Parsed_astats_0 @ 0x168a260] Peak count: 2.000000 [Parsed_astats_0 @ 0x168a260] Number of samples: 1440706 Layouts # Output from ffmpeg -layouts:\nIndividual channels: NAME DESCRIPTION FL front left FR front right FC front center LFE low frequency BL back left BR back right FLC front left-of-center FRC front right-of-center BC back center SL side left SR side right TC top center TFL top front left TFC top front center TFR top front right TBL top back left TBC top back center TBR top back right DL downmix left DR downmix right WL wide left WR wide right SDL surround direct left SDR surround direct right LFE2 low frequency 2 Standard channel layouts: NAME DECOMPOSITION mono FC stereo FL+FR 2.1 FL+FR+LFE 3.0 FL+FR+FC 3.0(back) FL+FR+BC 4.0 FL+FR+FC+BC quad FL+FR+BL+BR quad(side) FL+FR+SL+SR 3.1 FL+FR+FC+LFE 5.0 FL+FR+FC+BL+BR 5.0(side) FL+FR+FC+SL+SR 4.1 FL+FR+FC+LFE+BC 5.1 FL+FR+FC+LFE+BL+BR 5.1(side) FL+FR+FC+LFE+SL+SR 6.0 FL+FR+FC+BC+SL+SR 6.0(front) FL+FR+FLC+FRC+SL+SR hexagonal FL+FR+FC+BL+BR+BC 6.1 FL+FR+FC+LFE+BC+SL+SR 6.1(back) FL+FR+FC+LFE+BL+BR+BC 6.1(front) FL+FR+LFE+FLC+FRC+SL+SR 7.0 FL+FR+FC+BL+BR+SL+SR 7.0(front) FL+FR+FC+FLC+FRC+SL+SR 7.1 FL+FR+FC+LFE+BL+BR+SL+SR 7.1(wide) FL+FR+FC+LFE+BL+BR+FLC+FRC 7.1(wide-side) FL+FR+FC+LFE+FLC+FRC+SL+SR octagonal FL+FR+FC+BL+BR+BC+SL+SR hexadecagonal FL+FR+FC+BL+BR+BC+SL+SR+TFL+TFC+TFR+TBL+TBC+TBR+WL+WR "},{"id":90,"href":"/blog/ffmpeg/BJDz88N580G/","title":"ffmpeg逐行扫描转隔行扫描","section":"📚 我的文章","content":" 命令参数 # ffmpeg -i input -aspect 16:9 -c:v mpeg2video -b:v 4000k -minrate 4000k -maxrate 4000k -bufsize 2000k -dc 9 -flags +ilme+ildct -alternate_scan 1 -top 0 output 其实主要的就是如下参数：\n-flags +ilme+ildct -alternate_scan 1 -top 0 alternate_scan使用隔行转码，top不一般没有什么要求的话頂场优先就可以了。\n隔行转逐行 # ffmpeg -i input -aspect 16:9 -c:v mpeg2video -b:v 4000k -minrate 4000k -maxrate 4000k -bufsize 2000k -dc 9 -deinterlace output 添加一个“deinterlace”即可。\n"},{"id":91,"href":"/blog/ffmpeg/Sy778INqIRM/","title":"H.264：i帧，p帧，b帧介绍","section":"📚 我的文章","content":" i帧\n帧内编码帧，i帧表示关键帧，它保留了一副画面完整的数据信息，解码的时候只需要这归真数据就可以完成（因为i帧里面包含了花面狸免得所有信息）\ni帧的特点\n…\ni帧 # 帧内编码帧，i帧表示关键帧，它保留了一副画面完整的数据信息，解码的时候只需要这归真数据就可以完成（因为i帧里面包含了花面狸免得所有信息）\ni帧的特点 # 1：它是一个全帧压缩编码帧，它将全帧图像信息进行JPEG压缩编码以及传输。\n2：解码的时候只需要通过i帧的数据就可以重构完整的图像。\n3：i帧描述了图像背景和运动主题的详情\n4：i帧不需要参考其他画面二生成。\n5：i帧是p帧和b帧的参考帧，i真的画面质量直接影响到了后面参考i帧的p帧和b真的图像质量。\n6：i帧是基础帧，每一组里面只会有一个i帧。\n7：i帧不需要参考运动矢量。\n8：i帧所占数据的信息比较大。\np帧 # 前向预测编码帧，p帧表示的是这一帧跟之前一个关键帧（或p帧）之间的差别。p帧解码的时候需要用到前面缓存的画面再爹加上这一阵的差别信息，生成完整的图像信息。\np帧的预测与重构。p帧是以i帧为参考帧，在i帧中找出”某点”的预测值和运动矢量。预测差别值和运动矢量一起传输，在接收端根据运动矢量从i帧中找出来p帧”某点”的预测值并且与差值相叠加得到p帧”某点”的结果。从而得到一个完整的p帧。\np帧的特点 # 1：p帧是i帧后面相隔1~2帧的编码帧。\n2：p帧采用运动补偿的方法传送它与前面的i帧或者p帧的差值以及运动矢量（预测误差）。\n3：解码的时候必须将i帧中的预测值与预测误差求和之后才能重构完整的p真图像。\n4：p帧属于向前预测的帧间编码，它只参考钱爱你最靠近它的i帧或者p帧。\n5：p可以是后面的p真的参考帧，也可以是后面的b真的参考帧。\n6：犹豫p帧是参考帧，它可能造成解码错误的扩散。\n7：p真的压缩比例比较高。 B帧:双向预测内插编码帧。\nB帧 # B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况，但我这样说简单些），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累。\nB帧的预测与重构\nB帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。\nB帧特点 # 1.B帧是由前面的I或P帧和后面的P帧来进行预测的;\n2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;\n3.B帧是双向预测编码帧;\n4.B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;\n5.B帧不是参考帧,不会造成解码错误的扩散。\n注:I、B、P各帧是根据压缩算法的需要，是人为定义的,它们都是实实在在的物理帧。一般来说，I帧的压缩率是7（跟JPG差不多），P帧是20，B帧可以达到50。可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。\n"},{"id":92,"href":"/blog/ffmpeg/S1cmUI4qUCf/","title":"H.264NAL头解析","section":"📚 我的文章","content":" H.264 NAL头解析 如果NALU对应的Slice为一帧的开始，则用4字节表示，即0x00000001；否则用3字节表示，0x000001。\nNAL\nHe…\nH.264 NAL头解析 如果NALU对应的Slice为一帧的开始，则用4字节表示，即0x00000001；否则用3字节表示，0x000001。\nNAL\nHeader：forbidden_bit，nal_reference_bit（优先级）2bit，nal_unit_type（类型）5bit。标识NAL单元中的RBSP数据类型，其中，nal_unit_type为1，\n2， 3， 4， 5的NAL单元称为VCL的NAL单元，其他类型的NAL单元为非VCL的NAL单元。\n0：未规定\n1：非IDR图像中不采用数据划分的片段\n2：非IDR图像中A类数据划分片段\n3：非IDR图像中B类数据划分片段\n4：非IDR图像中C类数据划分片段\n5：IDR图像的片段\n6：补充增强信息（SEI）\n"},{"id":93,"href":"/blog/ffmpeg/SkNmLLVcUCf/","title":"iOS FFmpeg集成","section":"📚 我的文章","content":" FFmpeg标准库\n概念:\nFFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。\n采用LGPL或GPL许可证。它提供了录制…\nFFmpeg标准库 # 概念: # FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。\n采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。 它包含了非常先进的音频/视频编解码库libavcodec.\n功能: # 多媒体视频处理工具FFmpeg有非常强大的功能包括视频采集功能、视频格式转换、视频抓图、给视频加水印等。\n1. 视频采集功能: # ffmpeg视频采集功能非常强大，不仅可以采集视频采集卡或USB摄像头的图像，还可以进行屏幕录制，同时还支持以RTP方式将视频流传送给支持RTSP的流媒体服务器，支持直播应用。\n2. 视频格式转换功能: # ffmpeg可以轻易地实现多种视频格式之间的相互转换(wma,rm,avi,mod等)，例如可以将摄录下的视频avi等转成视频网站所采用的flv格式。\n3. 视频截图功能: # 对于选定的视频，截取指定时间的缩略图。视频抓图，获取静态图和动态图，不提倡抓gif文件;因为抓出的gif文件大而播放不流畅。\n4. 给视频加水印功能: # 使用ffmpeg视频添加水印(logo)。\n项目组成: # libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能；\nlibavcodec：用于各种类型声音/图像编解码；\nlibavutil：包含一些公共的工具函数；\nlibswscale：用于视频场景比例缩放、色彩映射转换；\nlibpostproc：用于后期效果处理；\nffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等；\nffsever：一个 HTTP 多媒体即时广播串流服务器；\nffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示\n集成 # 1. 前期准备 # 下载脚本:https://github.com/libav/gas-preprocessor\n复制gas-preprocessor.pl到/usr/sbin下，(这里需要完全关闭苹果的SIP安全功能, 具体请参考这篇文章\n终端下修改文件权限, 指令:\nchmod 777 /usr/sbin/gas-preprocessor.p 安装yasm, 指令如下:\n* curl http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz \u0026gt;yasm.tar.gz * tar xzvf yasm.tar.gz * cd yasm-1.2.0 * ./configure * make * sudo make install 2. 下载ffmpeg # 下载脚本：https://github.com/kewlbear/FFmpeg-iOS-build-script\n解压，找到文件 build-ffmpeg.sh\n编译完成后，终端进入FFmpeg-iOS-build-script目录，然后终端输入 ./build-ffmpeg.sh\nlipo，这个命令是将.a文件合并成一个\n3. 集成 # 把ffmpeg-iOS文件加入到工程中, 引入头文件 #include \u0026quot;avformat.h\u0026quot;, 执行方法\nav_register_all(), 并修改任一文件名由 .m 变为 .mm\n注 : 编译的时候报错： libavcodec/avcodec.h' file not found ，修改 Header search paths 里的路径：$(PROJECT_DIR)/FFmpeg-iOS/include\n添加额外的库引用: libz.tbd libbz2.tbd libiconv.tbd\n编译, 通过.\n"},{"id":94,"href":"/blog/linux/SkaWUIN5U0z/","title":"linux apache mysql php 优化","section":"📚 我的文章","content":" none\n一、准备环境 # 1、安装mysql # #cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql5.5 -DMYSQL_DATADIR=/usr/local/mysql5.5/data -DSYSCONFDIR=/usr/local/mysql5.5/etc -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_ARCHIVE_STORAGE_ENGINE=1 -DWITH_PERFSCHEMA_STORAGE_ENGINE=1 -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DENABLED_LOCAL_INFILE=1 -DWITH_EXTRA_CHARSETS=all #make #make install 2、安装nginx # #./configure --prefix=/usr/local/nginx --http-log-path=/var/log/nginx/access.log --error-log-path=/var/log/nginx/error.log --pid-path=/var/run/nginx/nginx.pid --user=daemon --group=daemon --with-pcre #make \u0026amp;\u0026amp; make install 3、安装php # #./configure --prefix=/usr/local/php5 --enable-bcmath --with-mysql=/usr/local/mysql5.5 --enable-fpm --with-fpm-user=daemon --with-fpm-group=daemon --with-config-file-path=/usr/local/php5 #make \u0026amp;\u0026amp; make install 4、使nginx支持php # (1)nginx配置 # location ~ \\.php$ { root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /usr/local/nginx/html$fastcgi_script_name; include fastcgi_params; } (2)php配置 # #vim /usr/local/php5/etc/php-fpm.conf #cd /usr/local/php5/sbin #./php-fpm -c /usr/local/php5/etc/php-fpm.conf 二、php优化 # 注意：如何添加php功能模块 例：安装mbstring多字节支持功能模块\n#cd /usr/src/lamp/php-5.3.10/ext \\\\进入要安装功能模块源码目录下 #/usr/local/php5/bin/phpize \\\\运行phpize命令，生成configure文件 #./configure --enable-mbstring --with-php-config=/usr/local/php5/bin/php-config #make #make install #vim php.ini\nextension_dir = \u0026#34;/usr/local/php5/lib/php/extensions/no-debug-non-zts-20090626\u0026#34; extension = mbstring.so 1、php加速处理 # (1)对php相关选项进行调整 #vim php.ini # realpath_cache_size = 32k realpath_cache_ttl = 600000 max_excution_time = 60 max_input_time = 120 memory_limit = 128M display_errors = Off (2)安装xcache # #tar xzvf xcache-2.0.0-rc1.tar.gz #cd xcache-2.0.0-rc1 #/usr/local/php5/bin/phpize #./configure --enable-xcache --enable-xcache-constant --with-php-config=/usr/local/php5/bin/php-config #make #make install #vim php.ini\nextension_dir = \u0026#34;/usr/local/php5/lib/php/extensions/no-debug-non-zts-20090626\u0026#34; extension = xcache.so [xcache] xcache.shm_scheme = \u0026#34;mmap\u0026#34; xcache.size = 16M xcache.count = 1 xcache.slots = 8K xcache.ttl = 0 xcache.gc_interval = 0 xcache.var_size = 4M xcache.var_count = 1 xcache.var_slots = 8K xcache.var_ttl = 0 xcache.var_maxttl = 0 xcache.var_gc_interval = 300 xcache.readonly_protection = Off xcache.mmap_path = \u0026#34;/dev/zero\u0026#34; xcache.coredump_directory = \u0026#34;\u0026#34; xcache.cacher = On xcache.stat = On xcache.optimizer = Off xcache.test = Off xcache.experimental = Off [xcache.coverager] xcache.coverager = Off xcache.coveragedump_directory = \u0026#34;\u0026#34; 三、mysql优化 # 1、查询优化 # query-cache-size = 16M query-cache-type = on | off query-cache-limit = 2M mysql\u0026gt;show status like \u0026#39;qcache%\u0026#39;; Qcache_queries_in_cache 目前mysql缓存的数目\nQcache_inserts 插入的缓存条目数 Qcache_hits 缓存命中率\nQcache_lowmem_prunes 有多少次出现缓存过低\nQcache_free_blocks 缓存碎片数量\n2、排序优化 # sort_buffer_size = 8M 设定排序缓冲区大小 max_sort_length = 8192 设定排序队列长度大小 mysql\u0026gt;show status like \u0026#39;%sort%\u0026#39;; Sort_merge_passes 表示排序算法已经完成的排序数量\nSort_range 表示在指定范围内的排序\nSort_rows 表示已经排序了多少行\nSort_scan 通过扫描完成的排序数量\n3、索引优化 # key_buffer_size 设置索引缓冲区大小 自定义索引缓冲区和载入索引\nmysql\u0026gt;set global stu.key_buffer_size=8388608; 设置自定义缓冲区 mysql\u0026gt;load index into cache test.stu; 将索引载入到系统缓冲区 mysql\u0026gt;cache index test.stu in stu; 将索引加载到自定义缓冲区 4、mysql性能优化 # concurrent_insert 是否允许数据并发插入，只对myisam引擎 thread_concurrency 定义并发线程数量\ninnodb_flush_log_log_trx_commit 设置日志写入文件的方式 innodb_buffer_pool_size\n定义缓冲区大小，一般设为内存的80-85%\ninnodb_buffer_pool_instance 定义高速缓冲区可并发操作的实例数量 innodb_open_files 定义可打开的文件数\n5、其它的重点优化参数 # max_connections = 1024 设置数据库允许的最大连接数 max_connect_errors = 32 表示允许的错误连接数 innodb_log_file_size = 512M 设置日志文件大小 innodb_max_dirty_pages_pct=80 设定写入磁盘的脏数据占用的缓冲区比例 "},{"id":95,"href":"/blog/linux/HJi_UUE5ICG/","title":"linux bash截取字符串的几种方法","section":"📚 我的文章","content":" 号截取，删除左边字符，保留右边字符 # var=http://www.aaa.com/123.htm\necho ${var#*//}\n其中var是变量名，…\n# 号截取，删除左边字符，保留右边字符 # var=http://www.aaa.com/123.htm echo ${var#*//} 其中var是变量名，#号是运算符， 号是通配符，//表示从左边开始删除第一个到//处的所有字符即删除http://\n结果是 ：www.aaa.com/123.htm\n## 号截取，删除左边字符，保留右边字符 # var=http://www.aaa.com/123.htm echo ${var##*/} ##*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符即删除 http://www.aaa.com/\n结果是 123.htm\n% 号截取，删除右边字符，保留左边字符 # var=http://www.aaa.com/123.htm echo ${var%/*} %/* 表示从右边开始，删除第一个 / 号及右边的字符\n结果是：http://www.aaa.com\n%% 号截取，删除右边字符，保留左边字符 # var=http://www.aaa.com/123.htm echo ${var%%/*} %%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符\n结果是：http:\n: 号截取，从左边第几个字符开始，及字符的个数 # var=http://www.aaa.com/123.htm echo ${var:0:5} 其中的 0 表示左边第一个字符开始，5 表示字符的总个数。\n结果是：http:\n: 号截取，从左边第几个字符开始，一直到结束 # var=http://www.aaa.com/123.htm echo ${var:7} 其中的 7 表示左边第8个字符开始，一直到结束。\n结果是 ：www.aaa.com/123.htm\n: 号截取，从右边第几个字符开始，及字符的个数 # var=http://www.aaa.com/123.htm echo ${var:0-7:3} 其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数。\n结果是：123\n: 号截取，从右边第几个字符开始，一直到结束 # var=http://www.aaa.com/123.htm echo ${var:0-7} 表示从右边第七个字符开始，一直到结束。\n结果是：123.htm\n注：（左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示）\n"},{"id":96,"href":"/blog/linux/rJvbIUV580z/","title":"linux crontab计划任务详解","section":"📚 我的文章","content":" crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令\n配置文件 # cat /etc/crontab SHELL=/bin/bash 计划任务的默认脚本bash shell PATH=/sbin:/bin:/usr/sbin:/usr/bin 默认搜索路径 MAILTO=root 当计划任务有标准输出或标准错误输出时，会将结果发邮件给root HOME=/ # run-parts 01 * * * * root run-parts /etc/cron.hourly /etc/ 后面一定是个文件夹，每小时执行 02 4 * * * root run-parts /etc/cron.daily 22 4 * * 0 root run-parts /etc/cron.weekly 42 4 1 * * root run-parts /etc/cron.monthly 注意事项 # 多个计划任务不宜同时进行防止有非法计划任务周和日，月不可同时并存，容易导致计划任务时间混乱\n简要说明 # crond\n是linux用来定期执行程序的命令。当安装完成操作系统之后，默认便会启动此任务调度命令。crond命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。而linux任务调度的工作主要分为以下两类：1、系统执行的工作：系统周期性所要执行的工作，如备份系统数据、清理缓存。2、个人执行的工作：某个用户定期要做的工作，例如每隔10分钟检查邮件服务器是否有新信，这些工作可由每个用户自行设置\ncrontab是UNIX系统下的定时任务触发器，其使用者的权限记载在下列两个文件中：\n文件含义 # /etc/cron.deny 该文件中所列的用户不允许使用Crontab命令\n/etc/cron.allow 该文件中所列的用户允许使用Crontab命令\n/var/spool/cron/ 是所有用户的crontab文件\n/var/spool/cron/crontabs /var/spool/cron/crontabs /etc/crontab 系统计划任务列表文件\nCrontab命令的格式为：crontab –l|-r|-e|-i [username]，其参数含义如表一： 参数名称 含义 示例 -l 显示用户的Crontab文件的内容 crontabl –l -i 删除用户的Crontab文件前给提示 crontabl -ri -r 从Crontab目录中删除用户的Crontab文件 crontabl -r -e 编辑用户的Crontab文件 crontabl -e 基本格式 # command \u0026lt;\u0026ndash;\u0026gt; 分　时　日　月　周　命令 第1列表示分钟1～59 每分钟用*或者 */1表示\n第2列表示小时1～23（0表示0点）\n第3列表示日期1～31\n第4列表示月份1～12\n第5列标识号星期0～6（0表示星期天）\n第6列要运行的命令\n时间数值特殊表示方法 # ＊ 表示该范围内的任意时间 ，表示间隔的多个不连续时间点\n－ 表示一个连续的时间范围\n/n 指定间隔的时间频率\n常用例子 # #每晚的21:30重启apache 30 21 * * * /usr/local/etc/rc.d/lighttpd restart #每月1、10、22日的4 : 45重启apache 45 4 1,10,22 * * /usr/local/etc/rc.d/lighttpd restart #每周六、周日的1 : 10重启apache 10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart #每天18 : 00至23 : 00之间每隔30分钟重启apache 0,30 18-23 * * * /usr/local/etc/rc.d/lighttpd restart #每个星期的星期六的11 : 00 pm重启apache 0 23 * * 6 /usr/local/etc/rc.d/lighttpd restart #每一小时重启apache * */1 * * * /usr/local/etc/rc.d/lighttpd restart #每天的晚上11点到早上7点之间，每隔一小时重启apache * 23-7/1 * * * /usr/local/etc/rc.d/lighttpd restart #每月的4号与每周一到周三的11点重启apache 0 11 4 * mon-wed /usr/local/etc/rc.d/lighttpd restart #每年的一月一号的4点重启apache 0 4 1 jan * /usr/local/etc/rc.d/lighttpd restart "},{"id":97,"href":"/blog/linux/B1CLLE98CG/","title":"linux DHCP简单使用方法","section":"📚 我的文章","content":"配置\nvim /etc/dhcpd.conf default-lease-time 1296000; max-lease-time 4000000; #IP最长失效时间 option subnet-mask 255.255.255.0; #子网的掩码 option broadcast-address 192.168.0.255; #网络的广播地址 option routers 192.168.0.254; #网关的地址 option domain-name-servers 211.151.48.59,211.151.48.47; #域名解析地址 ddns-update-style ad-hoc; subnet 192.168.0.0 netmask 255.255.255.0 { #定义IP池的内容 range 192.168.0.100 192.168.0.240; #地址范围为 100-240 共140个IP地址。 } #也可以象下面一样按MAC地址指定IP #host Jephe {hardware ethernet 00:a0:c9:a6:96:33;fixed-address 192.168.1.12;} 详解 # parameters（参数） # ddns-update-style 配置DHCP-DNS互动更新模式 default-lease-time 指定缺省租赁时间的长度，单位是秒 max-\nlease-time 指定最大租赁时间长度，单位是秒 hardware 指定网卡接口类型和MAC地址 server-name 通知DHCP客户服务器名称\nget-lease-hostnames flag 检查客户端使用的IP地址 fixed-address ip 分配给客户端一个固定的地址\nauthritative 拒绝不正确的IP地址的要求\ndeclarations（声明） # shared-network 用来告知是否一些子网络分享相同网络 subnet 描述一个IP地址是否属于该子网 range 起始IP 终止IP\n提供动态分配IP 的范围 host 主机名称 参考特别的主机 group 为一组参数提供声明 allow unknown-clients或deny\nunknown-client 是否动态分配IP给未知的使用者 allow bootp或deny bootp 是否响应激活查询 allow\nbooting或deny booting 是否响应使用者查询 filename 开始启动文件的名称，应用于无盘工作站 next-server\n设置服务器从引导文件中装如主机名，应用于无盘工作站\noption（选项） # subnet-mask 为客户端设定子网掩码 domain-name 为客户端指明DNS名字 domain-name-servers\n为客户端指明DNS服务器IP地址 host-name 为客户端指定主机名称 routers 为客户端设定默认网关 broadcast-address\n为客户端设定广播地址 ntp-server 为客户端设定网络时间服务器IP地址 time-offset 为客户端设定和格林威治时间的偏移时间，单位是秒。\n中继 # 配置步骤 # 1、开启路由转发\n2、设置就哦中继接口及DHCP服务器地址\n3、启动dhcprelay中继服务程序\n内核参数 # vim /etc/sysctl.conf net.ipv4.ip_forward = 1 sysctl -p 修改配置 # vim /etc/sysconfig/dhcrelay INTERFACES=\u0026#34;eth0 eth1\u0026#34; DHCPSERVERS=\u0026#34;192.168.1.2\u0026#34; 启动 # chkconfig dhcrelay on chkconfig dhcp on /etx/init.d/dhcp start /etc/init.d/dhcrelay start "},{"id":98,"href":"/blog/linux/HkiLUE5UCf/","title":"linux dns（named）最小配置","section":"📚 我的文章","content":" none\n一、简介 # 相对于存储和大数据领域，CDN是一个相对小的领域，但行行出状元，BIND就是CDN领域的蝉联N届的状元郎。BIND是一款非常常用的DNS开源服务器，全球有90%的DNS用BIND实现。值得一提的是，BIND9.8.1用C语言实现，代码量巨大，其设计实现几乎涵盖了服务器编程的所有细节。\n本文简要介绍一下BIND9.8.1最简单配置，其中穿插介绍BIND中的最基本概念，不涉及BIND的安装部署，不涉及BIND架构等话题。\n二、Zone和资源记录 # 介绍最简配置前需要明确两个配置中的概念：zone和RR。\nBIND的配置文件描述了一个域名服务器的所有属性，这些属性BIND的行为和功能。其中的zone文件描述了域名服务器中包含的主机，所提供的服务类型等信息，BIND通过将zone文件中的信息加载到内存数据结构中并有效组织起来，然后对外部的DNS请求提供验证和查询请求。需要注意的是，zone文件的格式不是由BIND制定的，而是DNS标准文档制定的（见RFC1035）。\n通常情况下，一个zone文件描述该DNS服务器服务的一个授权服务器域。例如我有一个DNS服务器可以解析taobao.com的域名和baidu.com的域名，那么我的DNS服务器的配置文件中就可以设置两个zone标签，一个描述taobao.com的域名信息，另一个描述baidu.com的域名信息。\n资源记录resource\nRecord记录了一个域(domain)的属性和特性，注意，属性是指共有的特征，特性指特有的特征。例如中国特色社会主义就是一个特性。\n三，named.conf文件配置 # named.conf是BIND的唯一的主配置文件，当然你也可以自己编写主配置文件，但是需要在BIND主进程named启动的时候用-\nc选项指定主配置文件的路径。named.conf由一个个子句组成，每个子句都有一个头跟一对大括号组成，大括号里面是该子句中的因子和值（具体见下面的例子）。\n下面的代码是named.conf的一个最简配置。其中假设named.conf只负责解析授权域名cobb.com。 其中的key是由rndc-\nconfgen生成的。\nkey \u0026#34;rndc-key\u0026#34; { algorithm hmac-md5; secret \u0026#34;eoiWMiCwCYPwNLWxl05rNw==\u0026#34;; }; controls { inet 127.0.0.1 port 953 allow { 127.0.0.1; } keys { \u0026#34;rndc-key\u0026#34;; }; }; options { //域名文件存放的绝对路径 directory \u0026#34;/usr/local/named/var\u0026#34;; //如果bind启动，自动会在/usr/local/named/var目录生成一个named.pid文件，打开文件就是named进程的ID pid-file \u0026#34;named.pid\u0026#34;; }; zone \u0026#34;.\u0026#34; IN { //根域名服务器 type hint; //存放在//usr/local/named/var目录，文件名为named.root file \u0026#34;named.root\u0026#34;; }; //域cobb.com的zone文件 zone \u0026#34;cobb.com\u0026#34; IN { type master; //该域名服务器是主域名服务器，这个选项主要用在主备部署中 file \u0026#34;cobb.com.zone\u0026#34;; //解析域名cobb.com的zone文件内容，其路径由options中的directory指定 allow-update { none; }; //定义了允许向主zone文件发送动态更新的匹配列表 }; //反向解析 zone \u0026#34;1.168.192.in-addr.arpa\u0026#34; in { type master; //存放反向解析的文件 file \u0026#34;cobb.com.rev\u0026#34;; allow-update { none; }; }; 上面的代码中，controls子句定义了服务器的控制通道的一些信息，控制通道是named为外部提供的管理named服务器的接口。通常情况下named都在本机的953端口上监听控制信息；allow表示允许本机上的rndc控制程序控制named服务器，allow出了指定ip地址外，还可以指定acl中的用户地址；keys表示rndc控制named时需要携带的密钥\n，这个密钥由rndc-gen生成，并在named.conf中包含。\n接下来的options选项中包含一些全局状态描述，这些描述信息在所有的zone文件和view中可见（view后面的系列博客会介绍），但如果zone文件或view中重新定义这些描述信息，则options中的信息被覆盖\n。上面例子中的directory和pid-file的含义见代码注释。\n四、zone文件配置 # 文件cobb.com.zone文件位于/usr/local/named/var中，其内容如下所示：\n$TTL 86400 $ORIGIN cobb.com. @ IN SOA ns1 root( 2013031901 ;serial 12h ;refresh 7200 ;retry 604800 ;expire 86400 ;mininum ) NS ns1.cobb.com. NS ns2.cobb.net. MX 10 mail.cobb.com. ns1 IN A 192.168.10.1 www IN A 192.168.10.10 IN A 192.168.10.11 mail IN A 192.168.10.20 ljx IN A 192.168.10.30 ftp IN CNAME ljx 上面的配置表示：\n1）该zone有两个域名服务器，一个是ns1.cobb.com，ip地址是192.168.10.1，另一个是ns2.cobb.net(它不在本域内)；\n2）该zone有一个邮件服务器，域名是mail.cobb.com，IP地址是192.168.10.20；\n3）该zone有两个对外服务的万维网服务器，其域名是www.cobb.com，IP地址是192.168.10.10和192.168.10.11；\n4）该zone有一个对外服务的ftp服务器，其域名是ftp.cobb.com，IP地址是192.168.10.30；\n5）该zone有一个主机，其域名是ljx.cobb.com，IP地址也是192.168.10.30； 其中TTL和ORIGIN等标签在BIND中叫做指令。\nzone文件中的所有指令都以一个$开始，指令主要用来表示zone文件中的一些控制信息。\n$TTL指令表示一个资源记录在其他DNS服务器中（这个DNS服务器是请求本BIND的服务器，一般情况下是local\ndns）的缓存时间，在这个缓存时间内，local dns（暂且先这么认为，好举例）不会再请求BIND，而是直接返回域名对应的IP地址。\n$ORIGIN指令表示该zone文件用来描述的域(domain)名称。 SOA(start of\nauthority)资源记录：它定义了一个域的全局特性，必须是出现在zone文件中的第一个资源记录，而且一个zone文件中必须只有一个SOA资源记录。其中SOA后面的ns1与root分别是域名服务器和管理员邮箱(root@cobb.com)，其全写分别是ns1.cobb.com.和root.cobb.com，因为$ORIGIN指明了域名，所以这个地方可以略去。\nNS(name\nserver)资源记录：它定义了为本域(domain)(这个例子中是cobb.com)服务的域名服务器。需要注意的是外部域名服务器（例子中的ns2）必须为zone\ncobb.com包含一个zone文件。\nMX(mail exchanger)资源记录：它定义了本域中的邮件服务器。这个资源记录是可选的，因为一个域中不一定有邮件服务器。\nA(Address)资源记录：这是个很关键的记录。它定义了zone文件中提到的主机或服务的IPv4地址（IPv6地址叫AAAA记录），而且这些IPv4地址必须是外部可见的。例如万维网服务器\nwww.cobb.com的IPv4地址是192.168.10.10。\nCNAME记录：是一个已经定义了IPv4地址的主机的别名记录。通常用来为已经存在的主机分配一个或多个服务。示例中的主机ljx.cobb.com既做主机又提供ftp服务。从上面的分析可以看出，我们也可以不用CNAME，只需要为不同的服务指定相同的IP地址即可。\n但是实际上两种情况下必须用CNAME记录：\n1）真是主机或别名主机在不同的域中，我们不知道外部域中的IP地址，所以必须要用CNAME，例如ftp.cobb.com是ftp.cobb.net的一个别名，但是在域cobb.com中无法知道ftp.cobb.net的IP地址，只能用CNAME记录；\n2）用户希望访问一个站点时用cobb.com产生www.cobb.com的效果，这时我们需要有如下的CNAME定义：\n; 定义一个解析cobb.com的IP地址 IN A cobb.com ; 为www.cobb.com建立别名cobb.com www IN A cobb.com. 当然，上面介绍的只是一个最小配置，但是已经包含了大部分情况下我们需要配置的选项。更多的配置选项请参见：http://www.zytrax.com/books/dns/ch7/view.html 五 参考文献 # 1，《Pro_DNS_and_BIND》\n2，http://www.zytrax.com/books/dns/ch7/view.html\n3，http://www.cnblogs.com/cobbliu/archive/2013/03/19/2970311.html 原文地址：直达\n"},{"id":99,"href":"/blog/linux/B1OZ8INcIAM/","title":"linux mount命令详解","section":"📚 我的文章","content":" 功能 # 加载指定的文件系统。\n语法 # mount [-afFhnrvVw] [-L] [-o] [-t] [设备名] [加载点]\n用法 # 说明：mount可将指定设备中指定的文件系统加载到Linux目录下（也就是装载点）。可将经常使用的设备写入文件/etc/fastab,以使系统在每次启动时自动加载。mount加载设备的信息记录在/etc/mtab文件中。使用umount命令卸载设备时，记录将被清除。\n常用参数和选项 # -a 加载文件/etc/fstab中设置的所有设备。\n-f 不实际加载设备。可与-v等参数同时使用以查看mount的执行过程。\n-F 需与-a参数同时使用。所有在/etc/fstab中设置的设备会被同时加载，可加快执行速度。\n-h 显示在线帮助信息。\n-L 加载文件系统标签为的设备。\n-n 不将加载信息记录在/etc/mtab文件中。\n-o 指定加载文件系统时的选项。有些选项也可在/etc/fstab中使用。这些选项包括：\nasync 以非同步的方式执行文件系统的输入输出动作。\natime 每次存取都更新inode的存取时间，默认设置，取消选项为noatime。\nauto 必须在/etc/fstab文件中指定此选项。执行-a参数时，会加载设置为auto的设备，取消选取为noauto。\ndefaults 使用默认的选项。默认选项为rw、suid、dev、exec、anto nouser与async。\ndev 可读文件系统上的字符或块设备，取消选项为nodev。\nexec 可执行二进制文件，取消选项为noexec。\ndata=writeback 不记录磁盘的日志\ndata=ordered 只记录主要的日志\ndata=journal 记录所有的日志\nnoatime 每次存取时不更新inode的存取时间。\nnoauto 无法使用-a参数来加载。\nnodev 不读文件系统上的字符或块设备。\nnoexec 无法执行二进制文件。\nnosuid 关闭set-user-identifier(设置用户ID)与set-group-identifer(设置组ID)设置位。\nnouser 使一般用户无法执行加载操作，默认设置。\nremount 重新加载设备。通常用于改变设备的设置状态。\nro 以只读模式加载。\nrw 以可读写模式加载。\nsuid 启动set-user-identifier(设置用户ID)与set-group-identifer(设置组ID)设置位，取消选项为nosuid。\nsync 以同步方式执行文件系统的输入输出动作。\nuser 可以让一般用户加载设备。\n-r 以只读方式加载设备。\n-t 指定设备的文件系统类型。常用的选项说明有：\nminix Linux最早使用的文件系统。\next2 Linux目前的常用文件系统。\nmsdos MS-DOS 的 FAT。\nvfat Win85/98 的 VFAT。\nnfs 网络文件系统。\niso9660 CD-ROM光盘的标准文件系统。\nntfs Windows NT的文件系统。\nhpfs OS/2文件系统。Windows NT 3.51之前版本的文件系统。\nauto 自动检测文件系统。\n-v 执行时显示详细的信息。\n-V 显示版本信息。\n-w 以可读写模式加载设备，默认设置。\n卸载故障 # 故障原因 需要卸载的设备正在被使用 现象：提示：“…device is busy”\n解决思路 # 将工作目录切换到挂载点以外，退出正在使用该设备的程序，使用fuser命令找出相关进程，结束该进程。\n"},{"id":100,"href":"/blog/linux/rJJe8UNcU0M/","title":"linux nfs配置及访问控制","section":"📚 我的文章","content":" NFS软件包 # nfs-utils portmap (rhel6换成了rpcbind ,所以启动服务时需要注意)\nNFS文件 # /etc/exports #NFS主配置文件 /etc/init.d/nfs #NFS启动脚本 /etc/init.d/protmap\n#portmap启动脚本 /var/lib/*tab #NFS日志文件\n书写规则 # 目录名(绝对路径) 客户端主机名、IP或“*”(选项) 选项可选择如下：\nsync：设置NFS服务器同步写磁盘,这样不会轻易丢失数据,建议所有的NFS共享目录使用该选项. ro：设置输出的共享目录为只读，与rw不能同时使用。\nrw：设置输出的共享目录为可读写，与ro不能同时使用。 root_squash：root用户访问共享目录的身份会自动变成nobody身份。\nno_root_squash：root用户会以自己的真实身份访问共享目录，不安全，不建议使用。 更多选项可在网上查\nshowmount # showmount命令用于查询显示NFS服务器的相关信息 显示NFS服务器的输出目录列表 显示当前本机中NFS服务器输出列表\nshowmount -e 显示指点NFS服务器中的共享目录列表\nshowmount -e IP 防火墙配置 # nfsd：2049 rhel5 portmap：111 rhel6 rpcbind：111\nrquotad,mountd,sratd和lockd可以强制使用一个大于1024的静态端口\n修改/etc/sysconfig/nfs文件 QUOTAD_PORT=40001 #rpc.quotad进程端口 LOCKD_TCPPORT=40002 #rpc.lockd进程端口 LOCKD_UDPPORT=40002 MOUNTD_PORT=40003 #rpc.mountd进程端口 STARTD_PORT=40004 #rpc.sratd进程端口 exportfs # 修改了/etc/exports文件不需要重启nfs，只要重新加载/etc/exports文件即可。\n-a：全部挂载（或卸载）/etc/exports文件内的设定。\n-r：重新加载/etc/exports中的设置，此外同步更新/etc/exports及/var/lib/nfs/xtab中的内容。\n-u：卸载某一目录。\n-v：在export时将共享的目录显示在屏幕上。\n常用组合 # exportfs -rv (重新加载配置并输出当前共享的目录)\nexportfs -auv (停止当前主机中NFS服务器的所有输出目录)\n服务配置 # vim /etc/exports /home/share 10.1.1.2(sync,rw) *(sync,ro) linux使用 # mount -t nfs ip地址:/home/share/ /mnt Windwos使用 # Windows 7或Windows 2008支持NFS客户端,NFS服务端只有Windows Server版本支持\nshowmount -e 10.1.1.1 mount \\\\10.1.1.1\\share Z: 需要注意的是，mount 挂载点和Linux及UNIX有所不同，不是使用一个目录作为挂载点，而是使用一个未被使用的盘符。\n"},{"id":101,"href":"/blog/linux/SJ68UEcUCM/","title":"linux openssh 常见问题汇总","section":"📚 我的文章","content":" 软件包名\nopenssh-server openssh-clients\n服务名：sshd\n服务端配置文件：/etc/ssh/sshd.config 客户端…\n软件包名 # openssh-server openssh-clients\n服务名：sshd # 服务端配置文件：/etc/ssh/sshd.config 客户端配置文件：/etc/ssh/ssh.config\n启动服务 # server sshd start 文件说明 # ~/.ssh/known_hosts #存放访问过的服务器的公钥 ~/.ssh/authorized_keys #存放需要验证的客户机的公钥 常见问题 # 1、ssh访问慢 # 原因：访问服务器的时候会把服务器的IP地址反向解析为域名，如果无法解析就会导致登陆时很慢。 下面几种方法都可以解决这个问题\n1、清空/etc/resolv.conf文件中的nameserver记录 2、在客户机的/etc/hosts文件中添加服务器域名的解析记录\n3、修改客户端的/etc/ssh/ssh.config文件 GSSAPLAuthentication no\n4、修改服务端的/etc/ssh/sshd.config文件 UserDNS no\n2、~/.ssh权限 # .ssh目录和下面的文件权限，组和其他人不能有w的权限 解决方法：降低第服务端的权限检查\nvim /etc/ssh/sshd_config StrictModes no 3、第一次访问sshserver时不用输入yes # ssh -o StrictHostKeyChecking=no username@sshserver vim /etc/ssh/ssh.config StrictHostKeyChecking=no 公钥认证 # ssh-keygen -t rsa #指定rsa算法 在~/.ssh/下生产两个文件 id_rsa用户的私钥 id_rsa.pub用户的公钥ssh-\ncopy-id -i ~/.ssh/id_rsa.pub username@sshserver\nscp使用 # scp 用户名@服务器地址:文件 本地路径 scp 本地文件 用户名@服务器地址:目标路径\nsftp使用 # sftp 用户名@服务器地址\ntcp_wrappers访问控制 # 检查某个服务是否受tcp_wrappers管理支持\nldd $(which sshd)|grep libwrap 先检查/etc/hosts.allow然后检查/etc/hosts.deny 如果两个文件都没有匹配的规则，则放行。\nsshd:all EXCEPT 192.168.0.0/255.255.255.0 可以使用all、?、* 阻挡所有但排除192.168.0.0网段\n"},{"id":102,"href":"/blog/linux/rkxlI845IAz/","title":"linux samba配置及乱码的解决方法","section":"📚 我的文章","content":" 简要说明 # samba：这个软体主要提供了SMB伺服器所需的各项服务程式(smbd及nmbd)、的文件档、以及其他与SAMBA相关的logrotate设定档及开机预设选项档案等；\nsamba-client：这个软体则提供了当Linux做为SAMBA\nClient端时，所需要的工具指令，例如挂载SAMBA档案格式的mount.cifs、取得类似网芳相关树状图的smbtree等等；\nsamba-common：这个软体提供的则是伺服器与用户端都会使用到的资料，包括SAMBA的主要设定档(smb.conf)、语法检验指令(testparm)等等；\n/var/lib/samba/private/{passdb.tdb,secrets.tdb}：管理Samba的使用者帐号/密码时，会用到的资料库档案；\n服务配置 # vim /etc/samba/smb.conf\n[share] path = /share //共享的目录 writable = yes //是否可写 write list = test // test用户可以访问该共享 访问控制 # max connections = 最大连接数 deadtime = 断掉连接时间（分钟）【0为不限制】 hosts deny = IP 、域名、except hosts allow = IP 、域名、except 用户控制 # public = no #不允许匿名用户访问 browseable = no #隐藏目录 （知道目录同样可以访问） valid users = 用户或列表或@用户组 writable = yes #可写（目录本身要可写） weite list = 用户或列表或@用户组 read only = yes #只读设置 create mask = 0744 #控制客户机创建文件的权限 directory mask = 0744 # 控制客户机创建目录的权限 安全级别 # samba服务器的安全级别分为5种，分别是user、share、server、domain和ads。\n在设置不同的级别时，samba服务器还会使用口令服务器和加密口令。\n1、user —–客户端访问服务器时需要输入用户名和密码，通过验证后，才能使用服务器的共享资源。此级别使用加密的方式传送密码。\n2、share —–客户端连接服务器时不需要输入用户名和密码\n3、server —–客户端在访问时同样需要输入用户名和密码，但是，密码验证需要密码验证服务器来负责。\n4、domain —–采用域控制器对用户进行身份验证\n5、ads —–若samba服务器加入到Windows活动目录中，则使用ads安全级别，ads安全级别也必须指定口令服务器\n启动服务 # service smb reload 管理工具 # 修改完配置文件后，启动服务，然后添加Samba用户（pdbedit -a 用户名）\n使用pdbedit指令功能 选项与参数：\n-L ：列出目前在资料库当中的帐号与UID 等相关资讯；\n-v ：需要搭配-L 来执行，可列出更多的讯息，包括家目录等资料；\n-w ：需要搭配-L 来执行，使用旧版的smbpasswd 格式来显示资料；\n-a ：新增一个可使用Samba 的帐号，后面的帐号需要在/etc/passwd 内存在者；\n-r ：修改一个帐号的相关资讯，需搭配很多特殊参数，请man pdbedit；\n-x ：删除一个可使用Samba 的帐号，可先用-L 找到帐号后再删除；\n-m ：后面接的是机器的代码(machine account)，与domain model 有关！\n乱码问题 # cat /etc/sysconfig/i18n [global] # 如果locale是zh_CN.UTF-8，做如下设置： display charset = UTF-8 unix charset = UTF-8 dos charset = UTF-8 # 如果locale是zh_CN.GBK或zh_CN.gb2312，做如下设置： display charset = cp936 unix charset = cp936 dos charset = cp936 linux访问 # smbclient //IP/目录名 -U 登录用户名 mount -t cifs -o username=用户名,passwd=密码,iocharset=gb2312,uid,pid,rw //ip 挂载点 smbtar -s server -u user -p passwd -x sharename -t output.tar windows访问 # windows访问方式就不说了。下面说下清除windows共享访问方法：\n打开cmd. c:\\\u0026gt;net use * /del "},{"id":103,"href":"/blog/linux/B1muLLNcIRf/","title":"Linux Screen命令","section":"📚 我的文章","content":"Linux screen 命令用于多重视窗管理程序。\nscreen 为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用 telnet 登入主机或是使用老式的终端机时，才有可能用到 screen 程序。\n语法 # screen [-AmRvx -ls -wipe][-d \u0026lt;作业名称\u0026gt;][-h \u0026lt;行数\u0026gt;][-r \u0026lt;作业名称\u0026gt;][-s \u0026lt;shell\u0026gt;][-S \u0026lt;作业名称\u0026gt;] 参数说明：\n-A 将所有的视窗都调整为目前终端机的大小。 -d \u0026lt;作业名称\u0026gt; 将指定的 screen 作业离线。 -h \u0026lt;行数\u0026gt; 指定视窗的缓冲区行数。 -m 即使目前已在作业中的 screen 作业，仍强制建立新的 screen 作业。 -r \u0026lt;作业名称\u0026gt; 恢复离线的 screen 作业。 -R 先试图恢复离线的作业。若找不到离线的作业，即建立新的 screen 作业。 -s 指定建立新视窗时，所要执行的 shell。 -S \u0026lt;作业名称\u0026gt; 指定 screen 作业的名称。 -v 显示版本信息。 -x 恢复之前离线的 screen 作业。 -ls 或 \u0026ndash;list 显示目前所有的 screen 作业。 -wipe 检查目前所有的 screen 作业，并删除已经无法使用的 screen 作业。 实例 # 创建 screen 终端\nscreen //创建 screen 终端 创建 screen 终端 并执行任务\nscreen vi ~/main.c //创建 screen 终端 ，并执行 vi命令 离开 screen 终端\nscreen vi ~/main.c //创建 screen 终端 ，并执行 vi命令 #include main () { } \u0026#34;~/mail.c\u0026#34; 0,0-1 在 screen 终端 下 按下 Ctrl+a d键 重新连接离开的 screen 终端\nscreen -ls # 显示已创建的screen终端 There are screens on: 2433.pts-3.linux (2013年10月20日 16时48分59秒) (Detached) 2428.pts-3.linux (2013年10月20日 16时48分05秒) (Detached) 2284.pts-3.linux (2013年10月20日 16时14分55秒) (Detached) 2276.pts-3.linux (2013年10月20日 16时13分18秒) (Detached) 4 Sockets in /var/run/screen/S-root. screen -r 2276 //连接 screen_id 为 2276 的 screen终端 "},{"id":104,"href":"/blog/linux/Hk2bI84c8Rz/","title":"linux VM虚拟内存和BDP优化","section":"📚 我的文章","content":" none\nVM虚拟内存优化 # #getconf PAGESIZE\nvm.dirty_background_bytes 系统内所包含的脏数据总数\nvm.dirty_background_ratio 脏数据所占用内存的百分比\nvm.dirty_expire_centisecs 脏数据在内存中的存放时间\nvm.dirty_bytes 如果进程的脏数据超过该值时则要求写到磁盘\nBDP优化 # BDP=Bandwidth*RRT net.core.rmem_max 最大缓冲区(窗口)大小\nnet.core.wmem_default 默认缓冲区大小\nnet.core.wmem_max 最大发送缓冲区大小\n"},{"id":105,"href":"/blog/linux/H13UIE5LRM/","title":"linux vnc简单配置","section":"📚 我的文章","content":" none\nVNC端口 # vncserver监听端口 RFB协议：5900+桌面号 HTTP协议：5800+桌面号 X协议：6000+桌面号\nvncserver使用的桌面编号默认是从1开始，依次使用。\nvnc配置 # 安装vnc 和vnc-server\nvncserver :1 #启动vncserver并生产配置文件\n修改~/.vnc/xstartup文件 默认使用twm环境 使用图形界面：\n修改配置文件，去掉下列两行的注释\nUncomment the following two lines for normal desktop: # unset SESSION_MANAGER # exec /etc/X11/xinit/xinitrc # 修改/etc/sysconfig/vncservers文件 去掉最后两行的注释\nVNCSERVERS=“2:myusername”\nVNCSERVERARGS[2]=“-geometry 800x600 -nolisten tcp -nohttpd -localhost”\n修改配置文件后重新VNC服务 vncserver -kill :1 vncserver :1\n修改/etc/inittab文件 将默认的启动级别改成5 添加开机启动 chkconfig vncserver on\n"},{"id":106,"href":"/blog/linux/S19ZLLE9I0G/","title":"linux 常用系统资源查看命令","section":"📚 我的文章","content":" none\n一、sar命令 # # sar 1 10 监控CPU，每秒监控一次，共监控10次 # sar -P ALL 1 5 监控所有CPU # sar -S 1 10 监控交换分区 # sar -d 1 10 监控磁盘IO # sar -b 1 10 监控磁盘IO和速率 # sar -r 1 10 监控内存使用 # sar -n DEV 1 10 监控网络接口卡的数据传输 二、mpstat # # mpstat -P ALL 1 10 三、iostat # # iostat -c 2 # iostat -d 1 100 # iostat 1 20 # iostat -p /dev/sda2 1 10 四、vmstat # #vmstat -d 1 20 输出信息 r 运行队列中的进程数，不要长时间超过CPU核心总数 b 等待IO的进程数 si 每秒从交换分区写到内存的数据大小 so 每秒写入交换分区的数据大小 #vmstat -a 1 10 五、其它常用监控命令 # (1) top (2) free (3) iptraf\n"},{"id":107,"href":"/blog/linux/H1sZIUN9I0f/","title":"linux 防拒绝服务攻击","section":"📚 我的文章","content":" none\n一、使用脚本 # wget http://www.inetbase.com/scripts/ddos/install.sh 安装脚本 wget http://www.inetbase.com/scripts/ddos/uninstall.sh 卸载脚本 二、内核优化 # net.ipv4.tcp_max_syn_backlog = 1024 #设定syn队列长度 net.ipv4.tcp_syncookies = 1 #设定是否启用cookies net.ipv4.tcp_synack_retries = 3 #设定synack重试次数 net.ipv4.tcp_syn_retries = 2 #设定syn重试次数 net.ipv4.icmp_echo_ignore_all = 1 #不回应ping net.ipv4.icmp_echo_ignore_broadcast = 1 #不回应广播ping 三、防火墙配置 # 1、基于数据包进行限制 # #iptables -A INPUT -p tcp --tcp-flags syn,ack,fin syn -m limit --limit 5/s --limit-burst 8 -j ACCEPT #iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT 2、基于连接数进行限制 # #iptables -A INPUT -s 192.168.0.0/24 -p tcp --dport 23 -m connlimit --connlimit-above 2 -j DROP 3、基于地址列表进行限制 # #iptables -A INPUT -p tcp --dport 80 --tcp-flags syn,ack,fin syn -m recent --name webpool --rcheck --seconds 120 --hitcount 10 -j LOG --log-prefix=\u0026#34;ddos:\u0026#34; --log-ip-options #iptables -A INPUT -p tcp --dport 80 --syn -m recent --name webpool --rcheck --seconds 120 --hitcount 10 -j DROP #iptables -A INPUT -p tcp --dport 80 --syn -m recent --name webpool --set -j ACCEPT "},{"id":108,"href":"/blog/linux/HyYg884c80f/","title":"linux 防御SYN攻击","section":"📚 我的文章","content":" none\n一、默认syn配置 # sysctl -a | grep _syn net.ipv4.tcp_max_syn_backlog = 1024 net.ipv4.tcp_syncookies = 1 net.ipv4.tcp_synack_retries = 5 net.ipv4.tcp_syn_retries = 5 tcp_max_syn_backlog 是SYN队列的长度，加大SYN队列长度可以容纳更多等待连接的网络连接数。\ntcp_syncookies是一个开关，是否打开SYN Cookie 功能，该功能可以防止部分SYN攻击。\ntcp_synack_retries和tcp_syn_retries定义SYN 的重试连接次数，将默认的参数减小来控制SYN连接次数的尽量少。\n二、修改syn配置 # ulimit -HSn 65535 sysctl -w net.ipv4.tcp_max_syn_backlog=2048 sysctl -w net.ipv4.tcp_syncookies=1 sysctl -w net.ipv4.tcp_synack_retries=2 sysctl -w net.ipv4.tcp_syn_retries=2 三、添加防火墙规则 # #Syn 洪水攻击(--limit 1/s 限制syn并发数每秒1次) iptables -A INPUT -p tcp --syn -m limit --limit 1/s -j ACCEPT #防端口扫描 iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST RST -m limit --limit 1/s -j ACCEPT #防洪水ping iptables -A FORWARD -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT 四、添加开机启动 # 最后别忘记将二、三、里面的命令写到/etc/rc.d/rc.local\n"},{"id":109,"href":"/blog/linux/HkGxI8VcL0f/","title":"linux（内核）oom kille vm.overcommit_memory参数详解","section":"📚 我的文章","content":" none\n详细说明 # 可选值：0、1、2。\n0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。\n1， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。\n2， 表示内核允许分配超过所有物理内存和交换空间总和的内存\n修改方法 # sysctl vm.overcommit_memory=2 echo \u0026#34;vm.overcommit_memory=2\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf "},{"id":110,"href":"/blog/linux/HJCOI8NqUAG/","title":"linux代理地址失效导致的问题解析","section":"📚 我的文章","content":" none\n错误描述 # 任何需要使用http服务的程序都会存在假死或超时，包括wget、cur、yum等等。\n初步发现 # 使用sudo 可是正常访问。\n例如：\nsudo yum install wget 然后发现 # [root@jn6 tmp]# wget http://mirrors.163.com/.help/CentOS6-Base-163.repo --2018-03-08 14:13:53-- http://mirrors.163.com/.help/CentOS6-Base-163.repo Connecting to 10.1.205.242:3128... 根据上面的提示发现了\nConnecting to 10.1.205.242:3128... 很明显是使用了代理，并且代理已经失效了。\n解决办法 # 查看“/etc/profile”、“/.bashrc”或者“/.bash_profile”将如下类似的行注释掉即可。\n#ftp_proxy=\u0026#34;http://10.1.205.242:3128\u0026#34;;export ftp_proxy #http_proxy=\u0026#34;http://10.1.205.242:3128\u0026#34;;export http_proxy #https_proxy=\u0026#34;http://10.1.205.242:3128\u0026#34;;export https_proxy 问题总结 # 根据初步发现的结果可以了解到，sudo并没有解析“/.bashrc”和“/.bash_profile”这两个文件。\n"},{"id":111,"href":"/blog/linux/S13z8UE5UCf/","title":"linux内存清理释放命令","section":"📚 我的文章","content":" none\n命令 # sync echo 1 \u0026gt; /proc/sys/vm/drop_caches echo 2 \u0026gt; /proc/sys/vm/drop_caches echo 3 \u0026gt; /proc/sys/vm/drop_caches 解释 # cache释放： To free pagecache: echo 1 \u0026gt; /proc/sys/vm/drop_caches To free dentries and inodes: echo 2 \u0026gt; /proc/sys/vm/drop_caches To free pagecache, dentries and inodes: echo 3 \u0026gt; /proc/sys/vm/drop_caches 说明 # 释放前最好sync一下，防止丢数据。\n"},{"id":112,"href":"/blog/linux/B1FO88V580M/","title":"Linux清除内存","section":"📚 我的文章","content":" 如何在 Linux 中清除缓存（Cache）？ # 每个 Linux 系统有三种选项来清除缓存而不需要中断任何进程或服务。\n（LCTT 译注：Cache，译作“缓存”，指 CPU\n和内存之间高速缓存。Buffer，译作“缓冲区”，指在写入磁盘前的存储再内存中的内容。在本文中，Buffer 和 Cache 有时候会通指。）\n仅清除页面缓存（PageCache） # sync; echo 1 \u0026gt; /proc/sys/vm/drop_caches 清除目录项和inode # sync; echo 2 \u0026gt; /proc/sys/vm/drop_caches 清除页面缓存，目录项和inode # sync; echo 3 \u0026gt; /proc/sys/vm/drop_caches 上述命令的说明：\nsync\n将刷新文件系统缓冲区（buffer），命令通过“;”分隔，顺序执行，shell在执行序列中的下一个命令之前会等待命令的终止。正如内核文档中提到的，写入到drop_cache将清空缓存而不会杀死任何应用程序/服务，echo命令做写入文件的工作。\n如果你必须清除磁盘高速缓存，第一个命令在企业和生产环境中是最安全，”…echo 1\u0026gt; …“只会清除页面缓存。\n在生产环境中不建议使用上面的第三个选项”…echo 3 \u0026gt; …” ，除非你明确自己在做什么，因为它会清除缓存页，目录项和inodes。\n"},{"id":113,"href":"/blog/linux/ryedLUN9UAf/","title":"linux无人值守安装之找不到pxelinux.0文件的解决办法","section":"📚 我的文章","content":" none\n解决思路 # yum search pxelinux 通过上面的方法我们找到了syslinux包\n然后安装syslinux\nyum install syslinux 最后找到pxelinux.0文件\nls /usr/share/syslinux/pxelinux.0 "},{"id":114,"href":"/blog/macos/HkGt88E9U0f/","title":"Mac terminal清除历史命令纪录","section":"📚 我的文章","content":" Linux传统清除方式并没能解决\nhistory -c\n我用的iterm2 + zsh\n常用history命令：\n查看历史命令纪录:\nhistory…\nLinux传统清除方式并没能解决\nhistory -c 我用的iterm2 + zsh\n常用history命令： # 查看历史命令纪录:\nhistory\nhistory | less 使用 !! 执行上一条命令\n!! 使用 !foo 执行以 foo 开头的命令\n!foo 使用 !n 执行第 n 个命令\n!100\n可以尝试下这样来解决：\n在terminal中输入hist，然后tab键，出来以下这些\nHISTCHARS HISTFILE HISTSIZE\n了解历史记录的大小:\necho $HISTSIZE 历史记录的保存位置:\necho $HISTFILE # 查看history文件存放地址 echo \u0026gt; ~/.zsh_history # 清空 好了，退出terminal，重新登录检查一下即可 退出后，再history检查一下\n"},{"id":115,"href":"/blog/macos/H1JGLLVcL0G/","title":"MacOS 10.12 解决找不到任何来源设置","section":"📚 我的文章","content":" 安装第三方软件必备技能\n打开终端 ( 终端在 应用程序 - 实用工具内 )\n输入以下命令并回车\nsudo spctl --master-disable 然后查看问题是否解决， 偏好设置-\u0026gt;安全性与隐私-\u0026gt;通用-\u0026gt;任何来源\n"},{"id":116,"href":"/blog/linux/Sky_LU458CM/","title":"mediainfo获取ts文件大小和信息不准确（MPEG-TS：检测文件的序列）的解决办法","section":"📚 我的文章","content":" 解决mediainfo获取ts媒体信息不准确问题\n场景 # 在/opt/目录下总共有200多个文件文件名分别如下：\n/opt/2017LPL夏季赛第01集.ts\n/opt/2017LPL夏季赛第02集.ts\n/opt/2017LPL夏季赛第03集.ts\n…\n/opt/2017LPL夏季赛第227集.ts\n/opt/2017LPL夏季赛第228集.ts\n错误结果 # mediainfo /opt/2017LPL夏季赛第01集.ts General ID : 1 (0x1) Complete name : Z:\\vrs\\new_upload\\2018-01-16\\2017LPL夏季赛第01集.ts CompleteName_Last : Z:\\vrs\\new_upload\\2018-01-16\\2017LPL夏季赛第228集.ts Format : MPEG-TS File size : 560 GiB Duration : 53mn 32s Overall bit rate mode : Constant Overall bit rate : 1 496 Mbps Video ID : 100 (0x64) Menu ID : 1 (0x1) Format : AVC Format/Info : Advanced Video Codec Format profile : High@L4.0 Format settings, CABAC : No Format settings, ReFrames : 2 frames Codec ID : 27 Duration : 53mn 32s Bit rate mode : Constant Bit rate : 1 422 Mbps Nominal bit rate : 7 800 Kbps / 7 800 Kbps Width : 1 920 pixels Height : 1 080 pixels Display aspect ratio : 16:9 Frame rate : 25.000 fps Color space : YUV Chroma subsampling : 4:2:0 Bit depth : 8 bits Scan type : Progressive Bits/(Pixel*Frame) : 27.431 Stream size : 532 GiB (95%) Writing library : x264 core 148 r2705 3f5ed56 Encoding settings : cabac=0 / ref=2 / deblock=1:0:0 / analyse=0x3:0x13 / me=hex / subme=7 / psy=1 / psy_rd=1.00:0.00 / mixed_ref=1 / me_range=16 / chroma_me=1 / trellis=1 / 8x8dct=1 / cqm=0 / deadzone=21,11 / fast_pskip=1 / chroma_qp_offset=-2 / threads=34 / lookahead_threads=5 / sliced_threads=0 / nr=0 / decimate=1 / interlaced=0 / bluray_compat=0 / constrained_intra=0 / bframes=3 / b_pyramid=0 / b_adapt=1 / b_bias=0 / direct=1 / weightb=1 / open_gop=0 / weightp=1 / keyint=32 / keyint_min=16 / scenecut=40 / intra_refresh=0 / rc_lookahead=32 / rc=cbr / mbtree=1 / bitrate=7800 / ratetol=1.0 / qcomp=0.60 / qpmin=0 / qpmax=69 / qpstep=4 / vbv_maxrate=7800 / vbv_bufsize=1560 / nal_hrd=cbr / filler=1 / ip_ratio=1.40 / aq=1:1.00 Audio ID : 101 (0x65) Menu ID : 1 (0x1) Format : MPEG Audio Format version : Version 1 Format profile : Layer 2 Codec ID : 3 Duration : 53mn 32s Bit rate mode : Constant Bit rate : 96.0 Kbps Channel(s) : 2 channels Sampling rate : 48.0 KHz Compression mode : Lossy Delay relative to video : -10ms Stream size : 36.8 MiB (0%) Menu ID : 4096 (0x1000) Menu ID : 1 (0x1) Duration : 53mn 32s List : 100 (0x64) (AVC) / 101 (0x65) (MPEG Audio) Service name : RM_SERVICE_01 Service provider : RealMagic Service type : digital television 正确结果 # mediainfo /opt/2017LPL夏季赛第01集.ts General ID : 1 (0x1) Complete name : /data/stb/product/vrs/new_upload/./2018-01-16/2017LPL夏季赛第01集.ts Format : MPEG-TS File size : 2.58 GiB Duration : 43mn 42s Overall bit rate mode : Constant Overall bit rate : 8 464 Kbps Video ID : 100 (0x64) Menu ID : 1 (0x1) Format : AVC Format/Info : Advanced Video Codec Format profile : High@L4.0 Format settings, CABAC : No Format settings, ReFrames : 2 frames Codec ID : 27 Duration : 43mn 42s Bit rate mode : Constant Bit rate : 7 800 Kbps / 7 800 Kbps Width : 1 920 pixels Height : 1 080 pixels Display aspect ratio : 16:9 Frame rate : 25.000 fps Color space : YUV Chroma subsampling : 4:2:0 Bit depth : 8 bits Scan type : Progressive Bits/(Pixel*Frame) : 0.150 Stream size : 2.43 GiB (94%) Writing library : x264 core 148 r2705 3f5ed56 Encoding settings : cabac=0 / ref=2 / deblock=1:0:0 / analyse=0x3:0x13 / me=hex / subme=7 / psy=1 / psy_rd=1.00:0.00 / mixed_ref=1 / me_range=16 / chroma_me=1 / trellis=1 / 8x8dct=1 / cqm=0 / deadzone=21,11 / fast_pskip=1 / chroma_qp_offset=-2 / threads=34 / lookahead_threads=5 / sliced_threads=0 / nr=0 / decimate=1 / interlaced=0 / bluray_compat=0 / constrained_intra=0 / bframes=3 / b_pyramid=0 / b_adapt=1 / b_bias=0 / direct=1 / weightb=1 / open_gop=0 / weightp=1 / keyint=32 / keyint_min=16 / scenecut=40 / intra_refresh=0 / rc_lookahead=32 / rc=cbr / mbtree=1 / bitrate=7800 / ratetol=1.0 / qcomp=0.60 / qpmin=0 / qpmax=69 / qpstep=4 / vbv_maxrate=7800 / vbv_bufsize=1560 / nal_hrd=cbr / filler=1 / ip_ratio=1.40 / aq=1:1.00 Audio ID : 101 (0x65) Menu ID : 1 (0x1) Format : MPEG Audio Format version : Version 1 Format profile : Layer 2 Codec ID : 3 Duration : 43mn 42s Bit rate mode : Constant Bit rate : 96.0 Kbps Channel(s) : 2 channels Sampling rate : 48.0 KHz Compression mode : Lossy Delay relative to video : -10ms Stream size : 30.0 MiB (1%) Menu ID : 4096 (0x1000) Menu ID : 1 (0x1) Duration : 43mn 42s List : 100 (0x64) (AVC) / 101 (0x65) (MPEG Audio) Service name : RM_SERVICE_01 Service provider : RealMagic Service type : digital television 解决办法 # 根据作者的github上提交的代码描述\nhttps://github.com/MediaArea/MediaInfoLib/commit/78f739893c85d4b1397276ef15badd160907b7aa\nvim \u0026#34;Source/MediaInfo/Multiple/File_MpegTs.cpp\u0026#34; void File_MpegTs::Streams_Accept() { ... if (!IsSub) { ... //TestContinuousFileNames(); ... } } 我们只要将”TestContinuousFileNames();“这行注释掉即可解决默认获取ts文件序列问题\n"},{"id":117,"href":"/blog/linux/SyqLL45IRz/","title":"nginx 简单配置及使用教程","section":"📚 我的文章","content":" none\n常用配置 # #运行用户 user nobody; #启动进程,通常设置成和cpu的数量相等 worker_processes 1; #全局错误日志及PID文件 #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; #工作模式及连接数上限 events { #epoll是多路复用IO(I/O Multiplexing)中的一种方式, #仅用于linux2.6以上内核,可以大大提高nginx的性能 use epoll; #单个后台worker process进程的最大并发链接数 worker_connections 1024; # 并发总数是 worker_processes 和 worker_connections 的乘积 # 即 max_clients = worker_processes * worker_connections # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4 为什么 # 为什么上面反向代理要除以4，应该说是一个经验值 # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000 # worker_connections 值的设置跟物理内存大小有关 # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数 # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右 # 我们来看看360M内存的VPS可以打开的文件句柄数是多少： # $ cat /proc/sys/fs/file-max # 输出 34336 # 32000 \u0026lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内 # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置 # 使得并发总数小于操作系统可以打开的最大文件数目 # 其实质也就是根据主机的物理CPU和内存进行配置 # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。 # ulimit -SHn 65535 } http { #设定mime类型,类型由mime.type文件定义 include mime.types; default_type application/octet-stream; #设定日志格式 log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log logs/access.log main; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件， #对于普通应用，必须设为 on, #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off， #以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; tcp_nodelay on; #开启gzip压缩 gzip on; gzip_disable \u0026#34;MSIE [1-6].\u0026#34;; #设定请求缓冲 client_header_buffer_size 128k; large_client_header_buffers 4 128k; #设定虚拟主机配置 server { #侦听80端口 listen 80; #定义使用 www.nginx.cn访问 server_name www.nginx.cn; #定义服务器的默认网站根目录位置 root html; #设定本虚拟主机的访问日志 access_log logs/nginx.access.log main; #默认请求 location / { #定义首页索引文件的名称 index index.php index.html index.htm; } # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html { } #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ { #过期30天，静态文件不怎么更新，过期可以设大一点， #如果频繁更新，则可以设置得小一点。 expires 30d; } #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置. location ~ .php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } #禁止访问 .htxxx 文件 location ~ /.ht { deny all; } } } 其他配置 # #定义Nginx运行的用户和用户组 user www www; #nginx进程数，建议设置为等于CPU总核心数。 worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ] error_log /var/log/nginx/error.log info; #进程文件 pid /var/run/nginx.pid; #一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。 worker_rlimit_nofile 65535; #工作模式与连接数上限 events { #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） worker_connections 65535; } #设定http服务器 http { include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型 #charset utf-8; #默认编码 server_names_hash_bucket_size 128; #服务器名字的hash表大小 client_header_buffer_size 32k; #上传文件大小限制 large_client_header_buffers 4 64k; #设定请求缓 client_max_body_size 8m; #设定请求缓 sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。 tcp_nopush on; #防止网络阻塞 tcp_nodelay on; #防止网络阻塞 keepalive_timeout 120; #长连接超时时间，单位是秒 #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用 upstream blog.ha97.com { #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; } #虚拟主机的配置 server { #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.ha97.com ha97.com; index index.html index.htm index.php; root /data/www/ha97; location ~ .*\\.(php|php5)?$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; } #图片缓存时间设置 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 10d; } #JS和CSS缓存时间设置 location ~ .*\\.(js|css)?$ { expires 1h; } #日志格式设定 log_format access \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; $http_x_forwarded_for\u0026#39;; #定义本虚拟主机的访问日志 access_log /var/log/nginx/ha97access.log access; #对 \u0026#34;/\u0026#34; 启用反向代理 location / { proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 } #设定查看Nginx状态的地址 location /NginxStatus { stub_status on; access_log on; auth_basic \u0026#34;NginxStatus\u0026#34;; auth_basic_user_file conf/htpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 } #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; } #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$ { expires 15d; } location ~ .*.(js|css)?$ { expires 1h; } } } "},{"id":118,"href":"/blog/linux/ByS8884qI0M/","title":"nginx+php+ThinkPHP环境常见错误总结","section":"📚 我的文章","content":" 错误一\n2017/09/07 16:39:18 [error] 21753#0: *26 FastCGI sent in stderr: “Primary s…\n错误一 # 2017/09/07 16:39:18 [error] 21753#0: *26 FastCGI sent in stderr: \u0026#34;Primary script unknown\u0026#34; while reading response header from upstream, client: 172.31.26.114, server: localhost, request: \u0026#34;GET /1.php HTTP/1.1\u0026#34;, upstream: \u0026#34;fastcgi://127.0.0.1:9000\u0026#34;, host: \u0026#34;10.200.8.220:8000\u0026#34; 解决版本 # 在server节点下添加以下配置\nroot /var/www/web; index index.php index.html index.htm; location ~ \\.php$ { try_files $uri = 404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi.conf; } ThinkPHP配置 # 假如网站的根目录是/var/www/web，如果ThinkPHP的网站在/var/www/web/Test目录配置如下\nlocation /Test/ { if (!-e $request_filename){ rewrite ^/Test/(.*)$ /Test/index.php?s=$1 last; } } location ~ \\.php/?.*$ { try_files $uri = 404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi.conf; #设置PATH_INFO并改写SCRIPT_FILENAME,SCRIPT_NAME服务器环境变量 #set $fastcgi_script_name2 $fastcgi_script_name; #if ($fastcgi_script_name ~ \u0026#34;^(.+\\.php)(/.+)$\u0026#34;) { # set $fastcgi_script_name2 $1; # set $path_info $2; #} #fastcgi_param PATH_INFO $path_info; #fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name2; #fastcgi_param SCRIPT_NAME $fastcgi_script_name2; } 如果是放在根目录下\nlocation / { if (!-e $request_filename){ rewrite ^/(.*)$ /index.php?s=$1 last; } } location ~ \\.php/?.*$ { try_files $uri = 404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi.conf; #设置PATH_INFO并改写SCRIPT_FILENAME,SCRIPT_NAME服务器环境变量 #set $fastcgi_script_name2 $fastcgi_script_name; #if ($fastcgi_script_name ~ \u0026#34;^(.+\\.php)(/.+)$\u0026#34;) { # set $fastcgi_script_name2 $1; # set $path_info $2; #} #fastcgi_param PATH_INFO $path_info; #fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name2; #fastcgi_param SCRIPT_NAME $fastcgi_script_name2; } 最后来个完整的例子\nuser root; worker_processes auto; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; root /var/www/web; index index.php index.html index.htm; location / { index index.htm index.html index.php; } location /Test/ { if (!-e $request_filename){ rewrite ^/Test/(.*)$ /Test/index.php?s=$1 last; } } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } location ~ \\.php/?.*$ { try_files $uri = 404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi.conf; #设置PATH_INFO并改写SCRIPT_FILENAME,SCRIPT_NAME服务器环境变量 #set $fastcgi_script_name2 $fastcgi_script_name; #if ($fastcgi_script_name ~ \u0026#34;^(.+\\.php)(/.+)$\u0026#34;) { # set $fastcgi_script_name2 $1; # set $path_info $2; #} #fastcgi_param PATH_INFO $path_info; #fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name2; #fastcgi_param SCRIPT_NAME $fastcgi_script_name2; } } } "},{"id":119,"href":"/blog/linux/H1v8I4cLAf/","title":"Nginx反向代理、镜像缓存加速及负载均衡的配置","section":"📚 我的文章","content":" none\nNginx已经具备Squid所拥有的Web缓存加速功能、清除指定URL缓存的功能。而在性能上，Nginx对多核CPU的利用，胜过Squid不少。另外，在反向代理、负载均衡、健康检查、后端服务器故障转移、Rewrite重写、易用性上，Nginx也比Squid强大得多。\n这使得一台Nginx可以同时作为“负载均衡服务器”与“Web缓存服务器”来使用。\n常规安装nginx的过程，这里就不详述了，这里只介绍nginx的配置文件的配置\n一、nginx反向代理的基本格式，也就是最简单反向代理配置文件 # server { listen 80; server_name vpsmm.com; location / { proxy_pass http://cache.vpsmm.com/; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 二、如果你需要使用CDN镜像加速的功能 # 也就是前端域名和后端域名相同，可以使用下面两种方法：\n（一）源地址直接填写IP # server { listen 80; server_name vpsmm.com; location / { proxy_pass http://192.168.0.110; //如果不是80端口，可以加上端口http://IP:81 proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } （二）采用HTTP Upstream模块server指令 # upstream cdn { server 192.168.0.110:80 weight=5; server 192.168.0.121:80 weight=5; } server { listen 80; server_name vpsmm.com; location / { proxy_pass http://cdn; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 三、最简单的前端全缓存+反向代理脚本 # mkdir /home/cache/path -p #新建2个目录，放置缓存文件 mkdir /home/cache/temp -p 修改 /usr/local/nginx/conf/nginx.conf 新增以下代码，主要是缓存相关设置，请放置于 http{ ##这里 } 中，一般加在\nlog_format 上面或下面均可：\nclient_body_buffer_size 512k; proxy_connect_timeout 5; proxy_read_timeout 60; proxy_send_timeout 5; proxy_buffer_size 16k; proxy_buffers 4 64k; proxy_busy_buffers_size 128k; proxy_temp_file_write_size 128k; proxy_temp_path /home/cache/temp; proxy_cache_path /home/cache/path levels=1:2 keys_zone=cache_one:500m inactive=7d max_size=30g; #500m是内存占用，7d是7天无访问删除，30g是缓存占具硬盘空间\n以下为虚拟主机配置文件，可另存成 .conf 放置于 vhost 下面：\nserver { listen 80; server_name vpsmm.com; #主机名 location / { proxy_cache cache_one; proxy_cache_valid 200 304 3d; #正常状态缓存时间3天 proxy_cache_key $host$uri$is_args$args; proxy_pass http://cache.vpsmm.com/; #反代的网站 proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; expires 10d; #默认10天缓存 access_log /home/wwwlogs/vpsmm.log access; #日志文件 } } 点击几下网站，df -sh 命令，查看 /home/cache\n目录大小，即可测试是否缓存成功。此脚本为前端全缓存，后端动态更新后，前端不会自动修改。可手动清理cache目录下文件。这个方法，可以用纯静态的形式来防CC，如果你的动态博客，受到CC攻击，可以尝试一下。\n以下为完整的nginx虚拟主机的配置文件\nlog_format jjhr.net \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; $http_x_forwarded_for\u0026#39;; # 反向代理参数，具体自行搜索按需配置吧 proxy_connect_timeout 5; proxy_read_timeout 60; proxy_send_timeout 5; proxy_buffer_size 16k; proxy_buffers 4 64k; proxy_busy_buffers_size 128k; proxy_temp_file_write_size 128k; # 配置临时目录、缓存路径（注意要先建立这2个目录，要在同一个硬盘分区，注意权限） proxy_temp_path /var/cache/nginx_proxy_temp 1 2; proxy_cache_path /var/cache/nginx_proxy_cache levels=1:2 keys_zone=jjhr:48m inactive=12d max_size=2g; # keys_zone=jjhr:48m 表示这个 zone 名称为 jjhr，分配的内存大小为 48MB # levels=1:2 表示缓存目录的第一级目录是 1 个字符，第二级目录是 2 个字符 # inactive=12d 表示这个zone中的缓存文件如果在 12 天内都没有被访问，那么文件会被cache manager 进程删除 # max_size=2G 表示这个zone的硬盘容量为 2G server{ listen 80; server_name jjhr.net *.jjhr.net; index index.html index.php; location / { #------------------------------------- proxy_cache jjhr; proxy_cache_key \u0026#34;$scheme://$host$request_uri\u0026#34;; proxy_cache_valid 200 304 7d; proxy_cache_valid 301 3d; proxy_cache_valid any 10s; expires 1d; #-------------------------------------- proxy_pass http://205.185.115.53; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } # wordpress 后台目录不缓存 location /wp-admin { if ( !-e $request_filename) { proxy_pass http://205.185.115.53; } } access_log /var/log/nginx/jjhr.net.log main; } 四、多个服务器负载均衡的配置 # http { …….. client_max_body_size 300m ; // 允许客户端请求的最大单个文件字节数 client_body_buffer_size 128k; // 缓冲区代理缓冲用户端请求的最大字节数，可以理解为先保存到本地再传给用户 proxy_connect_timeout 600; // 跟后端服务器连接的超时时间_发起握手等候响应超时时间 proxy_read_timeout 600; // 连接成功后_等候后端服务器响应时间_其实已经进入后端排队之中等候处理 proxy_send_timeout 600; proxy_buffer_size 16k; // 会保存用户的头信息，供nginx进行规则处理 proxy_buffers 4 32k; // 告诉nginx保存单个用的几个buffer最大用多大空间 proxy_busy_buffers_size 64k; proxy_max_temp_file_size 64k; // proxy缓存临时文件的大小 upstream clubsrv { server 192.168.0.110:80 weight=5; server 192.168.0.121:80 weight=5; } upstream mysrv { server 192.168.0.32:80 weight=2; server 127.0.0.1:8000 weight=8; } server { listen 80; server_name club.xywy.com; charset gbk; root /www; access_log logs/bba.log combined; //下面是第一个域名，使用clubsrv的代理 location / { proxy_next_upstream http_502 http_504 error timeout invalid_header; // 如果后端服务器返回502、504或执行超时等错误，自动将请求转发到upstream另一台服务器 proxy_pass http://clubsrv; // 与上面upstream自己命名的名字填写一致 proxy_redirect off; proxy_set_header Host club.xywy.com; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; // nginx在前端做代理，后端的日志会显示127.0.0.1，上面配置可以显示用户真实IP（还需装第三方软件，见下面的详细说明） index index.htm index.html index.php; } //下面是第二个域名，使用mysrv的代理，访问www.sum.com/message目录下的 server { listen 80; server_name www.sum.com; location /message { proxy_pass http://mysrv; proxy_set_header Host $host; // 访问这个域名的，只有mysrv 本机可以访问 } //访问除了/message之外的www.sum.com/ 地址， location / { proxy_pass http://mysrv; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; 下面的配置，与上面错误返回的效果相同，这里可以不写。 error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } Nginx负载均衡指令 # Nginx属于软件的七层负载均衡（lvs是软件的四层负载均衡的代表），七层负载均衡软件还有L7SW（Layer7\nswitching）、HAProxy等。支持负载均衡的模块是Http Upstream。下面介绍此模块及他下面的几个指令\nHTTP Upstream模块 # （1）ip_hash指令 # 当对后端的多台动态应用服务器做负载均衡时，ip_hash指令将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上。这样，当来自某ip用户在Sever\nA上登录后，再访问该站点的其他URL时，能保证访问仍在Server A上。\n如果不加ip_hash，加入用户在Server A上登录，再访问该站点其他URL，就有可能跳转到后端的Sever\nB、C…..，而session记录在A上，B、C上没有，就会提示用户未登录。\n注意：但这种访问不能保证后端服务器的负载均衡，可能后端有些server接受到的请求多，有些server接受的少，设置的权重值不起作用。\n建议如果后端的动态应用程序服务器能做到session共享，而不用nginx上配置ip_hash的方式。\nupstream mysrv { ip_hash; server 192.168.0.110:80 weight=2; server 127.0.0.1:8000 down; server 192.168.0.212:80 weight=8; } （2）server指令 # 该指令用语指定后端服务器的名称和参数。服务器的名称可以是一个域名，一个ip，端口号或UNIX Socket。\n参数介绍：\nweight=number ： 设置服务器权重，权重值越高，被分配到客户端请求数越多。默认为1；\nmax_fails=numbser ：\n在fail_timeout指定的时间内对后端服务器请求失败的次数，如果检测到后端服务器无法连接及发生错误（404除外），则标记为失败。如果没有设置，默认为1。设置为0则关闭这项检查。\nfail_timeout=time ： 在经历参数max_fails设置的失败次数后，暂停的时间。 down ： 表示服务器为永久离线状态。 Backup ： 仅仅在非backup服务器全部down或繁忙的时候才启用。 配置如下： upstream mysrv { ip_hash; server www.xywy.com weight=2; server 127.0.0.1:8000 down; server 192.168.0.212:80 max_fails=3 fail_timeout=30s; server unix:/tmp/bakend3; } "},{"id":120,"href":"/blog/linux/rykY88V58CG/","title":"nignx修改最大上传文件大小限制","section":"📚 我的文章","content":" none\nlocation / { root html; index index.html index.htm; client_max_body_size 1000m; } “client_max_body_size”设置一下上传的最大上限,然后重启nginx即可。\n"},{"id":121,"href":"/blog/linux/HkXeLI4cIAG/","title":"rabbitmq 消息队列安装和配置","section":"📚 我的文章","content":" erlang # 首先安装erlang语言环境\nyum install erlang -y rabbitMQ # rabbitMQ下载地址：直达安装方法:\nrpm -ivh --force --nodeps rabbitmq-server-3.6.0-1.noarch.rpm 或者 yum localinstall rabbitmq-server-3.6.0-1.noarch.rpm -y 启动服务 # /etc/init.d/rabbitmq-server start rabbitmq-plugins enable rabbitmq_management 配置主备 # 同步cookie # chmod 777 /var/lib/rabbitmq/.erlang.cookie scp /var/lib/rabbitmq/.erlang.cookie Go02:/var/lib/rabbitmq/.erlang.cookie chmod 400 /var/lib/rabbitmq/.erlang.cookie 添加节点 # rabbitmqctl stop_app rabbitmqctl reset rabbitmqctl join_cluster [--ram] rabbit@Go01 //此处的Go01为主节点的hostname,需要在/etc/hosts中指定 rabbitmqctl start_app 删除节点 # rabbitmqctl stop_app rabbitmqctl forget_cluster_node rabbit@rabbit1 修改类型 # rabbitmqctl stop_app rabbitmqctl change_cluster_node_type ram rabbitmqctl start_app 添加用户 # rabbitmqctl add_user admin admin 添加权限: rabbitmqctl set_permissions -p \u0026#34;/\u0026#34; admin \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; 删除测试用户: rabbitmqctl delete_user guest 赋予其administrator角色： rabbitmqctl set_user_tags admin administrator 修改配置 # //防止服务端异常中断恢复后镜像队列不能恢复的问题 vim /etc/rabbitmq/rabbitmq.conf [ {rabbit,[{tcp_listeners,[5672]}, {cluster_partition_handling, autoheal}]} ]. #不要忘记最后面的那个点号哦！ 环境变量 # touch /etc/rabbitmq/rabbitmq-env.conf#输入 RABBITMQ_NODENAME=FZTEC-240088 节点名称 RABBITMQ_NODE_IP_ADDRESS=127.0.0.1 监听IP RABBITMQ_NODE_PORT=5672 监听端口 RABBITMQ_LOG_BASE=/data/rabbitmq/log 日志目录 RABBITMQ_PLUGINS_DIR=/data/rabbitmq/plugins 插件目录 RABBITMQ_MNESIA_BASE=/data/rabbitmq/mnesia 后端存储目录 RabbitMQ的用户角色分类 # none、management、policymaker、monitoring、administrator\nRabbitMQ各类角色描述： # none # 不能访问 management plugin\nmanagement # 用户可以通过AMQP做的任何事外加： 列出自己可以通过AMQP登入的virtual hosts 查看自己的virtual hosts中的queues,\nexchanges 和 bindings 查看和关闭自己的channels 和 connections 查看有关自己的virtual\nhosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。\npolicymaker # management可以做的任何事外加： 查看、创建和删除自己的virtual hosts所属的policies和parameters\nmonitoring # management可以做的任何事外加： 列出所有virtual hosts，包括他们不能登录的virtual hosts\n查看其他用户的connections和channels 查看节点级别的数据如clustering和memory使用情况 查看真正的关于所有virtual\nhosts的全局的统计信息\nadministrator # policymaker和monitoring可以做的任何事外加: 创建和删除virtual hosts 查看、创建和删除users\n查看创建和删除permissions 关闭其他用户的connections\n"},{"id":122,"href":"/blog/linux/HybPILE5U0z/","title":"RabbitMQ三种Exchange模式(fanout,direct,topic)的性能比较","section":"📚 我的文章","content":" none\nRabbitMQ中，所有生产者提交的消息都由Exchange来接受，然后Exchange按照特定的策略转发到Queue进行存储\nRabbitMQ提供了四种Exchange：fanout,direct,topic,header\nheader模式在实际使用中较少，本文只对前三种模式进行比较。\n性能排序：fanout \u0026gt; direct \u0026raquo; topic。比例大约为11：10：6\n一.Direct Exchange # 任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。\n1.一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。\n2.这种模式下不需要将Exchange进行任何绑定(binding)操作\n3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。\n4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。\n二.Fanout Exchange # 任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。\n1.可以理解为路由表的模式\n2.这种模式不需要RouteKey\n3.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定。\n4.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。\n三.Topic Exchange # 任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上\n1.这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的队列。\n2.这种模式需要RouteKey，也许要提前绑定Exchange与Queue。\n3.在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。\n4.“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。\n5.同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息。\n原文地址：http://www.gaort.com/index.php/archives/366\n"},{"id":123,"href":"/blog/linux/H1z5LL49I0z/","title":"RabbitMQ性能优化","section":"📚 我的文章","content":" none\nrabbitmq.config # rabbitmq.config文件时rabbitmq的配置文件，他遵守Erlang配置文件定义。\nrabbitmq.config文件位置：\nUnix $RABBITMQ_HOME/etc/rabbitmq Windows %APPDATA%\\RabbitMQ\\ 例子如下：\n[ {mnesia, [{dump_log_write_threshold, 1000}]}, {rabbit, [{tcp_listeners, [5673]}]} ]. Memory配置和设置 # RabbitMQ在使用当前机器的40%以上内存时候，会发出内存警告，并组织RabbitMQ所有连接（producer连接）。直到RabbitMQ将当前数据刷入到硬盘或者消息被客户端消费。\n当Erlang的垃圾回收机制运行起来（这是一个非常耗费资源的工作），会消费两倍内存。（默认是80%的内存）。因此需要操作系统支持OS swap和page\nfile.\n注意：在32为架构下，每个进程被限制为2GB。通常64架构系统限制每个进程为256TB，64位windows限制为8TB。就算在64位操作系统下，32位的进程只能用2GB内存。\n因此强烈推荐使用64bit Erlang vm和64bit os。\n当RabbitMQ不能识别你的系统的时候，你必须对vm_memory_high_watermark进行修改。\n当rabbitmq不能识别系统的时候，会设置内存为1024MB。所以rabbitmq实际使用的内存仅仅410MB。\n当系统为8GB的时候，我们可以这是vm_memory_high_watermark=3，那么我们实际可以使用的内存为3GB。\n配置Memory Threshold文件\n默认配置RabbitMQ的vm_memory_high_watermark=0.4\n[{rabbit, [{vm_memory_high_watermark, 0.4}]}]. 举例说明： # 当机器内存为16GB，那么40%，为6.4GB。主要当32系统时候，实际可以使用的内存为2GB，那么实际可以使用的内存为820MB。\n当我配置vm_memory_high_watermark=0 我们可以阻止所有消息发送。\n注意：这个百分比，最好不要修改。应为Erlang VM回收的时候会占据系统内存的80%。已经达到系统临界区。不要设置超过50%的百分比。\n配置Page Threshold文件 # 当内存中的数据达到一定数量后，他需要被page out出来。 默认配置\nvm_memory_high_watermark_paging_ratio=0.5。也就是vm_memory_high_watermark0.5。假设总内存8GB，0.4的使用内存是3.2。那么当内存叨叨3.20.5=1.6GB时候，系统将会大量置换页面。\n因此我们可以将页面置换的百分比调高。设置为0.75\n[{rabbit, [{vm_memory_high_watermark_paging_ratio, 0.75}, {vm_memory_high_watermark, 0.4}]}]. 注意：我们可以将vm_memory_high_watermark_paging_ratio设置超过1.0，那么不会发生内存换页的情况，也就是说，当内存超过总内存的40%之后，将会阻止所有producer产生消息。\n配置命令 # rabbitmqctl set_vm_memory_high_watermark 0.4 这是内存使用占总内存数的百分比\nrabbitmqctl set_vm_memory_high_watermark_paging_ratio 0.75 设置rabbitmq使用内存达到rabbitmq可用内存百分比，就出发页面交换功能。\nrabbitmqctl status 获得系统配置。\nDisk配置和设置 # RabbitMQ会在硬盘空间不够的时候，阻止Producer发送消息。这样可以保证RabbitMQ可以再任何时候，将内存中的数据置换到磁盘中来。通常会将硬盘剩余数据大小设置为机器的总内存大小。\n全局流控制会被触发，当可用总硬盘容量已经低于配置信息。broker数据库将会最少10秒检查一下警告是否发出或者清除。\n在RabbitMQ启动的后，会打印disk limit限制，但是不能识别的平台就不能显示信息。\n注意：当RabbitMQ是集群情况下，当其中有一台机器硬盘不足的时候，所有节点的producer链接都会被阻止。\nRabbitMQ会定期价检查总磁盘可用空间的大小。通常时间为10秒每次，当限制快被达到时候，RabbitMQ检查的时候会达到10次/s.\n配置Disk Free Space Limit # 我们可以直接设置硬盘的最小限制。也可以设置相对内存大小的设置。\n先设置磁盘1GB限制\n[{rabbit, [{disk_free_limit, 1000000000}]}]. 在这时相对于机器总内存\n[{rabbit, [{disk_free_limit, {mem_relative, 1.0}}]}]. Erlang的Hipe优化 # 可以设置hipe_compiles设置。可以看到有20-50%的性能优化。而你只需要付出1分钟左右的延迟启动。\nHiPE需要你检查是否编译进入你的Erlang安装环境。Ubuntu，需要安装erlang-base-hipe.默认有些平台不支持。如果Erlang VM\nsegfaults,请关闭这个选项。\n[{rabbit, [{hipe_compile, true}]}]. 参考：http://www.rabbitmq.com/configure.html#configuration-file\n"},{"id":124,"href":"/blog/linux/rkCKI84cLAG/","title":"rabbitmq之机器机器全部断电恢复记录","section":"📚 我的文章","content":"今天遇到一个rabbitmq集群同时断电，当机器全部启动的时候发现rabbitmq无法正常启动，然后发现如下日志。\n=INFO REPORT==== 25-Apr-2018::11:11:07 === Starting RabbitMQ 3.5.3 on Erlang R16B03-1 Copyright (C) 2007-2014 GoPivotal, Inc. Licensed under the MPL. See http://www.rabbitmq.com/ =INFO REPORT==== 25-Apr-2018::11:11:07 === node : rabbit@WIN-ACC2J7AGNM9 home dir : C:\\Users\\Administrator config file(s) : e:/RabbitMQ Data/rabbitmq.config (not found) cookie hash : kR4NuIdBr2n8/4Qt9uIgqQ== log : E:/RabbitMQ Data/log/rabbit@WIN-ACC2J7AGNM9.log sasl log : E:/RabbitMQ Data/log/rabbit@WIN-ACC2J7AGNM9-sasl.log database dir : e:/RabbitMQ Data/db/rabbit@WIN-ACC2J7AGNM9-mnesia =WARNING REPORT==== 25-Apr-2018::11:11:07 === Kernel poll (epoll, kqueue, etc) is disabled. Throughput and CPU utilization may worsen. =INFO REPORT==== 25-Apr-2018::11:11:08 === Memory limit set to 13095MB of 32738MB total. =INFO REPORT==== 25-Apr-2018::11:11:08 === Disk free limit set to 50MB =INFO REPORT==== 25-Apr-2018::11:11:08 === Limiting to approx 8092 file handles (7280 sockets) =INFO REPORT==== 25-Apr-2018::11:11:38 === Timeout contacting cluster nodes: [\u0026#39;rabbit@WIN-2W6NDAIZBIA\u0026#39;]. BACKGROUND ========== This cluster node was shut down while other nodes were still running. To avoid losing data, you should start the other nodes first, then start this one. To force this node to start, first invoke \u0026#34;rabbitmqctl force_boot\u0026#34;. If you do so, any changes made on other cluster nodes after this one was shut down may be lost. DIAGNOSTICS =========== attempted to contact: [\u0026#39;rabbit@WIN-2W6NDAIZBIA\u0026#39;] rabbit@WIN-2W6NDAIZBIA: * connected to epmd (port 4369) on WIN-2W6NDAIZBIA * epmd reports: node \u0026#39;rabbit\u0026#39; not running at all no other nodes on WIN-2W6NDAIZBIA * suggestion: start the node current node details: - node name: \u0026#39;rabbit@WIN-ACC2J7AGNM9\u0026#39; - home dir: C:\\Users\\Administrator - cookie hash: kR4NuIdBr2n8/4Qt9uIgqQ== 关键的地方在于中间的这段说明：\nThis cluster node was shut down while other nodes were still running. To avoid losing data, you should start the other nodes first, then start this one. To force this node to start, first invoke \u0026#34;rabbitmqctl force_boot\u0026#34;. If you do so, any changes made on other cluster nodes after this one was shut down may be lost. 只要执行rabbitmqctl force_boot，将所有的节点全部强制设置成最后一个关闭的即可。\n"},{"id":125,"href":"/blog/linux/ry3FIUV58AM/","title":"rabbitmq之修改数据和log目录位置位置","section":"📚 我的文章","content":" vim /etc/rabbitmq/rabbitmq-env.conf\nI am a complete /etc/rabbitmq/rabbitmq-e… # vim /etc/rabbitmq/rabbitmq-env.conf # I am a complete /etc/rabbitmq/rabbitmq-env.conf file. # Comment lines start with a hash character. # This is a /bin/sh script file - use ordinary envt var syntax MNESIA_BASE=/data/rabbitmq/mnesia LOG_BASE=/data/logs/rabbitmq "},{"id":126,"href":"/blog/ffmpeg/S1EdILNqU0M/","title":"Rematrix is needed between 10 channels and 7.1(wide) but there is not enough","section":"📚 我的文章","content":" 解决办法\n将10个声道拆分成10个音轨\nffmpeg -i INPUTFILE -filter_complex “[0:a]pan=mono|c0=c0[…\n解决办法 # 将10个声道拆分成10个音轨\nffmpeg -i INPUTFILE -filter_complex \u0026#34;[0:a]pan=mono|c0=c0[a0];[0:a]pan=mono|c0=c1[a1];[0:a]pan=mono|c0=c2[a2];[0:a]pan=mono|c0=c3[a3];[0:a]pan=mono|c0=c4[a4];[0:a]pan=mono|c0=c5[a5];[0:a]pan=mono|c0=c6[a6];[0:a]pan=mono|c0=c7[a7];[0:a]pan=mono|c0=c8[a8];[0:a]pan=mono|c0=c9[a9]\u0026#34; -map \u0026#34;[a0]\u0026#34; -map \u0026#34;[a1]\u0026#34; -map \u0026#34;[a2]\u0026#34; -map \u0026#34;[a3]\u0026#34; -map \u0026#34;[a4]\u0026#34; -map \u0026#34;[a5]\u0026#34; -map \u0026#34;[a6]\u0026#34; -map \u0026#34;[a7]\u0026#34; -map \u0026#34;[a8]\u0026#34; -map \u0026#34;[a9]\u0026#34; -vn -c:a pcm_s24le OUTPUTFILE ffmpeg -i INPUTFILE -vn -c:a pcm_s24le -map 0:1 -filter:a:0 \u0026#34;pan=mono|c0=c0\u0026#34; -map 0:1 -filter:a:1 \u0026#34;pan=mono|c0=c1\u0026#34; -map 0:1 -filter:a:2 \u0026#34;pan=mono|c0=c2\u0026#34; -map 0:1 -filter:a:3 \u0026#34;pan=mono|c0=c3\u0026#34; -map 0:1 -filter:a:4 \u0026#34;pan=mono|c0=c4\u0026#34; -map 0:1 -filter:a:5 \u0026#34;pan=mono|c0=c5\u0026#34; -map 0:1 -filter:a:6 \u0026#34;pan=mono|c0=c6\u0026#34; -map 0:1 -filter:a:7 \u0026#34;pan=mono|c0=c7\u0026#34; -map 0:1 -filter:a:8 \u0026#34;pan=mono|c0=c8\u0026#34; -map 0:1 -filter:a:9 \u0026#34;pan=mono|c0=c9\u0026#34; OUTPUTFILE "},{"id":127,"href":"/blog/linux/B11rILN5UAz/","title":"Ubuntu 阿里云镜像源","section":"📚 我的文章","content":" 准备工作 # sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak #备份 修改配置 # 14.04 # sudo vim /etc/apt/sources.list #修改 deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 16.04 # sudo vim /etc/apt/sources.list #修改 deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial universe deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties deb http://archive.canonical.com/ubuntu xenial partner deb-src http://archive.canonical.com/ubuntu xenial partner deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 更新缓存 # sudo apt-get update #更新列表 "},{"id":128,"href":"/blog/linux/HyGHL8E5LRM/","title":"ubuntu编译安装vim及配制方法","section":"📚 我的文章","content":" 一个非常好用的vim配置文件\nvim简介 # Vim是一个类似于Vi的著名的功能强大、高度可定制的文本编辑器，在Vi的基础上改进和增加了很多特性。VIM是自由软件。\nVim普遍被推崇为类Vi编辑器中最好的一个，事实上真正的劲敌来自Emacs的不同变体。1999\n年Emacs被选为Linuxworld文本编辑分类的优胜者，Vim屈居第二。但在2000年2月Vim赢得了Slashdot\nBeanie的最佳开放源代码文本编辑器大奖，又将Emacs推至二线， 总的来看， Vim和Emacs在文本编辑方面都是非常优秀的。\n准备环境 # sudo apt-get install libncurses5-dev libgnome2-dev libgnomeui-dev \\ libgtk2.0-dev libatk1.0-dev libbonoboui2-dev \\ libcairo2-dev libx11-dev libxpm-dev libxt-dev python-dev \\ python3-dev ruby-dev liblua5.1 lua5.1-dev libperl-dev git 移除vim # dpkg -l | grep vim sudo apt-get remove vim-common vim-tiny 下载源码 # git clone https://github.com/vim/vim.git # 编译vim # cd vim ./configure --with-features=huge \\ --enable-multibyte \\ --enable-rubyinterp=yes \\ --enable-pythoninterp=yes \\ --with-python-config-dir=/usr/lib/python2.7/config \\ --enable-python3interp=yes \\ --with-python3-config-dir=/usr/lib/python3.5/config \\ --enable-perlinterp=yes \\ --enable-luainterp=yes \\ --enable-gui=gtk2 --enable-cscope --prefix=/usr make VIMRUNTIMEDIR=/usr/share/vim/vim80 sudo make install 配制vim # sh \u0026lt;(curl https://j.mp/spf13-vim3 -L) "},{"id":129,"href":"/blog/linux/BJ8I8E9U0M/","title":"vim 快速入门手册","section":"📚 我的文章","content":" vim常见操作\n图示 # ![vi-vim-cheat-sheet-sch.png](/static/uploads/BJ8I8E9U0M/img/vi-vim-cheat-\nsheet-sch_SyLsV8yY4.png)\n一、移动光标 # 1、左移h、右移l、下移j、上移k\n2、向下翻页ctrl + f，向上翻页ctrl + b\n3、向下翻半页ctrl + d，向上翻半页ctrl + u\n4、移动到行尾$，移动到行首0（数字），移动到行首第一个字符处^\n5、移动光标到下一个句子 ），移动光标到上一个句子（\n6、移动到段首{，移动到段尾}\n7、移动到下一个词w，移动到上一个词b\n8、移动到文档开始gg，移动到文档结束G\n9、移动到匹配的{}.().[]处%\n10、跳到第n行 ngg 或 nG 或 :n\n11、移动光标到屏幕顶端H，移动到屏幕中间M，移动到底部L\n12、读取当前字符，并移动到本屏幕内下一次出现的地方 *\n13、读取当前字符，并移动到本屏幕内上一次出现的地方 #\n二、查找替换 # 1、光标向后查找关键字 #或者g#\n2、光标向前查找关键字 或者g\n3、当前行查找字符 fx, Fx, tx, Tx\n4、基本替换 :s/s1/s2 （将下一个s1替换为s2）\n5、全部替换 :%s/s1/s2 6、只替换当前行 :s/s1/s2/g\n7、替换某些行 :n1,n2 s/s1/s2/g\n8、搜索模式为 /string，搜索下一处为n，搜索上一处为N\n9、制定书签 mx, 但是看不到书签标记，而且只能用小写字母\n10、移动到某标签处 `x，1旁边的键\n11、移动到上次编辑文件的位置 `. PS：.代表一个任意字符 *代表一个或多个字符的重复\n三、编辑操作 # 1、光标后插入a, 行尾插入A\n2、后插一行插入o，前插一行插入O\n3、删除字符插入s， 删除正行插入S\n4、光标前插入i，行首插入I\n5、删除一行dd，删除后进入插入模式cc或者S\n6、删除一个单词dw，删除一个单词进入插入模式cw\n7、删除一个字符x或者dl，删除一个字符进入插入模式s或者cl\n8、粘贴p，交换两个字符xp，交换两行ddp\n9、复制y，复制一行yy\n10、撤销u，重做ctrl + r，重复.\n11、智能提示 ctrl + n 或者 ctrl + p\n12、删除motion跨过的字符，删除并进入插入模式 c{motion}\n13、删除到下一个字符跨过的字符，删除并进入插入模式，不包括x字符 ctx\n14、删除当前字符到下一个字符处的所有字符，并进入插入模式，包括x字符，cfx\n15、删除motion跨过的字符，删除但不进入插入模式 d{motion}\n16、删除motion跨过的字符，删除但不进入插入模式，不包括x字符 dtx\n17、删除当前字符到下一个字符处的所有字符，包括x字符 dfx\n18、如果只是复制的情况时，将12-17条中的c或d改为y\n19、删除到行尾可以使用D或C\n20、拷贝当前行 yy或者Y\n21、删除当前字符 x\n22、粘贴 p\n23、可以使用多重剪切板，查看状态使用:reg，使用剪切板使用”，例如复制到w寄存器，”wyy，或者使用可视模式v”wy\n24、重复执行上一个作用使用.\n25、使用数字可以跨过n个区域，如y3x，会拷贝光标到第三个x之间的区域，3j向下移动3行\n26、在编写代码的时候可以使用]p粘贴，这样可以自动进行代码缩进\n27、 \u0026raquo; 缩进所有选择的代码\n28、 \u0026laquo; 反缩进所有选择的代码\n29、gd 移动到光标所处的函数或变量的定义处\n30、K 在man里搜索光标所在的词\n31、合并两行 J\n32、若不想保存文件，而重新打开 :e!\n33、若想打开新文件 :e filename，然后使用ctrl + ^进行文件切换\n四、窗口操作 # 1、分隔一个窗口:split或者:vsplit\n2、创建一个窗口:new或者:vnew\n3、在新窗口打开文件:sf {filename}\n4、关闭当前窗口:close\n5、仅保留当前窗口:only\n6、到左边窗口 ctrl + w, h\n7、到右边窗口 ctrl + w, l\n8、到上边窗口 ctrl + w, k\n9、到下边窗口 ctrl + w, j\n10、到顶部窗口 ctrl + w, t\n11、到底部窗口 ctrl + w, b\n五、宏操作 # 1、开始记录宏操作q[a-z]，按q结束，保存操作到寄存器[a-z]中\n2、@[a-z]执行寄存器[a-z]中的操作\n3、@@执行最近一次记录的宏操作\n六、可视操作 # 1、进入块可视模式 ctrl + v\n2、进入字符可视模式 v\n3、进入行可视模式 V\n4、删除选定的块 d\n5、删除选定的块然后进入插入模式 c\n6、在选中的块同是插入相同的字符 IESC\n七、跳到声明 # 1、[[ 向前跳到顶格第一个{\n2、[] 向前跳到顶格第一个}\n3、]] 向后跳到顶格的第一个{\n4、]] 向后跳到顶格的第一个}\n5、[{ 跳到本代码块的开头\n6、]} 跳到本代码块的结尾\n八、挂起操作 # 1、挂起Vim ctrl + z 或者 :suspend\n2、查看任务 在shell中输入 jobs\n3、恢复任务 fg [job number]（将后台程序放到前台）或者 bg [job number]（将前台程序放到后台）\n4、执行shell命令 :!command\n5、开启shell命令 :shell，退出该shell exit\n6、保存vim状态 :mksession name.vim\n7、恢复vim状态 :source name.vim\n8、启动vim时恢复状态 vim -S name.vim\n"},{"id":130,"href":"/blog/linux/BJrx8LE98CG/","title":"vsftpd 配置方法及访问控制","section":"📚 我的文章","content":" vsftpd 详细配置说明\nvsftpd常用配置 # #关闭匿名用户访问权限 anonymous_enable=NO #开启本地用户权限 local_enable=YES #开启写权限 write_enable=YES #设置侦听端口 listen_port=21 #写文件时的umask local_umask=002 #被动模式及开放端口段 #pasv_enable=yes #pasv_min_port=30000 #pasv_max_port=50000 #超时时间 #idle_session_timeout=6000000 #data_connection_timeout=6000000 dirmessage_enable=YES xferlog_enable=YES connect_from_port_20=YES xferlog_std_format=YES chroot_local_user=YES chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_list listen=YES pam_service_name=vsftpd userlist_enable=YES tcp_wrappers=YES use_localtime=YES reverse_lookup_enable=NO #convert_charset_enable=0 #local_charset=UTF8 #remote_charset=GB2312 #double_377=1 创建账户\nuseradd -M -s /sbin/nologin -d /mnt/usernamefile/ username for i in name1 name2 name3;do useradd -M -s /sbin/nologin -d /mnt/$i/ $i;done for i in name1 name2 name3;do echo \u0026#34;$i\u0026#34;123 | passwd --stdin $i ;done 创建目录 # mkdir usernamefile chown username:username usernamefile for i in name1 name2 name3;do mkdir /mnt/$i;done for i in name1 name2 name3;do chown $i:$i /mnt/$i/;done chmod -R 770 * vsftpd被动模式 # 1、开启被动模式 # vim vsftpd.conf pasv_enable=YES #开启被动模式 pasv_min_port=3000 #随机最小端口 pasv_max_port=4000 #随机最大端口 2、加载内核 # modprobe ip_conntrack_ftp modprobe ip_nat_ftp 3、防火墙 # vim /etc/sysconfig/iptables 在*filter下加入下 -A OUTPUT -p tcp --sport 3000:4000 -j ACCEPT -A INPUT -p tcp --dport 3000:4000 -j ACCEPT iptables-restore \u0026lt; /etc/sysconfig/iptables 加载iptables配置 vsftpd虚拟用户 # 1、vsftpd安装 # yum -y install vsftpd #vsftpd软件 yum -y install db4-utils #生成虚拟用户认证数据文件命令 2、配置vsftp # vim /etc/vsftpd/vsftpd.conf listen=YES #独立运行vsftpd anonymous_enable=NO #限制匿名用户登录 dirmessage_enable=YES xferlog_enable=YES xferlog_file=/var/log/vsftpd.log xferlog_std_format=YES chroot_list_enable=YES #限制虚拟用户切换目录 chroot_list_file=/etc/vsftpd/chroot_list #限制切换目录的用户列表 chroot_local_user=YES guest_enable=YES #开启虚拟用户认证 guest_username=ftp #映射的真实用户 user_config_dir=/etc/vsftpd/vsftpd_user_conf #虚拟用户配置目录 pam_service_name=vsftpd.vu #vsftpd认证的pam认证模块 local_enable=YES 3、虚拟用户db # cd /etc/vsftpd vim user.txt yuangang #用户名 123456 #密码 db_load -T -t hash -f user.txt /etc/vsftpd/vsftpd_login.db chmod 600 /etc/vsftpd/vsftpd_login.db # 配置pam认证 vim /etc/pam.d/vsftpd.vu auth required /lib/security/pam_userdb.so db=/etc/vsftpd/vsftpd_login account required /lib/security/pam_userdb.so db=/etc/vsftpd/vsftpd_login vim /etc/vsftpd/chroot_list #限制虚拟用户切换目录 ftp yuangang 4、配置虚拟用户 # cd /etc/vsftpd/vsftpd_user_conf vim yuangang write_enable=YES anon_world_readable_only=NO anon_upload_enable=YES anon_mkdir_write_enable=YES anon_other_write_enable=YES local_root=/data/httpd/yuangang # 建立虚拟用户ftp目录 mkdir /data/httpd/yuangang chown -R ftp.root /data/httpd chmod o+rw /data/httpd/yuangang vsftpd cmds_allowed # cmds_allowed=ABOR,CWD,LIST,MDTM,MKD,NLST, PASS,PASV,PORT,PWD,QUIT,RETR,RMD,RNFR, RNTO,SITE,SIZE,STOR,TYPE,USER,ACCT, APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST 注意:一定不能使用换行和空格，不然就没效果..\n全部参数 # # ABOR - abort a file transfer 取消文件传输 # CWD - change working directory 更改目录 # DELE - delete a remote file 删除文件 # LIST - list remote files 列目录 # MDTM - return the modification time of a file 返回文件的更新时间 # MKD - make a remote directory 新建文件夹 # NLST - name list of remote directory # PASS - send password # PASV - enter passive mode # PORT - open a data port 打开一个传输端口 # PWD - print working directory 显示当前工作目录 # QUIT - terminate the connection 退出 # RETR - retrieve a remote file 下载文件 # RMD - remove a remote directory # RNFR - rename from # RNTO - rename to # SITE - site-specific commands # SIZE - return the size of a file 返回文件大小 # STOR - store a file on the remote host 上传文件 # TYPE - set transfer type # USER - send username # less common commands: # ACCT* - send account information # APPE - append to a remote file # CDUP - CWD to the parent of the current directory # HELP - return help on using the server # MODE - set transfer mode # NOOP - do nothing # REIN* - reinitialize the connection # STAT - return server status # STOU - store a file uniquely # STRU - set file transfer structure # SYST - return system type 常用参数 # # CWD - change working directory 更改目录 # LIST - list remote files 列目录 # MKD - make a remote directory 新建文件夹 # NLST - name list of remote directory # PWD - print working directory 显示当前工作目录 # RETR - retrieve a remote file 下载文件 # STOR - store a file on the remote host 上传文件 # DELE - delete a remote file 删除文件 # RMD - remove a remote directory 删除目录 # RNFR - rename from 重命名 # RNTO - rename to 重命名 以上是常用的一些参数，大家对照学习一下！\n几个例子 # 1、只能上传。不能下载、删除、重命名。 cmds_allowed＝FEAT,REST,CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,SIZE,STOR,TYPE,USER,ACCT, APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST 2、只能下载。不能上传、删除、重命名。write_enable=NO 3、只能上传、删除、重命名。不能下载。download_enable＝NO 4、只能下载、删除、重命名。不能上传。 cmds_allowed=FEAT,REST,CWD,LIST,MDTM,MKD,NLST,PASS,PASV,PORT,PWD,QUIT,RMD,RNFR,RNTO, RETR,DELE,SIZE,TYPE,USER,ACCT,APPE,CDUP,HELP,MODE,NOOP,REIN,STAT,STOU,STRU,SYST 日志格式解析 # Sun Feb 23 22:08:26 2014 | 6 | 212.73.193.130 | 1023575 |\n/Lille_IconSP/win_230214_52_11.jpg | b| _| i| r| sipafranch| ftp| 0| *| c\n记录 含义\nSun Feb 23 22:08:26 2014 FTP传输时间\n6 传输文件所用时间。单位/秒\n212.73.193.130 ftp客户端名称/IP\n1023575 传输文件大小。单位/Byte\n/Lille_IconSP/win_230214_52_11.jpg 传输文件名，包含路径\nb 传输方式： a以ASCII方式传输; b以二进制(binary)方式传输;\n_ 特殊处理标志位：”_“不做任何处理；”C”文件是压缩格式；”U”文件非压缩格式；”T”文件是tar格式；\ni 传输方向：”i”上传；”o”下载；\nr 用户访问模式：“a”匿名用户；”g”访客模式；”r”系统中用户;\nsipafranch 登录用户名\nftp 服务名称，一般都是ftp\n0 认证方式：”0”无；”1”RFC931认证；\n认证用户id，”*“表示无法获取id c 完成状态：”i”传输未完成；”c”传输已完成；\n"},{"id":131,"href":"/blog/linux/SJ_88EqU0M/","title":"web运维相关查询命令","section":"📚 我的文章","content":" none\n1. 查看TCP连接状态 # netstat -nat |awk \u0026#39;{print $6}\u0026#39;|sort|uniq -c|sort -rn netstat -n | awk \u0026#39;/^tcp/ {++S[$NF]};END {for(a in S) print a, S[a]}\u0026#39; 或 netstat -n | awk \u0026#39;/^tcp/ {++state[$NF]}; END {for(key in state) print key,\u0026#34;\\t\u0026#34;,state[key]}\u0026#39; netstat -n | awk \u0026#39;/^tcp/ {++arr[$NF]};END {for(k in arr) print k,\u0026#34;\\t\u0026#34;,arr[k]}\u0026#39; netstat -n |awk \u0026#39;/^tcp/ {print $NF}\u0026#39;|sort|uniq -c|sort -rn netstat -ant | awk \u0026#39;{print $NF}\u0026#39; | grep -v \u0026#39;[a-z]\u0026#39; | sort | uniq -c (以上每一行实现的效果基本相同，在此列出不同的写法，方便对脚本写法的更深理解）\n2. 查找请求数请20个IP（常用于查找攻来源） # netstat -anlp|grep 80|grep tcp|awk \u0026#39;{print $5}\u0026#39;|awk -F: \u0026#39;{print $1}\u0026#39;|sort|uniq -c|sort -nr|head -n20 netstat -ant |awk \u0026#39;/:80/{split($5,ip,\u0026#34;:\u0026#34;);++A[ip[1]]}END{for(i in A) print A[i],i}\u0026#39; |sort -rn|head -n20 3. 用tcpdump嗅探80端口的访问看看谁最高 # tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F\u0026#34;.\u0026#34; \u0026#39;{print $1\u0026#34;.\u0026#34;$2\u0026#34;.\u0026#34;$3\u0026#34;.\u0026#34;$4}\u0026#39; | sort | uniq -c | sort -nr |head -20 4. 查找较多time_wait连接 # netstat -n|grep TIME_WAIT|awk \u0026#39;{print $5}\u0026#39;|sort|uniq -c|sort -rn|head -n20 5. 找查较多的SYN连接 # netstat -an | grep SYN | awk \u0026#39;{print $5}\u0026#39; | awk -F: \u0026#39;{print $1}\u0026#39; | sort | uniq -c | sort -nr | more 6. 根据端口列进程 # netstat -ntlp | grep 80 | awk \u0026#39;{print $7}\u0026#39; | cut -d/ -f1 7. 查看有多少个PHP-CGI进程活动 # netstat -anp | grep php-cgi | grep ^tcp | wc -l 8.查看PHP-CGI占用内存的总数 # total=0; for i in `ps -C php-cgi -o rss=`; do total=$(($total+$i)); done; echo \u0026#34;PHP-CGI Memory usage: $total kb\u0026#34; "},{"id":132,"href":"/blog/linux/Sykc8UNqICz/","title":"zabbix之无法启动问题及解决办法","section":"📚 我的文章","content":" none\n1、\n错误提示\nzabbix_agentd [1749]: cannot create PID file [/var/run/zabbix/zabbix_agentd.pid]: [2] No such file or directory 解决方法\nmkdir /var/run/zabbix/ chown zabbix.zabbix /var/run/zabbix/ chmod g+w /var/run/zabbix/ touch /var/run/zabbix/zabbix_agentd.pid /etc/init.d/zabbix-agent restart ps aux | grep zabbix "},{"id":133,"href":"/blog/linux/SytNL84q8Af/","title":"阿里云ECS Linux的rc.local（开机启动）设置不生效","section":"📚 我的文章","content":" none\n使用场景 # 前段时间使用阿里云的ecs，将一些开机启动的命令写到/etc/rc.local里面，发现不生效。经过一番查询和搜索之后，最后发现一个坑，居然要给这个文件设置执行权限才生效。\n解决方法 # chmod +x /etc/rc.local "},{"id":134,"href":"/blog/ffmpeg/SyD7UIEcUAM/","title":"简析Android集成FFMPEG推流","section":"📚 我的文章","content":" 如今，视频直播行业在中国算是比较热门。在刚刚过去的2015年，视频直播成为互联网行业最抢眼的领域之一。从游戏到秀场，从传统的网页端到移动互联网，各大直播平台包括…\n如今，视频直播行业在中国算是比较热门。在刚刚过去的2015年，视频直播成为互联网行业最抢眼的领域之一。从游戏到秀场，从传统的网页端到移动互联网，各大直播平台包括斗鱼、熊猫tv、虎牙战旗还有纯移动端的映客、易直播等，群雄割据。言归正转，今天我们讲解的是Android\n端简要集成FFMPEG进行推流。\n推流基本流程 # 一般情况下推流的基本流程如上。\nFFmpeg # 说到推流就不得不提大名鼎鼎的FFMPEG了，FFmpeg是一个开源免费跨平台的视频和音频流方案，属于自由软件，采用LGPL或GPL许可证（依据你选择的组件）。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多codec都是从头开发的。诸如微信的小视频，映客、斗鱼等均是在FFmpeg基础上开发而来，可见FFmpeg之强大。一下是解压微信的apk的截图。\nFFmpeg 在Android中的使用 # FFmpeg要想在Android就必须要编译成Android上能使用so动态链接库（下称so库）。具体编译方法可以参考github官方提供源码。编译过程大约在30分钟左右。以下是笔者编译好的so库。\nFFmpeg主要分为8大模块： # libavcodec：用于各种类型声音/图像编解码； libavdevice：用于视频采集访问摄像头等 libavfilter：用做滤镜处理 libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能； libswresample：用于重采样； libavutil：包含一些公共的工具函数； libswscale：用于视频场景比例缩放、色彩映射转换； libpostproc：用于后期效果处理； JNI开发调用FFmpeg # 我们先看看我们使用到的FFmpegUtils工具类，主要用于加载native方法：\npublic class FFmpegUtils { //加载so库 static{ System.loadLibrary(\u0026#34;avutil-54\u0026#34;); System.loadLibrary(\u0026#34;swresample-1\u0026#34;); System.loadLibrary(\u0026#34;avcodec-56\u0026#34;); System.loadLibrary(\u0026#34;avformat-56\u0026#34;); System.loadLibrary(\u0026#34;swscale-3\u0026#34;); System.loadLibrary(\u0026#34;postproc-53\u0026#34;); System.loadLibrary(\u0026#34;avfilter-5\u0026#34;); System.loadLibrary(\u0026#34;avdevice-56\u0026#34;); System.loadLibrary(\u0026#34;sffstreamer\u0026#34;); } /* * 把本地的音视频数据通过rtmp协议发送到流媒体服务器上 *@param input *@param output */ public native int stream(String input, String output); } 接下来我们就是我们的重头戏JNI调用FFmpeg\n#include \u0026#34;libavcodec/avcodec.h\u0026#34; #include \u0026#34;libavformat/avformat.h\u0026#34; #include \u0026#34;libavutil/log.h\u0026#34; #define LOGE(format, ...) __android_log_print(ANDROID_LOG_ERROR, \u0026#34;(\u0026gt;_\u0026lt;)\u0026#34;, format, ##__VA_ARGS__) #define LOGI(format, ...) __android_log_print(ANDROID_LOG_INFO, \u0026#34;(^_^)\u0026#34;, format, ##__VA_ARGS__) JNIEXPORT jint JNICALL Java_org_loofer_ffmpegstreamer_MainActivity_stream (JNIEnv *env, jobject obj, jstring input_jstr, jstring output_jstr) { //java string -\u0026gt; c char* //视频文件所在路径 const char* input_cstr = (*env)-\u0026gt;GetStringUTFChars(env,input_jstr, NULL)); //推送的流媒体地址 const char* output_cstr = (*env)-\u0026gt;GetStringUTFChars(env,output_jstr, NULL)); //封装格式(读入，写出)（解封装，得到frame） AVFormatContext *inFmtCtx = NULL, *outFmtCtx = NULL; AVOutputFormat *ofmt = NULL; AVPacket pkt; //注册组件 av_register_all(); //初始化网络 avformat_network_init(); //Input if ((ret = avformat_open_input(\u0026amp;inFmtCtx, input_str, 0, 0)) \u0026lt; 0) { LOGE( \u0026#34;Could not open input file.\u0026#34;); goto end; } //获取文件信息 if ((ret = avformat_find_stream_info(inFmtCtx, 0)) \u0026lt; 0) { LOGE( \u0026#34;Failed to retrieve input stream information\u0026#34;); goto end; } //获取视频的索引位置 int videoindex=-1; for(i=0; i\u0026lt;inFmtCtx-\u0026gt;nb_streams; i++) if(inFmtCtx-\u0026gt;streams[i]-\u0026gt;codec-\u0026gt;codec_type==AVMEDIA_TYPE_VIDEO){ videoindex=i; break; } //输出封装格式，推送flv封装格式的视频流 avformat_alloc_output_context2(\u0026amp;outFmtCtx, NULL, \u0026#34;flv\u0026#34;,output_cstr); //RTMP //avformat_alloc_output_context2(\u0026amp;outFmtCtx, NULL, \u0026#34;mpegts\u0026#34;, output_cstr);//UDP if (!outFmtCtx) { LOGE( \u0026#34;Could not create output context/n\u0026#34;); ret = AVERROR_UNKNOWN; goto end; } for (i = 0; i \u0026lt; inFmtCtx-\u0026gt;nb_streams; i++) { //解码器，解码上下文保持一致 AVStream *in_stream = inFmtCtx-\u0026gt;streams[i]; AVStream *out_stream = avformat_new_stream(outFmtCtx, in_stream-\u0026gt;codec-\u0026gt;codec); if (!out_stream) { LOGE( \u0026#34;Failed allocating output stream/n\u0026#34;); ret = AVERROR_UNKNOWN; goto end; } //复制解码器上下文的 设置 ret = avcodec_copy_context(out_stream-\u0026gt;codec, in_stream-\u0026gt;codec); if (ret \u0026lt; 0) { LOGE( \u0026#34;Failed to copy context from input to output stream codec context/n\u0026#34;); goto end; } //全局的header out_stream-\u0026gt;codec-\u0026gt;codec_tag = 0; if (outFmtCtx-\u0026gt;oformat-\u0026gt;flags \u0026amp; AVFMT_GLOBALHEADER) out_stream-\u0026gt;codec-\u0026gt;flags |= CODEC_FLAG_GLOBAL_HEADER; } //打开输出的AVIOContext IO流上下文 ofmt = outFmtCtx-\u0026gt;oformat; //Open output URL if (!(ofmt-\u0026gt;flags \u0026amp; AVFMT_NOFILE)) { ret = avio_open(\u0026amp;outFmtCtx-\u0026gt;pb, output_cstr, AVIO_FLAG_WRITE); if (ret \u0026lt; 0) { LOGE( \u0026#34;Could not open output URL \u0026#39;%s\u0026#39;\u0026#34;, output_cstr); goto end; } } //先写一个头 ret = avformat_write_header(outFmtCtx, NULL); if (ret \u0026lt; 0) { LOGE( \u0026#34;Error occurred when opening output URL/n\u0026#34;); goto end; } int frame_index=0; int64_t start_time=av_gettime(); while (1) { AVStream *in_stream, *out_stream; //Get an AVPacket ret = av_read_frame(inFmtCtx, \u0026amp;pkt); if (ret \u0026lt; 0) break; //FIX：No PTS (Example: Raw H.264) //raw stream 裸流 //PTS:Presentation Time Stamp 解码后视频帧要在什么时候取出来 //DTS:送入解码器后什么时候标识进行解码 if(pkt.pts==AV_NOPTS_VALUE){ //Write PTS AVRational time_base1=inFmtCtx-\u0026gt;streams[videoindex]-\u0026gt;time_base; //Duration between 2 frames (us) int64_t calc_duration=(double)AV_TIME_BASE/av_q2d(inFmtCtx-\u0026gt;streams[videoindex]-\u0026gt;r_frame_rate); //Parameters pkt.pts=(double)(frame_index*calc_duration)/(double)(av_q2d(time_base1)*AV_TIME_BASE); pkt.dts=pkt.pts; pkt.duration=(double)calc_duration/(double)(av_q2d(time_base1)*AV_TIME_BASE); } //读入速度比较快，可以在这里调整读取速度减轻服务器压力 if(pkt.stream_index==videoindex){ AVRational time_base=inFmtCtx-\u0026gt;streams[videoindex]-\u0026gt;time_base; AVRational time_base_q={1,AV_TIME_BASE}; int64_t pts_time = av_rescale_q(pkt.dts, time_base, time_base_q); int64_t now_time = av_gettime() - start_time; if (pts_time \u0026gt; now_time) av_usleep(pts_time - now_time); } in_stream = inFmtCtx-\u0026gt;streams[pkt.stream_index]; out_stream = outFmtCtx-\u0026gt;streams[pkt.stream_index]; /* copy packet */ //Convert PTS/DTS pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-\u0026gt;time_base, out_stream-\u0026gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX); pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-\u0026gt;time_base, out_stream-\u0026gt;time_base, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX); pkt.duration = av_rescale_q(pkt.duration, in_stream-\u0026gt;time_base, out_stream-\u0026gt;time_base); pkt.pos = -1; //Print to Screen if(pkt.stream_index==videoindex){ LOGE(\u0026#34;Send %8d video frames to output URL/n\u0026#34;,frame_index); frame_index++; } //写数据 //ret = av_write_frame(outFmtCtx, \u0026amp;pkt); ret = av_interleaved_write_frame(outFmtCtx, \u0026amp;pkt); if (ret \u0026lt; 0) { LOGE( \u0026#34;Error muxing packet/n\u0026#34;); break; } av_free_packet(\u0026amp;pkt); } //写结尾 av_write_trailer(outFmtCtx); end: //释放自愿 avformat_close_input(\u0026amp;inFmtCtx); /* 关闭输出流 */ if (outFmtCtx \u0026amp;\u0026amp; !(ofmt-\u0026gt;flags \u0026amp; AVFMT_NOFILE)) avio_close(outFmtCtx-\u0026gt;pb); avformat_free_context(outFmtCtx); if (ret \u0026lt; 0 \u0026amp;\u0026amp; ret != AVERROR_EOF) { LOGE( \u0026#34;Error occurred./n\u0026#34;); return -1; } return 0; } 函数简单介绍 # av_register_all():注册所有组件。 avformat_open_input():打开输入视频文件。 avformat_find_stream_info():获取视频文件信息。 avcodec_find_decoder():查找解码器。 avcodec_open2():打开解码器。 av_read_frame():从输入文件读取一帧压缩数据。 avcodec_decode_video2():解码一帧压缩数据。 avcodec_close():关闭解码器。 avformat_close_input():关闭输入视频文件 "},{"id":135,"href":"/blog/linux/HJqtULE5I0z/","title":"排查linux根目录空间占用与实际空间不符","section":"📚 我的文章","content":" none\n发现问题 # 首先使用”df -Th”查看根目录的空间使用和”du -sh /“的结果进行对比。\n排查问题 # 第一种情况 # 文件被删掉，但是写这个文件的进程没退出\nlsof -n|grep delete 使用以上命令得到相关的进程，然后使用得到的pid找到对应的程序，然后重启程序或kill掉即可释放被删除文件的空间。\n第二种情况 # lsof -n|grep delete 没有得到任何返回结果。\n那么我们首先查看下根目录的文件系统，如果是“xfs”,那么可以使用\nxfs_db -c frag -r /dev/sdxx 查看碎片的占比，如果较高的话，那么我们应该整理下xfs的碎片了。\nxfs_fsr /dev/sdxx #整理碎片 然后你再“df”看看释放空间已经释放了。\n备注 # xfs虽然性能比较好，但是稳定性还是有所欠缺，不是很建议使用。\n如果以上的方法没有解决你的问题或者你还有其他情况，欢迎留言一起探讨。\n"}]