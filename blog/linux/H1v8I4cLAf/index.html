<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
none

Nginx已经具备Squid所拥有的Web缓存加速功能、清除指定URL缓存的功能。而在性能上，Nginx对多核CPU的利用，胜过Squid不少。另外，在反向代理、负载均衡、健康检查、后端服务器故障转移、Rewrite重写、易用性上，Nginx也比Squid强大得多。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://notes.zhangwenbing.com/blog/linux/H1v8I4cLAf/"><meta property="og:site_name" content="张文兵的笔记"><meta property="og:title" content="Nginx反向代理、镜像缓存加速及负载均衡的配置"><meta property="og:description" content=" none
Nginx已经具备Squid所拥有的Web缓存加速功能、清除指定URL缓存的功能。而在性能上，Nginx对多核CPU的利用，胜过Squid不少。另外，在反向代理、负载均衡、健康检查、后端服务器故障转移、Rewrite重写、易用性上，Nginx也比Squid强大得多。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-05-14T04:45:01+08:00"><meta property="article:modified_time" content="2018-05-14T04:45:01+08:00"><meta property="article:tag" content="Linux"><title>Nginx反向代理、镜像缓存加速及负载均衡的配置 | 张文兵的笔记</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://notes.zhangwenbing.com/blog/linux/H1v8I4cLAf/><link rel=stylesheet href=/book.min.7bc0bb908f28131671779537cc0c91a39075ed4cba93497f05888d37375171ce.css integrity="sha256-e8C7kI8oExZxd5U3zAyRo5B17Uy6k0l/BYiNNzdRcc4=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.9cd03a0d8b5b3ae9a9b7d7066805a088c7effbfb06ee82fad5ad1d579dab6251.js integrity="sha256-nNA6DYtbOumpt9cGaAWgiMfv+/sG7oL61a0dV52rYlE=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>张文兵的笔记</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-6d1804e163fb7f5fbc576b94719a59cb class=toggle>
<label for=section-6d1804e163fb7f5fbc576b94719a59cb class="flex justify-between"><a role=button>👨🏼‍💻 编程相关</a></label><ul><li><input type=checkbox id=section-f56428119b0aac71309abf8dfea134ce class=toggle>
<label for=section-f56428119b0aac71309abf8dfea134ce class="flex justify-between"><a role=button>📔 C++</a></label><ul><li><input type=checkbox id=section-fb47b341e1fcc9c423db5ed573183d82 class=toggle>
<label for=section-fb47b341e1fcc9c423db5ed573183d82 class="flex justify-between"><a role=button>🔖 MacOS相关</a></label><ul><li><a href=/notes/2024/06/06/sf4ff6x8cuyhvzougj9dwg/>📝 MacOS签名</a></li><li><a href=/notes/2024/05/28/3txbbb7iruppjsg4p7rwnb/>📝 MacOS堆栈大小</a></li></ul></li><li><input type=checkbox id=section-b76e207ac5e871ff00bceef2a05945c7 class=toggle>
<label for=section-b76e207ac5e871ff00bceef2a05945c7 class="flex justify-between"><a role=button>🔖 Qt</a></label><ul><li><a href=/notes/2024/08/01/rnc4n7cfifidx8ca2rhjme/>📝 QML鼠标事件</a></li><li><a href=/notes/2024/08/06/ny773erqjgbzmzgfikfvds/>📝 QML虚拟列表</a></li></ul></li><li><input type=checkbox id=section-03639da61c682690825d49325c54c7e8 class=toggle>
<label for=section-03639da61c682690825d49325c54c7e8 class="flex justify-between"><a role=button>🔖 Python</a></label><ul><li><a href=/notes/2025/02/10/7auahqg8nnxm5ydhxzqrnr/>📝 调用Python代码</a></li><li><a href=/notes/2025/02/10/gqci9riugfetribe6j6fou/>📝 调用Python方法</a></li><li><a href=/notes/2025/02/10/pkdrvn9md3ggfmbxahx4ef/>📝 注册Python模块</a></li></ul></li></ul></li><li><input type=checkbox id=section-aea9addc7ea0cf58a2c2c9ec52f959c9 class=toggle>
<label for=section-aea9addc7ea0cf58a2c2c9ec52f959c9 class="flex justify-between"><a role=button>📔 Git</a></label><ul><li><a href=/notes/2024/03/11/j3c62fv8dglvf2kg975zlv/>📝 标签操作</a></li><li><a href=/notes/2024/03/14/5kqlzqjqawbxf2t6vusxar/>📝 删除Commit</a></li><li><a href=/blog/git/WNYzxj6GR/>📝 git之删除远程分支</a></li><li><a href=/blog/git/-fZeBsu3T/>📝 git更新.gitignore</a></li><li><a href=/blog/git/H1Krv6b-4/>📝 git修改历史cimmit信息</a></li><li><a href=/blog/git/By9OI51xN/>📝 git基础笔记</a></li><li><a href=/blog/git/Hk6GGp6cQ/>📝 Git回滚到某个commit</a></li></ul></li></ul></li><li><input type=checkbox id=section-caf3b688bb818cc6cfc82165db78eba5 class=toggle>
<label for=section-caf3b688bb818cc6cfc82165db78eba5 class="flex justify-between"><a role=button>♻️ 回收归档</a></label><ul><li><input type=checkbox id=section-4a72fedb3d7dfc18dbbcab83511bf75a class=toggle>
<label for=section-4a72fedb3d7dfc18dbbcab83511bf75a class="flex justify-between"><a role=button>📔 Rust</a></label><ul><li><input type=checkbox id=section-8aa26b33a0315c1be70924160dd1a92c class=toggle>
<label for=section-8aa26b33a0315c1be70924160dd1a92c class="flex justify-between"><a role=button>🔖 学习笔记</a></label><ul><li><a href=/notes/2024/03/06/e3ksq3zkmps14gcxuirwzx/>📝 所有权</a></li><li><a href=/notes/2024/03/06/o4arkqgfnqygr5ckif2gkk/>📝 借用与引用</a></li></ul></li></ul></li></ul></li><li><a href=/links/>🤝 友情链接</a></li></ul><ul><li><a href=/articles/>📚 我的文章</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Nginx反向代理、镜像缓存加速及负载均衡的配置</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#一nginx反向代理的基本格式也就是最简单反向代理配置文件><strong>一、nginx反向代理的基本格式，也就是最简单反向代理配置文件</strong></a></li><li><a href=#二如果你需要使用cdn镜像加速的功能><strong>二、如果你需要使用CDN镜像加速的功能</strong></a><ul><li><a href=#一源地址直接填写ip><strong>（一）源地址直接填写IP</strong></a></li><li><a href=#二采用http-upstream模块server指令><strong>（二）采用HTTP Upstream模块server指令</strong></a></li></ul></li><li><a href=#三最简单的前端全缓存反向代理脚本><strong>三、最简单的前端全缓存+反向代理脚本</strong></a></li><li><a href=#四多个服务器负载均衡的配置><strong>四、多个服务器负载均衡的配置</strong></a><ul><li><a href=#nginx负载均衡指令>Nginx负载均衡指令</a></li><li><a href=#http-upstream模块>HTTP Upstream模块</a></li></ul></li></ul></nav></aside></header><article class="markdown book-post"><h1 class=book-post-title><a href=/blog/linux/H1v8I4cLAf/>Nginx反向代理、镜像缓存加速及负载均衡的配置</a></h1><div class=book-post-meta><span class=book-post-meta-date>2018-05-14</span>
<span class=book-post-meta-separator-categories>&nbsp; | &nbsp;</span>
<span class=book-post-meta-categories><a href=/categories/linux/>Linux</a>
</span><span class=book-post-meta-separator-tags>&nbsp; | &nbsp;</span>
<span class=book-post-meta-tags><a href=/tags/linux/>Linux</a></span></div><blockquote><p>none</p></blockquote><p>Nginx已经具备Squid所拥有的Web缓存加速功能、清除指定URL缓存的功能。而在性能上，Nginx对多核CPU的利用，胜过Squid不少。另外，在反向代理、负载均衡、健康检查、后端服务器故障转移、Rewrite重写、易用性上，Nginx也比Squid强大得多。</p><p>这使得一台Nginx可以同时作为“负载均衡服务器”与“Web缓存服务器”来使用。</p><p>常规安装nginx的过程，这里就不详述了，这里只介绍nginx的配置文件的配置</p><h2 id=一nginx反向代理的基本格式也就是最简单反向代理配置文件><strong>一、nginx反向代理的基本格式，也就是最简单反向代理配置文件</strong>
<a class=anchor href=#%e4%b8%80nginx%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a0%bc%e5%bc%8f%e4%b9%9f%e5%b0%b1%e6%98%af%e6%9c%80%e7%ae%80%e5%8d%95%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6>#</a></h2><pre tabindex=0><code>server
{
listen 80;
server_name vpsmm.com;
location / {
proxy_pass http://cache.vpsmm.com/;
proxy_redirect off;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
}
</code></pre><h2 id=二如果你需要使用cdn镜像加速的功能><strong>二、如果你需要使用CDN镜像加速的功能</strong>
<a class=anchor href=#%e4%ba%8c%e5%a6%82%e6%9e%9c%e4%bd%a0%e9%9c%80%e8%a6%81%e4%bd%bf%e7%94%a8cdn%e9%95%9c%e5%83%8f%e5%8a%a0%e9%80%9f%e7%9a%84%e5%8a%9f%e8%83%bd>#</a></h2><p><strong>也就是前端域名和后端域名相同，可以使用下面两种方法：</strong></p><h3 id=一源地址直接填写ip><strong>（一）源地址直接填写IP</strong>
<a class=anchor href=#%e4%b8%80%e6%ba%90%e5%9c%b0%e5%9d%80%e7%9b%b4%e6%8e%a5%e5%a1%ab%e5%86%99ip>#</a></h3><pre tabindex=0><code>server
{
listen 80;
server_name vpsmm.com;
location / {
proxy_pass http://192.168.0.110; //如果不是80端口，可以加上端口http://IP:81
proxy_redirect off;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
}
</code></pre><h3 id=二采用http-upstream模块server指令><strong>（二）采用HTTP Upstream模块server指令</strong>
<a class=anchor href=#%e4%ba%8c%e9%87%87%e7%94%a8http-upstream%e6%a8%a1%e5%9d%97server%e6%8c%87%e4%bb%a4>#</a></h3><pre tabindex=0><code>upstream cdn {
server 192.168.0.110:80 weight=5;
server 192.168.0.121:80 weight=5;
}
server
{
listen 80;
server_name vpsmm.com;
location / {
proxy_pass http://cdn;
proxy_redirect off;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
}
</code></pre><h2 id=三最简单的前端全缓存反向代理脚本><strong>三、最简单的前端全缓存+反向代理脚本</strong>
<a class=anchor href=#%e4%b8%89%e6%9c%80%e7%ae%80%e5%8d%95%e7%9a%84%e5%89%8d%e7%ab%af%e5%85%a8%e7%bc%93%e5%ad%98%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86%e8%84%9a%e6%9c%ac>#</a></h2><pre tabindex=0><code>mkdir /home/cache/path -p #新建2个目录，放置缓存文件
mkdir /home/cache/temp -p
</code></pre><p>修改 /usr/local/nginx/conf/nginx.conf 新增以下代码，主要是缓存相关设置，请放置于 http{ ##这里 } 中，一般加在</p><p>log_format 上面或下面均可：</p><pre tabindex=0><code>client_body_buffer_size 512k;
proxy_connect_timeout 5;
proxy_read_timeout 60;
proxy_send_timeout 5;
proxy_buffer_size 16k;
proxy_buffers 4 64k;
proxy_busy_buffers_size 128k;
proxy_temp_file_write_size 128k;
proxy_temp_path /home/cache/temp;
proxy_cache_path /home/cache/path levels=1:2 keys_zone=cache_one:500m inactive=7d max_size=30g;
</code></pre><p>#500m是内存占用，7d是7天无访问删除，30g是缓存占具硬盘空间</p><p>以下为虚拟主机配置文件，可另存成 .conf 放置于 vhost 下面：</p><pre tabindex=0><code>server
{
listen 80;
server_name vpsmm.com; #主机名
location / {
proxy_cache cache_one;
proxy_cache_valid 200 304 3d; #正常状态缓存时间3天
proxy_cache_key $host$uri$is_args$args;
proxy_pass http://cache.vpsmm.com/; #反代的网站
proxy_redirect off;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
expires 10d; #默认10天缓存
access_log /home/wwwlogs/vpsmm.log access; #日志文件
}
}
</code></pre><p>点击几下网站，df -sh 命令，查看 /home/cache</p><p>目录大小，即可测试是否缓存成功。此脚本为前端全缓存，后端动态更新后，前端不会自动修改。可手动清理cache目录下文件。这个方法，可以用纯静态的形式来防CC，如果你的动态博客，受到CC攻击，可以尝试一下。</p><p>以下为完整的nginx虚拟主机的配置文件</p><pre tabindex=0><code>log_format jjhr.net &#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39;
&#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39;
&#39;&#34;$http_user_agent&#34; $http_x_forwarded_for&#39;;
# 反向代理参数，具体自行搜索按需配置吧
proxy_connect_timeout 5;
proxy_read_timeout 60;
proxy_send_timeout 5;
proxy_buffer_size 16k;
proxy_buffers 4 64k;
proxy_busy_buffers_size 128k;
proxy_temp_file_write_size 128k;

# 配置临时目录、缓存路径（注意要先建立这2个目录，要在同一个硬盘分区，注意权限）
proxy_temp_path /var/cache/nginx_proxy_temp 1 2;
proxy_cache_path /var/cache/nginx_proxy_cache levels=1:2 keys_zone=jjhr:48m inactive=12d max_size=2g;
# keys_zone=jjhr:48m 表示这个 zone 名称为 jjhr，分配的内存大小为 48MB
# levels=1:2 表示缓存目录的第一级目录是 1 个字符，第二级目录是 2 个字符
# inactive=12d 表示这个zone中的缓存文件如果在 12 天内都没有被访问，那么文件会被cache manager 进程删除
# max_size=2G 表示这个zone的硬盘容量为 2G
server{
listen 80;
server_name jjhr.net *.jjhr.net;
index index.html index.php;
location / {
#-------------------------------------
proxy_cache jjhr;
proxy_cache_key &#34;$scheme://$host$request_uri&#34;;
proxy_cache_valid 200 304 7d;
proxy_cache_valid 301 3d;
proxy_cache_valid any 10s;
expires 1d;
#--------------------------------------
proxy_pass http://205.185.115.53;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
# wordpress 后台目录不缓存
location /wp-admin {
if ( !-e $request_filename) {
proxy_pass http://205.185.115.53;
}
}
access_log /var/log/nginx/jjhr.net.log main;
}
</code></pre><h2 id=四多个服务器负载均衡的配置><strong>四、多个服务器负载均衡的配置</strong>
<a class=anchor href=#%e5%9b%9b%e5%a4%9a%e4%b8%aa%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e7%9a%84%e9%85%8d%e7%bd%ae>#</a></h2><pre tabindex=0><code>http
{
……..
client_max_body_size 300m ; // 允许客户端请求的最大单个文件字节数
client_body_buffer_size 128k;
// 缓冲区代理缓冲用户端请求的最大字节数，可以理解为先保存到本地再传给用户
proxy_connect_timeout 600;
// 跟后端服务器连接的超时时间_发起握手等候响应超时时间
proxy_read_timeout 600;
// 连接成功后_等候后端服务器响应时间_其实已经进入后端排队之中等候处理
proxy_send_timeout 600;
proxy_buffer_size 16k; // 会保存用户的头信息，供nginx进行规则处理
proxy_buffers 4 32k; // 告诉nginx保存单个用的几个buffer最大用多大空间
proxy_busy_buffers_size 64k;
proxy_max_temp_file_size 64k;
// proxy缓存临时文件的大小
upstream clubsrv {
server 192.168.0.110:80 weight=5;
server 192.168.0.121:80 weight=5;
}
upstream mysrv {
server 192.168.0.32:80 weight=2;
server 127.0.0.1:8000 weight=8;
}
server {
listen 80;
server_name club.xywy.com;
charset gbk;
root /www;
access_log logs/bba.log combined;
//下面是第一个域名，使用clubsrv的代理
location / {
proxy_next_upstream http_502 http_504 error timeout invalid_header;
// 如果后端服务器返回502、504或执行超时等错误，自动将请求转发到upstream另一台服务器
proxy_pass http://clubsrv;
// 与上面upstream自己命名的名字填写一致
proxy_redirect off;
proxy_set_header Host club.xywy.com;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
// nginx在前端做代理，后端的日志会显示127.0.0.1，上面配置可以显示用户真实IP（还需装第三方软件，见下面的详细说明）
index index.htm index.html index.php;
}
//下面是第二个域名，使用mysrv的代理，访问www.sum.com/message目录下的
server {
listen 80;
server_name www.sum.com;
location /message {
proxy_pass http://mysrv;
proxy_set_header Host $host;
// 访问这个域名的，只有mysrv 本机可以访问
}
//访问除了/message之外的www.sum.com/ 地址，
location / {
proxy_pass http://mysrv;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
下面的配置，与上面错误返回的效果相同，这里可以不写。
error_page 500 502 503 504 /50x.html;
location = /50x.html
{
root html;
}
</code></pre><h3 id=nginx负载均衡指令>Nginx负载均衡指令
<a class=anchor href=#nginx%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e6%8c%87%e4%bb%a4>#</a></h3><p>Nginx属于软件的七层负载均衡（lvs是软件的四层负载均衡的代表），七层负载均衡软件还有L7SW（Layer7</p><p>switching）、HAProxy等。支持负载均衡的模块是Http Upstream。下面介绍此模块及他下面的几个指令</p><h3 id=http-upstream模块>HTTP Upstream模块
<a class=anchor href=#http-upstream%e6%a8%a1%e5%9d%97>#</a></h3><h4 id=1ip_hash指令>（1）ip_hash指令
<a class=anchor href=#1ip_hash%e6%8c%87%e4%bb%a4>#</a></h4><p>当对后端的多台动态应用服务器做负载均衡时，ip_hash指令将某个客户端IP的请求通过哈希算法定位到同一台后端服务器上。这样，当来自某ip用户在Sever</p><p>A上登录后，再访问该站点的其他URL时，能保证访问仍在Server A上。</p><p>如果不加ip_hash，加入用户在Server A上登录，再访问该站点其他URL，就有可能跳转到后端的Sever</p><p>B、C…..，而session记录在A上，B、C上没有，就会提示用户未登录。</p><p>注意：但这种访问不能保证后端服务器的负载均衡，可能后端有些server接受到的请求多，有些server接受的少，设置的权重值不起作用。</p><p>建议如果后端的动态应用程序服务器能做到session共享，而不用nginx上配置ip_hash的方式。</p><pre tabindex=0><code>upstream mysrv {
ip_hash;
server 192.168.0.110:80 weight=2;
server 127.0.0.1:8000 down;
server 192.168.0.212:80 weight=8;
}
</code></pre><h4 id=2server指令>（2）server指令
<a class=anchor href=#2server%e6%8c%87%e4%bb%a4>#</a></h4><p>该指令用语指定后端服务器的名称和参数。服务器的名称可以是一个域名，一个ip，端口号或UNIX Socket。</p><p>参数介绍：</p><p>weight=number ： 设置服务器权重，权重值越高，被分配到客户端请求数越多。默认为1；</p><p>max_fails=numbser ：</p><p>在fail_timeout指定的时间内对后端服务器请求失败的次数，如果检测到后端服务器无法连接及发生错误（404除外），则标记为失败。如果没有设置，默认为1。设置为0则关闭这项检查。</p><pre tabindex=0><code>fail_timeout=time ： 在经历参数max_fails设置的失败次数后，暂停的时间。
down ： 表示服务器为永久离线状态。
Backup ： 仅仅在非backup服务器全部down或繁忙的时候才启用。
配置如下：
upstream mysrv {
ip_hash;
server www.xywy.com weight=2;
server 127.0.0.1:8000 down;
server 192.168.0.212:80 max_fails=3 fail_timeout=30s;
server unix:/tmp/bakend3;
}
</code></pre></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#一nginx反向代理的基本格式也就是最简单反向代理配置文件><strong>一、nginx反向代理的基本格式，也就是最简单反向代理配置文件</strong></a></li><li><a href=#二如果你需要使用cdn镜像加速的功能><strong>二、如果你需要使用CDN镜像加速的功能</strong></a><ul><li><a href=#一源地址直接填写ip><strong>（一）源地址直接填写IP</strong></a></li><li><a href=#二采用http-upstream模块server指令><strong>（二）采用HTTP Upstream模块server指令</strong></a></li></ul></li><li><a href=#三最简单的前端全缓存反向代理脚本><strong>三、最简单的前端全缓存+反向代理脚本</strong></a></li><li><a href=#四多个服务器负载均衡的配置><strong>四、多个服务器负载均衡的配置</strong></a><ul><li><a href=#nginx负载均衡指令>Nginx负载均衡指令</a></li><li><a href=#http-upstream模块>HTTP Upstream模块</a></li></ul></li></ul></nav></div></aside></main><footer class=page-footer><p><span id=page-footer-time>载入中...</span>
<script>function secondToDate(e){if(!e)return 0;var t=new Array(0,0,0,0,0);return e>=365*24*3600&&(t[0]=parseInt(e/(365*24*3600)),e%=365*24*3600),e>=24*3600&&(t[1]=parseInt(e/(24*3600)),e%=24*3600),e>=3600&&(t[2]=parseInt(e/3600),e%=3600),e>=60&&(t[3]=parseInt(e/60),e%=60),e>0&&(t[4]=e),t}</script><script type=text/javascript language=javascript>function setTime(){var e=Math.round(new Date(Date.UTC(2016,11,1,0,0,0)).getTime()/1e3),t=Math.round(((new Date).getTime()+8*60*60*1e3)/1e3);currentTime=secondToDate(t-e),currentTimeHtml=currentTime[0]+"年"+currentTime[1]+"天"+currentTime[2]+"时"+currentTime[3]+"分"+currentTime[4]+"秒",document.getElementById("page-footer-time").innerHTML="网站运行:"+currentTimeHtml}setInterval(setTime,1e3)</script></p></footer></body></html>