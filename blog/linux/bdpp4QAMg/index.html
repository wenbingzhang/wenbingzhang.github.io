<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
简单的讲讲nginx+php的一些常用优化，以及相关的内核参数优化。


  Nginx 优化
  #


  1. TCP 与 UNIX 套接字
  #

UNIX 域套接字提供的性能略高于 TCP 套接字在回送接口上的性能（较少的数据复制，较少的上下文切换）。如果每个服务器需要支持超过 1000 个连接，请使用 TCP 套接字 - 它们可以更好地扩展。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://notes.zhangwenbing.com/blog/linux/bdpp4QAMg/"><meta property="og:site_name" content="张文兵的笔记"><meta property="og:title" content="nginx及php-fpm优化"><meta property="og:description" content=" 简单的讲讲nginx+php的一些常用优化，以及相关的内核参数优化。
Nginx 优化 # 1. TCP 与 UNIX 套接字 # UNIX 域套接字提供的性能略高于 TCP 套接字在回送接口上的性能（较少的数据复制，较少的上下文切换）。如果每个服务器需要支持超过 1000 个连接，请使用 TCP 套接字 - 它们可以更好地扩展。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-04T16:33:34+08:00"><meta property="article:modified_time" content="2020-12-04T16:33:34+08:00"><meta property="article:tag" content="Linux"><title>nginx及php-fpm优化 | 张文兵的笔记</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://notes.zhangwenbing.com/blog/linux/bdpp4QAMg/><link rel=stylesheet href=/book.min.7bc0bb908f28131671779537cc0c91a39075ed4cba93497f05888d37375171ce.css integrity="sha256-e8C7kI8oExZxd5U3zAyRo5B17Uy6k0l/BYiNNzdRcc4=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.48800af68fbedb7c84ccea7977f9fc153f33baead16235bd8ce38d14a2214a8a.js integrity="sha256-SIAK9o++23yEzOp5d/n8FT8zuurRYjW9jOONFKIhSoo=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>张文兵的笔记</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-6d1804e163fb7f5fbc576b94719a59cb class=toggle>
<label for=section-6d1804e163fb7f5fbc576b94719a59cb class="flex justify-between"><a role=button>👨🏼‍💻 编程相关</a></label><ul><li><input type=checkbox id=section-f56428119b0aac71309abf8dfea134ce class=toggle>
<label for=section-f56428119b0aac71309abf8dfea134ce class="flex justify-between"><a role=button>📔 C++</a></label><ul><li><input type=checkbox id=section-fb47b341e1fcc9c423db5ed573183d82 class=toggle>
<label for=section-fb47b341e1fcc9c423db5ed573183d82 class="flex justify-between"><a role=button>🔖 MacOS相关</a></label><ul><li><a href=/notes/2024/06/06/sf4ff6x8cuyhvzougj9dwg/>📝 MacOS签名</a></li><li><a href=/notes/2024/05/28/3txbbb7iruppjsg4p7rwnb/>📝 MacOS堆栈大小</a></li></ul></li><li><input type=checkbox id=section-b76e207ac5e871ff00bceef2a05945c7 class=toggle>
<label for=section-b76e207ac5e871ff00bceef2a05945c7 class="flex justify-between"><a role=button>🔖 Qt</a></label><ul><li><a href=/notes/2024/08/01/rnc4n7cfifidx8ca2rhjme/>📝 QML鼠标事件</a></li><li><a href=/notes/2024/08/06/ny773erqjgbzmzgfikfvds/>📝 QML虚拟列表</a></li></ul></li><li><input type=checkbox id=section-03639da61c682690825d49325c54c7e8 class=toggle>
<label for=section-03639da61c682690825d49325c54c7e8 class="flex justify-between"><a role=button>🔖 Python</a></label><ul><li><a href=/notes/2025/02/10/7auahqg8nnxm5ydhxzqrnr/>📝 调用Python代码</a></li><li><a href=/notes/2025/02/10/gqci9riugfetribe6j6fou/>📝 调用Python方法</a></li><li><a href=/notes/2025/02/10/pkdrvn9md3ggfmbxahx4ef/>📝 注册Python模块</a></li></ul></li></ul></li><li><input type=checkbox id=section-aea9addc7ea0cf58a2c2c9ec52f959c9 class=toggle>
<label for=section-aea9addc7ea0cf58a2c2c9ec52f959c9 class="flex justify-between"><a role=button>📔 Git</a></label><ul><li><a href=/notes/2024/03/11/j3c62fv8dglvf2kg975zlv/>📝 标签操作</a></li><li><a href=/notes/2024/03/14/5kqlzqjqawbxf2t6vusxar/>📝 删除Commit</a></li><li><a href=/blog/git/WNYzxj6GR/>📝 git之删除远程分支</a></li><li><a href=/blog/git/-fZeBsu3T/>📝 git更新.gitignore</a></li><li><a href=/blog/git/H1Krv6b-4/>📝 git修改历史cimmit信息</a></li><li><a href=/blog/git/By9OI51xN/>📝 git基础笔记</a></li><li><a href=/blog/git/Hk6GGp6cQ/>📝 Git回滚到某个commit</a></li></ul></li></ul></li><li><input type=checkbox id=section-caf3b688bb818cc6cfc82165db78eba5 class=toggle>
<label for=section-caf3b688bb818cc6cfc82165db78eba5 class="flex justify-between"><a role=button>♻️ 回收归档</a></label><ul><li><input type=checkbox id=section-4a72fedb3d7dfc18dbbcab83511bf75a class=toggle>
<label for=section-4a72fedb3d7dfc18dbbcab83511bf75a class="flex justify-between"><a role=button>📔 Rust</a></label><ul><li><input type=checkbox id=section-8aa26b33a0315c1be70924160dd1a92c class=toggle>
<label for=section-8aa26b33a0315c1be70924160dd1a92c class="flex justify-between"><a role=button>🔖 学习笔记</a></label><ul><li><a href=/notes/2024/03/06/e3ksq3zkmps14gcxuirwzx/>📝 所有权</a></li><li><a href=/notes/2024/03/06/o4arkqgfnqygr5ckif2gkk/>📝 借用与引用</a></li></ul></li></ul></li></ul></li><li><a href=/links/>🤝 友情链接</a></li></ul><ul><li><a href=/articles/>📚 我的文章</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>nginx及php-fpm优化</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#nginx-优化>Nginx 优化</a><ul><li><a href=#1-tcp-与-unix-套接字>1. TCP 与 UNIX 套接字</a></li><li><a href=#2-调整-worker_processes-参数>2. 调整 worker_processes 参数</a></li><li><a href=#3-禁用访问日志>3. 禁用访问日志</a></li><li><a href=#4-开启-gzip-压缩>4. 开启 gzip 压缩</a></li><li><a href=#5-缓存访问频次较高的文件>5. 缓存访问频次较高的文件</a></li><li><a href=#6-调整客户端超时>6. 调整客户端超时</a></li><li><a href=#7-调整输出缓存>7. 调整输出缓存</a></li><li><a href=#8-负载均衡策略>8. 负载均衡策略</a></li><li><a href=#9-持续监控日志>9. 持续监控日志</a></li></ul></li><li><a href=#php-fpm-优化>PHP-fpm 优化</a><ul><li><a href=#1-修改进程管理模式>1. 修改进程管理模式</a></li><li><a href=#2-释放内存的配置>2. 释放内存的配置</a></li><li><a href=#3-php-fpm-慢日志>3. php-fpm 慢日志</a></li></ul></li><li><a href=#内核优化>内核优化</a><ul><li><a href=#1-time_wait产生原因>1. TIME_WAIT产生原因：</a></li><li><a href=#2-过多time_wait危害>2. 过多TIME_WAIT危害</a></li><li><a href=#3-解决方法>3. 解决方法</a></li></ul></li></ul></nav></aside></header><article class="markdown book-post"><h1 class=book-post-title><a href=/blog/linux/bdpp4QAMg/>nginx及php-fpm优化</a></h1><div class=book-post-meta><span class=book-post-meta-date>2020-12-04</span>
<span class=book-post-meta-separator-categories>&nbsp; | &nbsp;</span>
<span class=book-post-meta-categories><a href=/categories/linux/>Linux</a>
</span><span class=book-post-meta-separator-tags>&nbsp; | &nbsp;</span>
<span class=book-post-meta-tags><a href=/tags/linux/>Linux</a></span></div><blockquote><p>简单的讲讲nginx+php的一些常用优化，以及相关的内核参数优化。</p></blockquote><h2 id=nginx-优化>Nginx 优化
<a class=anchor href=#nginx-%e4%bc%98%e5%8c%96>#</a></h2><h3 id=1-tcp-与-unix-套接字>1. TCP 与 UNIX 套接字
<a class=anchor href=#1-tcp-%e4%b8%8e-unix-%e5%a5%97%e6%8e%a5%e5%ad%97>#</a></h3><p>UNIX 域套接字提供的性能略高于 TCP 套接字在回送接口上的性能（较少的数据复制，较少的上下文切换）。如果每个服务器需要支持超过 1000 个连接，请使用 TCP 套接字 - 它们可以更好地扩展。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>upstream backend
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  server unix:/var/run/fastcgi.sock;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=2-调整-worker_processes-参数>2. 调整 worker_processes 参数
<a class=anchor href=#2-%e8%b0%83%e6%95%b4-worker_processes-%e5%8f%82%e6%95%b0>#</a></h3><p>现代硬件是多处理器，NGINX 可以利用多个物理或虚拟处理器。在大多数情况下，您的 Web 服务器计算机不会配置为处理多个工作负载（例如同时提供 Web 服务器和打印服务器的服务），因此您需要配置 NGINX 以使用所有可用的处理器，因为 NGINX 工作进程是不是多线程的。</p><p>将 nginx.conf 文件中的 worker_processes 设置为计算机所具有的核心数。</p><p>当你在它的时候，增加 worker_connections 的数量（每个核心应该处理多少个连接）并将 multi_accept 设置为 ON，如果你在 Linux 上则设置为 epoll：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>worker_processes 4;
</span></span><span style=display:flex><span>events
</span></span><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  worker_connections 1024;
</span></span><span style=display:flex><span>  multi_accept on;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=3-禁用访问日志>3. 禁用访问日志
<a class=anchor href=#3-%e7%a6%81%e7%94%a8%e8%ae%bf%e9%97%ae%e6%97%a5%e5%bf%97>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>access_log off;
</span></span><span style=display:flex><span>log_not_found off;
</span></span><span style=display:flex><span>error_log /var/log/nginx-error.log warn;
</span></span></code></pre></div><p>如果有需要不可以关闭，至少是缓存他们</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>access_log /var/log/nginx/access.log main buffer<span style=color:#f92672>=</span>16k;
</span></span></code></pre></div><h3 id=4-开启-gzip-压缩>4. 开启 gzip 压缩
<a class=anchor href=#4-%e5%bc%80%e5%90%af-gzip-%e5%8e%8b%e7%bc%a9>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gzip on;
</span></span><span style=display:flex><span>gzip_disable <span style=color:#e6db74>&#34;msie6&#34;</span>;
</span></span><span style=display:flex><span>gzip_vary on;
</span></span><span style=display:flex><span>gzip_proxied any;
</span></span><span style=display:flex><span>gzip_comp_level 6;
</span></span><span style=display:flex><span>gzip_min_length 1100;
</span></span><span style=display:flex><span>gzip_buffers <span style=color:#ae81ff>16</span> 8k;
</span></span><span style=display:flex><span>gzip_http_version 1.1;
</span></span><span style=display:flex><span>gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
</span></span></code></pre></div><h3 id=5-缓存访问频次较高的文件>5. 缓存访问频次较高的文件
<a class=anchor href=#5-%e7%bc%93%e5%ad%98%e8%ae%bf%e9%97%ae%e9%a2%91%e6%ac%a1%e8%be%83%e9%ab%98%e7%9a%84%e6%96%87%e4%bb%b6>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>open_file_cache max<span style=color:#f92672>=</span><span style=color:#ae81ff>2000</span> inactive<span style=color:#f92672>=</span>20s;
</span></span><span style=display:flex><span>open_file_cache_valid 60s;
</span></span><span style=display:flex><span>open_file_cache_min_uses 5;
</span></span><span style=display:flex><span>open_file_cache_errors off;
</span></span></code></pre></div><h3 id=6-调整客户端超时>6. 调整客户端超时
<a class=anchor href=#6-%e8%b0%83%e6%95%b4%e5%ae%a2%e6%88%b7%e7%ab%af%e8%b6%85%e6%97%b6>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>client_max_body_size 50M;
</span></span><span style=display:flex><span>client_body_buffer_size 1m;
</span></span><span style=display:flex><span>client_body_timeout 15;
</span></span><span style=display:flex><span>client_header_timeout 15;
</span></span><span style=display:flex><span>keepalive_timeout <span style=color:#ae81ff>2</span> 2;
</span></span><span style=display:flex><span>send_timeout 15;
</span></span><span style=display:flex><span>sendfile on;
</span></span><span style=display:flex><span>tcp_nopush on;
</span></span><span style=display:flex><span>tcp_nodelay on;
</span></span></code></pre></div><h3 id=7-调整输出缓存>7. 调整输出缓存
<a class=anchor href=#7-%e8%b0%83%e6%95%b4%e8%be%93%e5%87%ba%e7%bc%93%e5%ad%98>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>fastcgi_buffers <span style=color:#ae81ff>256</span> 16k;
</span></span><span style=display:flex><span>fastcgi_buffer_size 128k;
</span></span><span style=display:flex><span>fastcgi_connect_timeout 3s;
</span></span><span style=display:flex><span>fastcgi_send_timeout 120s;
</span></span><span style=display:flex><span>fastcgi_read_timeout 120s;
</span></span><span style=display:flex><span>fastcgi_busy_buffers_size 256k;
</span></span><span style=display:flex><span>fastcgi_temp_file_write_size 256k;
</span></span><span style=display:flex><span>reset_timedout_connection on;
</span></span><span style=display:flex><span>server_names_hash_bucket_size 100;
</span></span></code></pre></div><h3 id=8-负载均衡策略>8. 负载均衡策略
<a class=anchor href=#8-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e7%ad%96%e7%95%a5>#</a></h3><p>Nginx 提供轮询（round robin）、用户 IP 哈希（client IP）和指定权重 3 种方式。</p><p>默认情况下，Nginx 会为你提供轮询作为负载均衡策略。但是这并不一定能够让你满意。比如，某一时段内的一连串访问都是由同一个用户 Michael 发起的，那么第一次 Michael 的请求可能是 backend2，而下一次是 backend3，然后是 backend1、backend2、backend3…… 在大多数应用场景中，这样并不高效。当然，也正因如此，Nginx 为你提供了一个按照 Michael、Jason、David 等等这些乱七八糟的用户的 IP 来 hash 的方式，这样每个 client 的访问请求都会被甩给同一个后端服务器。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>upstream backend <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  ip_hash;
</span></span><span style=display:flex><span>  server unix:/var/run/php7.2-fpm.sock1 weight<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span> max_fails<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> fail_timeout<span style=color:#f92672>=</span>5;
</span></span><span style=display:flex><span>  server unix:/var/run/php7.2-fpm.sock2 weight<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span> max_fails<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span> fail_timeout<span style=color:#f92672>=</span>5;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=9-持续监控日志>9. 持续监控日志
<a class=anchor href=#9-%e6%8c%81%e7%bb%ad%e7%9b%91%e6%8e%a7%e6%97%a5%e5%bf%97>#</a></h3><p>尤其是在调优最初期，在一个窗口</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail -f /var/log/nginx/error.log
</span></span></code></pre></div><p>在另外两个窗口分别：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail -f /var/log/php-fpm/error.log
</span></span><span style=display:flex><span>tail -f /var/log/php-fpm/www-error.log
</span></span></code></pre></div><h2 id=php-fpm-优化>PHP-fpm 优化
<a class=anchor href=#php-fpm-%e4%bc%98%e5%8c%96>#</a></h2><h3 id=1-修改进程管理模式>1. 修改进程管理模式
<a class=anchor href=#1-%e4%bf%ae%e6%94%b9%e8%bf%9b%e7%a8%8b%e7%ae%a1%e7%90%86%e6%a8%a1%e5%bc%8f>#</a></h3><p>static 管理模式适合比较大内存的服务器，而 dynamic 则适合小内存的服务器，你可以设置一个 pm.min_spare_servers 和 pm.max_spare_servers 合理范围，这样进程数会不断变动。ondemand 模式则更加适合微小内存，例如 512MB 或者 256MB 内存，以及对可用性要求不高的环境。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pm <span style=color:#f92672>=</span> dynamic <span style=color:#75715e>#指定进程管理方式，有3种可供选择：static、dynamic和ondemand。</span>
</span></span><span style=display:flex><span>pm.max_children <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span> <span style=color:#75715e>#static模式下创建的子进程数或dynamic模式下同一时刻允许最大的php-fpm子进程数量。</span>
</span></span><span style=display:flex><span>pm.start_servers <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#75715e>#动态方式下的起始php-fpm进程数量。</span>
</span></span><span style=display:flex><span>pm.min_spare_servers <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span> <span style=color:#75715e>#动态方式下服务器空闲时最小php-fpm进程数量。</span>
</span></span><span style=display:flex><span>pm.max_spare_servers <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span> <span style=color:#75715e>#动态方式下服务器空闲时最大php-fpm进程数量。</span>
</span></span><span style=display:flex><span>pm.max_requests <span style=color:#f92672>=</span> <span style=color:#ae81ff>2000</span> <span style=color:#75715e>#php-fpm子进程能处理的最大请求数。</span>
</span></span><span style=display:flex><span>pm.process_idle_timeout <span style=color:#f92672>=</span> 10s
</span></span><span style=display:flex><span>request_terminate_timeout <span style=color:#f92672>=</span> <span style=color:#ae81ff>120</span>
</span></span></code></pre></div><p>pm = static，始终保持一个固定数量的子进程，这个数由 pm.max_children 定义，这种方式很不灵活，也通常不是默认的。</p><p>pm = dynamic，启动时会产生固定数量的子进程（由 pm.start_servers 控制）可以理解成最小子进程数，而最大子进程数则由 pm.max_children 去控制，子进程数会在最大和最小数范围中变化。闲置的子进程数还可以由另 2 个配置控制，分别是 pm.min_spare_servers 和 pm.max_spare_servers。如果闲置的子进程超出了 pm.max_spare_servers，则会被杀掉。小于 pm.min_spare_servers 则会启动进程（注意，pm.max_spare_servers 应小于 pm.max_children）。</p><p>pm = ondemand，这种模式和 pm = dynamic 相反，把内存放在第一位，每个闲置进程在持续闲置了 pm.process_idle_timeout 秒后就会被杀掉，如果服务器长时间没有请求，就只会有一个 php-fpm 主进程。弊端是遇到高峰期或者如果 pm.process_idle_timeout 的值太短的话，容易出现 504 Gateway Time-out 错误，因此 pm = dynamic 和 pm = ondemand 谁更适合视实际情况而定。</p><h3 id=2-释放内存的配置>2. 释放内存的配置
<a class=anchor href=#2-%e9%87%8a%e6%94%be%e5%86%85%e5%ad%98%e7%9a%84%e9%85%8d%e7%bd%ae>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pm.max_requests <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>
</span></span></code></pre></div><p>设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ‘0’ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.</p><p>也就是当一个 PHP-CGI 进程处理的请求数累积到 1000 个后，自动重启该进程，防止第三方库造成的内存泄漏。 重启时可能会导致 502 错误，在高并发站点时有出现。</p><h3 id=3-php-fpm-慢日志>3. php-fpm 慢日志
<a class=anchor href=#3-php-fpm-%e6%85%a2%e6%97%a5%e5%bf%97>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>request_terminate_timeout <span style=color:#f92672>=</span> 30s <span style=color:#75715e>#将执行时间太长的进程直接终止</span>
</span></span><span style=display:flex><span>request_slowlog_timeout <span style=color:#f92672>=</span> 2s <span style=color:#75715e>#2秒</span>
</span></span><span style=display:flex><span>slowlog <span style=color:#f92672>=</span> log/$pool.log.slow <span style=color:#75715e>#日志文件</span>
</span></span></code></pre></div><h2 id=内核优化>内核优化
<a class=anchor href=#%e5%86%85%e6%a0%b8%e4%bc%98%e5%8c%96>#</a></h2><h3 id=1-time_wait产生原因>1. TIME_WAIT产生原因：
<a class=anchor href=#1-time_wait%e4%ba%a7%e7%94%9f%e5%8e%9f%e5%9b%a0>#</a></h3><p>1、nginx现有的负载均衡模块实现php fastcgi负载均衡，nginx使用了短连接方式，所以会造成大量处于TIME_WAIT状态的连接。</p><p>2、TCP/IP设计者本来是这么设计的</p><p>主要有两个原因</p><p>(1) 防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）</p><p>(2) 可靠的关闭TCP连接</p><p>在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。</p><h3 id=2-过多time_wait危害>2. 过多TIME_WAIT危害
<a class=anchor href=#2-%e8%bf%87%e5%a4%9atime_wait%e5%8d%b1%e5%ae%b3>#</a></h3><p>TIME_WAIT 并不会占用很大资源的，除非受到攻击。只要把TIME_WAIT所占用内存控制在一定范围。一般默认最大是35600条TIME_WAIT。</p><h3 id=3-解决方法>3. 解决方法
<a class=anchor href=#3-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95>#</a></h3><p>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭。</p><p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭。</p><p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p><p>net.ipv4.tcp_fin_timeout = 30 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。</p><p>net.ipv4.tcp_keepalive_time = 1200 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</p><p>net.ipv4.ip_local_port_range = 1024 65000 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</p><p>net.ipv4.tcp_max_syn_backlog = 8192 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</p><p>net.ipv4.tcp_max_tw_buckets = 5000 表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默 认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。</p><p>注:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#a6e22e>net.ipv4.tcp_tw_reuse</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>net.ipv4.tcp_tw_recycle</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>1</span>
</span></span></code></pre></div><p>设置这两个参数： reuse是表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接； recyse是加速TIME-WAIT sockets回收</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#nginx-优化>Nginx 优化</a><ul><li><a href=#1-tcp-与-unix-套接字>1. TCP 与 UNIX 套接字</a></li><li><a href=#2-调整-worker_processes-参数>2. 调整 worker_processes 参数</a></li><li><a href=#3-禁用访问日志>3. 禁用访问日志</a></li><li><a href=#4-开启-gzip-压缩>4. 开启 gzip 压缩</a></li><li><a href=#5-缓存访问频次较高的文件>5. 缓存访问频次较高的文件</a></li><li><a href=#6-调整客户端超时>6. 调整客户端超时</a></li><li><a href=#7-调整输出缓存>7. 调整输出缓存</a></li><li><a href=#8-负载均衡策略>8. 负载均衡策略</a></li><li><a href=#9-持续监控日志>9. 持续监控日志</a></li></ul></li><li><a href=#php-fpm-优化>PHP-fpm 优化</a><ul><li><a href=#1-修改进程管理模式>1. 修改进程管理模式</a></li><li><a href=#2-释放内存的配置>2. 释放内存的配置</a></li><li><a href=#3-php-fpm-慢日志>3. php-fpm 慢日志</a></li></ul></li><li><a href=#内核优化>内核优化</a><ul><li><a href=#1-time_wait产生原因>1. TIME_WAIT产生原因：</a></li><li><a href=#2-过多time_wait危害>2. 过多TIME_WAIT危害</a></li><li><a href=#3-解决方法>3. 解决方法</a></li></ul></li></ul></nav></div></aside></main><footer class=page-footer><p><span id=page-footer-time>载入中...</span>
<script>function secondToDate(e){if(!e)return 0;var t=new Array(0,0,0,0,0);return e>=365*24*3600&&(t[0]=parseInt(e/(365*24*3600)),e%=365*24*3600),e>=24*3600&&(t[1]=parseInt(e/(24*3600)),e%=24*3600),e>=3600&&(t[2]=parseInt(e/3600),e%=3600),e>=60&&(t[3]=parseInt(e/60),e%=60),e>0&&(t[4]=e),t}</script><script type=text/javascript language=javascript>function setTime(){var e=Math.round(new Date(Date.UTC(2016,11,1,0,0,0)).getTime()/1e3),t=Math.round(((new Date).getTime()+8*60*60*1e3)/1e3);currentTime=secondToDate(t-e),currentTimeHtml=currentTime[0]+"年"+currentTime[1]+"天"+currentTime[2]+"时"+currentTime[3]+"分"+currentTime[4]+"秒",document.getElementById("page-footer-time").innerHTML="网站运行:"+currentTimeHtml}setInterval(setTime,1e3)</script></p></footer></body></html>